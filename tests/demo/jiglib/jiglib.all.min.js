jigLib={};
	
jigLib.extend=function(dest,source){
	for(proto in source.prototype){
		dest.prototype[proto]=source.prototype[proto];
	}
	dest.prototype.Super=source;
};(function(jigLib){
	jigLib.JConfig={
		solverType: "ACCUMULATED", //allowable value: FAST,NORMAL,ACCUMULATED						// WAS ACCUMULATED
		boxCollisionsType: "EDGEBASE", //allowable value: EDGEBASE or SORTBASE
		rotationType: "DEGREES", // can be either RADIANS or DEGREES;								// WAS DEGREES
		aabbDetection: true, //if execute the aabb detection;
		doShockStep:  true, //if do a shock step to help stacking.
		allowedPenetration: 0.01, // How much penetration to allow									// WAS 0.01
		collToll: 0.05, // the tolerance for collision detection 									// WAS 0.1
		velThreshold: 0.5,
		angVelThreshold: 5,
		posThreshold: 0.2,// change for detecting position changes during deactivation
		orientThreshold: 0.2, // change for detecting orientation changes during deactivation.
		deactivationTime: 0.5, // how long it takes to go from active to frozen when stationary.	// WAS 1
		numPenetrationRelaxationTimesteps: 50, // number of timesteps to resolve penetration over
		numCollisionIterations: 4, // number of collision iterations
		numContactIterations: 8, // number of contact iterations
		numConstraintIterations:  15 // number of Constraint iteratrions
	};
	 
})(jigLib);
// glMatrix v0.9.4
(function(jigLib){
glMatrixArrayType=typeof Float32Array!="undefined"?Float32Array:typeof WebGLFloatArray!="undefined"?WebGLFloatArray:Array;var vec3={};vec3.create=function(a){var b=new glMatrixArrayType(3);if(a){b[0]=a[0];b[1]=a[1];b[2]=a[2]}return b};vec3.set=function(a,b){b[0]=a[0];b[1]=a[1];b[2]=a[2];return b};vec3.add=function(a,b,c){if(!c||a==c){a[0]+=b[0];a[1]+=b[1];a[2]+=b[2];return a}c[0]=a[0]+b[0];c[1]=a[1]+b[1];c[2]=a[2]+b[2];return c};
vec3.subtract=function(a,b,c){if(!c||a==c){a[0]-=b[0];a[1]-=b[1];a[2]-=b[2];return a}c[0]=a[0]-b[0];c[1]=a[1]-b[1];c[2]=a[2]-b[2];return c};vec3.negate=function(a,b){b||(b=a);b[0]=-a[0];b[1]=-a[1];b[2]=-a[2];return b};vec3.scale=function(a,b,c){if(!c||a==c){a[0]*=b;a[1]*=b;a[2]*=b;return a}c[0]=a[0]*b;c[1]=a[1]*b;c[2]=a[2]*b;return c};
vec3.normalize=function(a,b){b||(b=a);var c=a[0],d=a[1],e=a[2],g=Math.sqrt(c*c+d*d+e*e);if(g){if(g==1){b[0]=c;b[1]=d;b[2]=e;return b}}else{b[0]=0;b[1]=0;b[2]=0;return b}g=1/g;b[0]=c*g;b[1]=d*g;b[2]=e*g;return b};vec3.cross=function(a,b,c){c||(c=a);var d=a[0],e=a[1];a=a[2];var g=b[0],f=b[1];b=b[2];c[0]=e*b-a*f;c[1]=a*g-d*b;c[2]=d*f-e*g;return c};vec3.length=function(a){var b=a[0],c=a[1];a=a[2];return Math.sqrt(b*b+c*c+a*a)};vec3.dot=function(a,b){return a[0]*b[0]+a[1]*b[1]+a[2]*b[2]};
vec3.direction=function(a,b,c){c||(c=a);var d=a[0]-b[0],e=a[1]-b[1];a=a[2]-b[2];b=Math.sqrt(d*d+e*e+a*a);if(!b){c[0]=0;c[1]=0;c[2]=0;return c}b=1/b;c[0]=d*b;c[1]=e*b;c[2]=a*b;return c};vec3.str=function(a){return"["+a[0]+", "+a[1]+", "+a[2]+"]"};var mat3={};mat3.create=function(a){var b=new glMatrixArrayType(9);if(a){b[0]=a[0];b[1]=a[1];b[2]=a[2];b[3]=a[3];b[4]=a[4];b[5]=a[5];b[6]=a[6];b[7]=a[7];b[8]=a[8];b[9]=a[9]}return b};
mat3.set=function(a,b){b[0]=a[0];b[1]=a[1];b[2]=a[2];b[3]=a[3];b[4]=a[4];b[5]=a[5];b[6]=a[6];b[7]=a[7];b[8]=a[8];return b};mat3.identity=function(a){a[0]=1;a[1]=0;a[2]=0;a[3]=0;a[4]=1;a[5]=0;a[6]=0;a[7]=0;a[8]=1;return a};mat3.toMat4=function(a,b){b||(b=mat4.create());b[0]=a[0];b[1]=a[1];b[2]=a[2];b[3]=0;b[4]=a[3];b[5]=a[4];b[6]=a[5];b[7]=0;b[8]=a[6];b[9]=a[7];b[10]=a[8];b[11]=0;b[12]=0;b[13]=0;b[14]=0;b[15]=1;return b};
mat3.str=function(a){return"["+a[0]+", "+a[1]+", "+a[2]+", "+a[3]+", "+a[4]+", "+a[5]+", "+a[6]+", "+a[7]+", "+a[8]+"]"};var mat4={};mat4.create=function(a){var b=new glMatrixArrayType(16);if(a){b[0]=a[0];b[1]=a[1];b[2]=a[2];b[3]=a[3];b[4]=a[4];b[5]=a[5];b[6]=a[6];b[7]=a[7];b[8]=a[8];b[9]=a[9];b[10]=a[10];b[11]=a[11];b[12]=a[12];b[13]=a[13];b[14]=a[14];b[15]=a[15]}return b};
mat4.set=function(a,b){b[0]=a[0];b[1]=a[1];b[2]=a[2];b[3]=a[3];b[4]=a[4];b[5]=a[5];b[6]=a[6];b[7]=a[7];b[8]=a[8];b[9]=a[9];b[10]=a[10];b[11]=a[11];b[12]=a[12];b[13]=a[13];b[14]=a[14];b[15]=a[15];return b};mat4.identity=function(a){a[0]=1;a[1]=0;a[2]=0;a[3]=0;a[4]=0;a[5]=1;a[6]=0;a[7]=0;a[8]=0;a[9]=0;a[10]=1;a[11]=0;a[12]=0;a[13]=0;a[14]=0;a[15]=1;return a};
mat4.transpose=function(a,b){if(!b||a==b){var c=a[1],d=a[2],e=a[3],g=a[6],f=a[7],h=a[11];a[1]=a[4];a[2]=a[8];a[3]=a[12];a[4]=c;a[6]=a[9];a[7]=a[13];a[8]=d;a[9]=g;a[11]=a[14];a[12]=e;a[13]=f;a[14]=h;return a}b[0]=a[0];b[1]=a[4];b[2]=a[8];b[3]=a[12];b[4]=a[1];b[5]=a[5];b[6]=a[9];b[7]=a[13];b[8]=a[2];b[9]=a[6];b[10]=a[10];b[11]=a[14];b[12]=a[3];b[13]=a[7];b[14]=a[11];b[15]=a[15];return b};
mat4.determinant=function(a){var b=a[0],c=a[1],d=a[2],e=a[3],g=a[4],f=a[5],h=a[6],i=a[7],j=a[8],k=a[9],l=a[10],o=a[11],m=a[12],n=a[13],p=a[14];a=a[15];return m*k*h*e-j*n*h*e-m*f*l*e+g*n*l*e+j*f*p*e-g*k*p*e-m*k*d*i+j*n*d*i+m*c*l*i-b*n*l*i-j*c*p*i+b*k*p*i+m*f*d*o-g*n*d*o-m*c*h*o+b*n*h*o+g*c*p*o-b*f*p*o-j*f*d*a+g*k*d*a+j*c*h*a-b*k*h*a-g*c*l*a+b*f*l*a};
mat4.inverse=function(a,b){b||(b=a);var c=a[0],d=a[1],e=a[2],g=a[3],f=a[4],h=a[5],i=a[6],j=a[7],k=a[8],l=a[9],o=a[10],m=a[11],n=a[12],p=a[13],r=a[14],s=a[15],A=c*h-d*f,B=c*i-e*f,t=c*j-g*f,u=d*i-e*h,v=d*j-g*h,w=e*j-g*i,x=k*p-l*n,y=k*r-o*n,z=k*s-m*n,C=l*r-o*p,D=l*s-m*p,E=o*s-m*r,q=1/(A*E-B*D+t*C+u*z-v*y+w*x);b[0]=(h*E-i*D+j*C)*q;b[1]=(-d*E+e*D-g*C)*q;b[2]=(p*w-r*v+s*u)*q;b[3]=(-l*w+o*v-m*u)*q;b[4]=(-f*E+i*z-j*y)*q;b[5]=(c*E-e*z+g*y)*q;b[6]=(-n*w+r*t-s*B)*q;b[7]=(k*w-o*t+m*B)*q;b[8]=(f*D-h*z+j*x)*q;
b[9]=(-c*D+d*z-g*x)*q;b[10]=(n*v-p*t+s*A)*q;b[11]=(-k*v+l*t-m*A)*q;b[12]=(-f*C+h*y-i*x)*q;b[13]=(c*C-d*y+e*x)*q;b[14]=(-n*u+p*B-r*A)*q;b[15]=(k*u-l*B+o*A)*q;return b};mat4.toMat3=function(a,b){b||(b=mat3.create());b[0]=a[0];b[1]=a[1];b[2]=a[2];b[3]=a[4];b[4]=a[5];b[5]=a[6];b[6]=a[8];b[7]=a[9];b[8]=a[10];return b};
mat4.toInverseMat3=function(a,b){var c=a[0],d=a[1],e=a[2],g=a[4],f=a[5],h=a[6],i=a[8],j=a[9],k=a[10],l=k*f-h*j,o=-k*g+h*i,m=j*g-f*i,n=c*l+d*o+e*m;if(!n)return null;n=1/n;b||(b=mat3.create());b[0]=l*n;b[1]=(-k*d+e*j)*n;b[2]=(h*d-e*f)*n;b[3]=o*n;b[4]=(k*c-e*i)*n;b[5]=(-h*c+e*g)*n;b[6]=m*n;b[7]=(-j*c+d*i)*n;b[8]=(f*c-d*g)*n;return b};
mat4.multiply=function(a,b,c){c||(c=a);var d=a[0],e=a[1],g=a[2],f=a[3],h=a[4],i=a[5],j=a[6],k=a[7],l=a[8],o=a[9],m=a[10],n=a[11],p=a[12],r=a[13],s=a[14];a=a[15];var A=b[0],B=b[1],t=b[2],u=b[3],v=b[4],w=b[5],x=b[6],y=b[7],z=b[8],C=b[9],D=b[10],E=b[11],q=b[12],F=b[13],G=b[14];b=b[15];c[0]=A*d+B*h+t*l+u*p;c[1]=A*e+B*i+t*o+u*r;c[2]=A*g+B*j+t*m+u*s;c[3]=A*f+B*k+t*n+u*a;c[4]=v*d+w*h+x*l+y*p;c[5]=v*e+w*i+x*o+y*r;c[6]=v*g+w*j+x*m+y*s;c[7]=v*f+w*k+x*n+y*a;c[8]=z*d+C*h+D*l+E*p;c[9]=z*e+C*i+D*o+E*r;c[10]=z*
g+C*j+D*m+E*s;c[11]=z*f+C*k+D*n+E*a;c[12]=q*d+F*h+G*l+b*p;c[13]=q*e+F*i+G*o+b*r;c[14]=q*g+F*j+G*m+b*s;c[15]=q*f+F*k+G*n+b*a;return c};mat4.multiplyVec3=function(a,b,c){c||(c=b);var d=b[0],e=b[1];b=b[2];c[0]=a[0]*d+a[4]*e+a[8]*b+a[12];c[1]=a[1]*d+a[5]*e+a[9]*b+a[13];c[2]=a[2]*d+a[6]*e+a[10]*b+a[14];return c};
mat4.multiplyVec4=function(a,b,c){c||(c=b);var d=b[0],e=b[1],g=b[2];b=b[3];c[0]=a[0]*d+a[4]*e+a[8]*g+a[12]*b;c[1]=a[1]*d+a[5]*e+a[9]*g+a[13]*b;c[2]=a[2]*d+a[6]*e+a[10]*g+a[14]*b;c[4]=a[4]*d+a[7]*e+a[11]*g+a[15]*b;return c};
mat4.translate=function(a,b,c){var d=b[0],e=b[1];b=b[2];if(!c||a==c){a[12]=a[0]*d+a[4]*e+a[8]*b+a[12];a[13]=a[1]*d+a[5]*e+a[9]*b+a[13];a[14]=a[2]*d+a[6]*e+a[10]*b+a[14];a[15]=a[3]*d+a[7]*e+a[11]*b+a[15];return a}var g=a[0],f=a[1],h=a[2],i=a[3],j=a[4],k=a[5],l=a[6],o=a[7],m=a[8],n=a[9],p=a[10],r=a[11];c[0]=g;c[1]=f;c[2]=h;c[3]=i;c[4]=j;c[5]=k;c[6]=l;c[7]=o;c[8]=m;c[9]=n;c[10]=p;c[11]=r;c[12]=g*d+j*e+m*b+a[12];c[13]=f*d+k*e+n*b+a[13];c[14]=h*d+l*e+p*b+a[14];c[15]=i*d+o*e+r*b+a[15];return c};
mat4.scale=function(a,b,c){var d=b[0],e=b[1];b=b[2];if(!c||a==c){a[0]*=d;a[1]*=d;a[2]*=d;a[3]*=d;a[4]*=e;a[5]*=e;a[6]*=e;a[7]*=e;a[8]*=b;a[9]*=b;a[10]*=b;a[11]*=b;return a}c[0]=a[0]*d;c[1]=a[1]*d;c[2]=a[2]*d;c[3]=a[3]*d;c[4]=a[4]*e;c[5]=a[5]*e;c[6]=a[6]*e;c[7]=a[7]*e;c[8]=a[8]*b;c[9]=a[9]*b;c[10]=a[10]*b;c[11]=a[11]*b;c[12]=a[12];c[13]=a[13];c[14]=a[14];c[15]=a[15];return c};
mat4.rotate=function(a,b,c,d){var e=c[0],g=c[1];c=c[2];var f=Math.sqrt(e*e+g*g+c*c);if(!f)return null;if(f!=1){f=1/f;e*=f;g*=f;c*=f}var h=Math.sin(b),i=Math.cos(b),j=1-i;b=a[0];f=a[1];var k=a[2],l=a[3],o=a[4],m=a[5],n=a[6],p=a[7],r=a[8],s=a[9],A=a[10],B=a[11],t=e*e*j+i,u=g*e*j+c*h,v=c*e*j-g*h,w=e*g*j-c*h,x=g*g*j+i,y=c*g*j+e*h,z=e*c*j+g*h;e=g*c*j-e*h;g=c*c*j+i;if(d){if(a!=d){d[12]=a[12];d[13]=a[13];d[14]=a[14];d[15]=a[15]}}else d=a;d[0]=b*t+o*u+r*v;d[1]=f*t+m*u+s*v;d[2]=k*t+n*u+A*v;d[3]=l*t+p*u+B*
v;d[4]=b*w+o*x+r*y;d[5]=f*w+m*x+s*y;d[6]=k*w+n*x+A*y;d[7]=l*w+p*x+B*y;d[8]=b*z+o*e+r*g;d[9]=f*z+m*e+s*g;d[10]=k*z+n*e+A*g;d[11]=l*z+p*e+B*g;return d};mat4.rotateX=function(a,b,c){var d=Math.sin(b);b=Math.cos(b);var e=a[4],g=a[5],f=a[6],h=a[7],i=a[8],j=a[9],k=a[10],l=a[11];if(c){if(a!=c){c[0]=a[0];c[1]=a[1];c[2]=a[2];c[3]=a[3];c[12]=a[12];c[13]=a[13];c[14]=a[14];c[15]=a[15]}}else c=a;c[4]=e*b+i*d;c[5]=g*b+j*d;c[6]=f*b+k*d;c[7]=h*b+l*d;c[8]=e*-d+i*b;c[9]=g*-d+j*b;c[10]=f*-d+k*b;c[11]=h*-d+l*b;return c};
mat4.rotateY=function(a,b,c){var d=Math.sin(b);b=Math.cos(b);var e=a[0],g=a[1],f=a[2],h=a[3],i=a[8],j=a[9],k=a[10],l=a[11];if(c){if(a!=c){c[4]=a[4];c[5]=a[5];c[6]=a[6];c[7]=a[7];c[12]=a[12];c[13]=a[13];c[14]=a[14];c[15]=a[15]}}else c=a;c[0]=e*b+i*-d;c[1]=g*b+j*-d;c[2]=f*b+k*-d;c[3]=h*b+l*-d;c[8]=e*d+i*b;c[9]=g*d+j*b;c[10]=f*d+k*b;c[11]=h*d+l*b;return c};
mat4.rotateZ=function(a,b,c){var d=Math.sin(b);b=Math.cos(b);var e=a[0],g=a[1],f=a[2],h=a[3],i=a[4],j=a[5],k=a[6],l=a[7];if(c){if(a!=c){c[8]=a[8];c[9]=a[9];c[10]=a[10];c[11]=a[11];c[12]=a[12];c[13]=a[13];c[14]=a[14];c[15]=a[15]}}else c=a;c[0]=e*b+i*d;c[1]=g*b+j*d;c[2]=f*b+k*d;c[3]=h*b+l*d;c[4]=e*-d+i*b;c[5]=g*-d+j*b;c[6]=f*-d+k*b;c[7]=h*-d+l*b;return c};
mat4.frustum=function(a,b,c,d,e,g,f){f||(f=mat4.create());var h=b-a,i=d-c,j=g-e;f[0]=e*2/h;f[1]=0;f[2]=0;f[3]=0;f[4]=0;f[5]=e*2/i;f[6]=0;f[7]=0;f[8]=(b+a)/h;f[9]=(d+c)/i;f[10]=-(g+e)/j;f[11]=-1;f[12]=0;f[13]=0;f[14]=-(g*e*2)/j;f[15]=0;return f};mat4.perspective=function(a,b,c,d,e){a=c*Math.tan(a*Math.PI/360);b=a*b;return mat4.frustum(-b,b,-a,a,c,d,e)};
mat4.ortho=function(a,b,c,d,e,g,f){f||(f=mat4.create());var h=b-a,i=d-c,j=g-e;f[0]=2/h;f[1]=0;f[2]=0;f[3]=0;f[4]=0;f[5]=2/i;f[6]=0;f[7]=0;f[8]=0;f[9]=0;f[10]=-2/j;f[11]=0;f[12]=(a+b)/h;f[13]=(d+c)/i;f[14]=(g+e)/j;f[15]=1;return f};
mat4.lookAt=function(a,b,c,d){d||(d=mat4.create());var e=a[0],g=a[1];a=a[2];var f=c[0],h=c[1],i=c[2];c=b[1];var j=b[2];if(e==b[0]&&g==c&&a==j)return mat4.identity(d);var k,l,o,m;c=e-b[0];j=g-b[1];b=a-b[2];m=1/Math.sqrt(c*c+j*j+b*b);c*=m;j*=m;b*=m;k=h*b-i*j;i=i*c-f*b;f=f*j-h*c;if(m=Math.sqrt(k*k+i*i+f*f)){m=1/m;k*=m;i*=m;f*=m}else f=i=k=0;h=j*f-b*i;l=b*k-c*f;o=c*i-j*k;if(m=Math.sqrt(h*h+l*l+o*o)){m=1/m;h*=m;l*=m;o*=m}else o=l=h=0;d[0]=k;d[1]=h;d[2]=c;d[3]=0;d[4]=i;d[5]=l;d[6]=j;d[7]=0;d[8]=f;d[9]=
o;d[10]=b;d[11]=0;d[12]=-(k*e+i*g+f*a);d[13]=-(h*e+l*g+o*a);d[14]=-(c*e+j*g+b*a);d[15]=1;return d};mat4.str=function(a){return"["+a[0]+", "+a[1]+", "+a[2]+", "+a[3]+", "+a[4]+", "+a[5]+", "+a[6]+", "+a[7]+", "+a[8]+", "+a[9]+", "+a[10]+", "+a[11]+", "+a[12]+", "+a[13]+", "+a[14]+", "+a[15]+"]"};quat4={};quat4.create=function(a){var b=new glMatrixArrayType(4);if(a){b[0]=a[0];b[1]=a[1];b[2]=a[2];b[3]=a[3]}return b};quat4.set=function(a,b){b[0]=a[0];b[1]=a[1];b[2]=a[2];b[3]=a[3];return b};
quat4.calculateW=function(a,b){var c=a[0],d=a[1],e=a[2];if(!b||a==b){a[3]=-Math.sqrt(Math.abs(1-c*c-d*d-e*e));return a}b[0]=c;b[1]=d;b[2]=e;b[3]=-Math.sqrt(Math.abs(1-c*c-d*d-e*e));return b};quat4.inverse=function(a,b){if(!b||a==b){a[0]*=1;a[1]*=1;a[2]*=1;return a}b[0]=-a[0];b[1]=-a[1];b[2]=-a[2];b[3]=a[3];return b};quat4.length=function(a){var b=a[0],c=a[1],d=a[2];a=a[3];return Math.sqrt(b*b+c*c+d*d+a*a)};
quat4.normalize=function(a,b){b||(b=a);var c=a[0],d=a[1],e=a[2],g=a[3],f=Math.sqrt(c*c+d*d+e*e+g*g);if(f==0){b[0]=0;b[1]=0;b[2]=0;b[3]=0;return b}f=1/f;b[0]=c*f;b[1]=d*f;b[2]=e*f;b[3]=g*f;return b};quat4.multiply=function(a,b,c){c||(c=a);var d=a[0],e=a[1],g=a[2];a=a[3];var f=b[0],h=b[1],i=b[2];b=b[3];c[0]=d*b+a*f+e*i-g*h;c[1]=e*b+a*h+g*f-d*i;c[2]=g*b+a*i+d*h-e*f;c[3]=a*b-d*f-e*h-g*i;return c};
quat4.multiplyVec3=function(a,b,c){c||(c=b);var d=b[0],e=b[1],g=b[2];b=a[0];var f=a[1],h=a[2];a=a[3];var i=a*d+f*g-h*e,j=a*e+h*d-b*g,k=a*g+b*e-f*d;d=-b*d-f*e-h*g;c[0]=i*a+d*-b+j*-h-k*-f;c[1]=j*a+d*-f+k*-b-i*-h;c[2]=k*a+d*-h+i*-f-j*-b;return c};quat4.toMat3=function(a,b){b||(b=mat3.create());var c=a[0],d=a[1],e=a[2],g=a[3],f=c+c,h=d+d,i=e+e,j=c*f,k=c*h;c=c*i;var l=d*h;d=d*i;e=e*i;f=g*f;h=g*h;g=g*i;b[0]=1-(l+e);b[1]=k-g;b[2]=c+h;b[3]=k+g;b[4]=1-(j+e);b[5]=d-f;b[6]=c-h;b[7]=d+f;b[8]=1-(j+l);return b};
quat4.toMat4=function(a,b){b||(b=mat4.create());var c=a[0],d=a[1],e=a[2],g=a[3],f=c+c,h=d+d,i=e+e,j=c*f,k=c*h;c=c*i;var l=d*h;d=d*i;e=e*i;f=g*f;h=g*h;g=g*i;b[0]=1-(l+e);b[1]=k-g;b[2]=c+h;b[3]=0;b[4]=k+g;b[5]=1-(j+e);b[6]=d-f;b[7]=0;b[8]=c-h;b[9]=d+f;b[10]=1-(j+l);b[11]=0;b[12]=0;b[13]=0;b[14]=0;b[15]=1;return b};quat4.str=function(a){return"["+a[0]+", "+a[1]+", "+a[2]+", "+a[3]+"]"};
jigLib.GLMatrix=mat4;
})(jigLib);(function(jigLib){
	/**
	 * @author Paul Brunt
	 * 
	 * In an attempt to reduce the overhead of millions of Vector3D objects, I have
	 * pulled all of the methods and constants out into this utility class as static
	 * members. This class should never be instantiated (hence the constructor error).
	 * Note also that all instances of Vector3D have been replaced with simple arrays (e.g. [x,y,z,w])
	 * Jim Sangwine
	 **/
	var Vector3DUtil=function(){ throw new Error('Vector3DUtil is a utility class and should not be instantiated'); };

	Vector3DUtil.X_AXIS=[1,0,0,0];
	Vector3DUtil.Y_AXIS=[0,1,0,0];
	Vector3DUtil.Z_AXIS=[0,0,1,0];

	/**
	 * returns a new 3D vector that is the sum of v1 and v2
	 * @param v1 {Array} in the format [x,y,z,w]
	 * @param v2 {Array} in the format [x,y,z,w]
	 * @returns {Array} in the format [x,y,z,w]
	 **/
	Vector3DUtil.add=function(v1,v2){
		return [v1[0]+v2[0],v1[1]+v2[1],v1[2]+v2[2],v1[3]+v2[3]];
	};

	/**
	 * returns a new 3D vector that is the result of v2 subtracted from v1
	 * @param v1 {Array} in the format [x,y,z,w]
	 * @param v2 {Array} in the format [x,y,z,w]
	 * @returns {Array} in the format [x,y,z,w]
	 **/
	Vector3DUtil.subtract=function(v1,v2){
		return [v1[0]-v2[0],v1[1]-v2[1],v1[2]-v2[2],v1[3]-v2[3]];
	};

	/**
	 * performs an in-place subtraction of v2 from v1 (v1 is modified)
	 * @param v1 {Array} in the format [x,y,z,w]
	 * @param v2 {Array} in the format [x,y,z,w]
	 **/
	Vector3DUtil.decrementBy=function(v1,v2){
		v1[0]-=v2[0];
		v1[1]-=v2[1];
		v1[2]-=v2[2];
		v1[3]-=v2[3];
	};

	/**
	 * performs an in-place addition of v2 to v1 (v1 is modified)
	 * @param v1 {Array} in the format [x,y,z,w]
	 * @param v2 {Array} in the format [x,y,z,w]
	 **/
	Vector3DUtil.IncrementBy=function(v1,v2){
		v1[0]+=v2[0];
		v1[1]+=v2[1];
		v1[2]+=v2[2];
		v1[3]+=v2[3];
	};

	/**
	 * determines the distance between vectors v1 and v2
	 * @param v1 {Array} in the format [x,y,z,w]
	 * @param v2 {Array} in the format [x,y,z,w]
	 * @returns {Number}
	 **/
	Vector3DUtil.distance=function(v1,v2) {
		var math=Math;
		var pow=math.pow;
		var x=pow(v1[0]-v2[0], 2);
		var y=pow(v1[1]-v2[1], 2);
		var z=pow(v1[2]-v2[2], 2);
		return math.sqrt(x+y+z);
	};

	/**
	 * determines the dot product for two vectors
	 * @param v1 {Array} in the format [x,y,z,w]
	 * @param v2 {Array} in the format [x,y,z,w]
	 * @returns {Number}
	 **/
	Vector3DUtil.dotProduct=function(v1,v2){
		return v1[0]*v2[0]+v1[1]*v2[1]+v1[2]*v2[2];
	};

	/**
	 * determines the cross product for two vectors
	 * @param v1 {Array} in the format [x,y,z,w]
	 * @param v2 {Array} in the format [x,y,z,w]
	 * @returns {Array} in the format [x,y,z,w]
	 **/
	Vector3DUtil.crossProduct=function(v1,v2){
		return [v1[1]*v2[2]-v1[2]*v2[1],v1[2]*v2[0]-v1[0]*v2[2],v1[0]*v2[1]-v1[1]*v2[0],0];
	};

	/**
	 * determines the length of a vector
	 * @param v {Array} in the format [x,y,z,w]
	 * @returns {Number}
	 **/
	Vector3DUtil.get_length=function(v){
		var sq=v[0]*v[0]+v[1]*v[1]+v[2]*v[2];
		return(sq>0) ? Math.pow(sq,0.5) : 0.0;
	};

	/**
	 * determines the length squared of a vector
	 * @param v {Array} in the format [x,y,z,w]
	 * @returns {Number}
	 **/
	Vector3DUtil.get_lengthSquared=function(v){
		var sq=v[0]*v[0]+v[1]*v[1]+v[2]*v[2];
		return sq;
	};

	/**
	 * performs in-place normalisation of a vector
	 * @param v {Array} in the format [x,y,z,w]
	 * @returns {Number}
	 **/
	Vector3DUtil.normalize=function(v){
		f=Vector3DUtil.get_length(v);
		v[0]/=f;
		v[1]/=f;
		v[2]/=f;
		return f;
	};

	/**
	 * performs in-place negation of a vector
	 * @param v {Array} in the format [x,y,z,w]
	 * @returns {Array} in the format [x,y,z,w]
	 **/
	Vector3DUtil.negate=function(v){
		v[0]*=-1;
		v[1]*=-1;
		v[2]*=-1;
		return v;
	};

	/**
	 * performs in-place scaling of a vector
	 * @param v {Array} in the format [x,y,z,w]
	 * @param s {Number}
	 **/
	Vector3DUtil.scaleBy=function(v,s){
		v[0]*=s;
		v[1]*=s;
		v[2]*=s;
	};

	/**
	 * gets the absolute sum of each value of a given 3D vector
	 * useful for determining the total amount of force acting on a given body for example
	 * @param v {Array} in the format [x,y,z,w]
	 * @returns {Number}
	 **/
	Vector3DUtil.getSum=function(v){
		var abs=Math.abs;
		return abs(v[0])+abs(v[1])+abs(v[2]);
	};
	
	/**
	 * scales Vector3D v so that the absolute sum of x,y & z is no greater than s
	 * useful in situations when a force vector must be limited to some maximum total amount of force
	 * @param v {Array} in the format [x,y,z,w]
	 * @param s {Number} the scaling factor
	 **/
	Vector3DUtil.limitSum=function(v,s){
		var abs=Math.abs;
		c=Vector3DUtil.getSum(v);
		if (s>=c) return;
		f=s/c;
		Vector3DUtil.scaleBy(v,f);
	};

	/**
	 * performs in-place projection on a vector
	 * @param v {Array} in the format [x,y,z,w]
	 **/
	Vector3DUtil.project=function(v){
		v[0]/=v[3];
		v[1]/=v[3];
		v[2]/=v[3];
		v[3]=1;
	};

	/**
	 * determines the angle between two vectors
	 * @param v1 {Array} in the format [x,y,z,w]
	 * @param v2 {Array} in the format [x,y,z,w]
	 * @returns {Number}
	 **/
	Vector3DUtil.angleBetween=function(v1,v2){
		var v1n=v1.slice(0);
		var v2n=v2.slice(0);
		Vector3DUtil.normalize(v1n);
		Vector3DUtil.normalize(v2n);
		d=Vector3DUtil.dotProduct(v1n, v2n);
		if (d<-1) d=-1;
		else if (d>1) d=1;

		return Math.acos(d);
	};

	/**
	 * tests two vectors for equality
	 * @param v1 {Array} in the format [x,y,z,w]
	 * @param v2 {Array} in the format [x,y,z,w]
	 * @param allFour {Boolean} whether to test all 4 slots [x,y,z,w] or only the 1st 3 coordinate values [x,y,z]
	 * @returns {Boolean}
	 **/
	Vector3DUtil.equals=function(v1, v2, allFour){
		if(!allFour)
			return (v1[0]==v2[0] && v1[1]==v2[1]  && v1[2]==v2[2]); 
		else
			return (v1[0]==v2[0] && v1[1]==v2[1]  && v1[2]==v2[2] && v1[3]==v2[3]); 
	};

	/**
	 * replacement for the Vector3D constructor - avoids NaN assignments
	 * 
	 * @param x {Number}
	 * @param y {Number}
	 * @param z {Number}
	 * @param w {Number}
	 * @returns {Array} in the format [x,y,z,w]
	 **/
	Vector3DUtil.create=function(x,y,z,w){
		var v3d=[];
		v3d[0] = (x) ? x : 0;
		v3d[1] = (y) ? y : 0;
		v3d[2] = (z) ? z : 0;
		v3d[3] = (w) ? w : 0;
		return v3d;
	};

	jigLib.Vector3DUtil=Vector3DUtil;
	
})(jigLib);(function(jigLib){
	var Vector3DUtil=jigLib.Vector3DUtil;
	var GLMatrix=jigLib.GLMatrix;
	
	/**
	 * @author Paul Brunt
	 * 
	 * Class rewritten by Jim Sangwine to use GLMatrix (http://code.google.com/p/glmatrix/)
	 **/
	var Matrix3D=function(v){
		if(v) this.glmatrix=GLMatrix.create(v);
		else this.glmatrix=GLMatrix.create([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]);
	};
	Matrix3D.prototype.glmatrix=null;
	
	Matrix3D.prototype.get_determinant=function() {
		return GLMatrix.determinant(this.glmatrix);
	};

	Matrix3D.prototype.prepend=function(m){
		GLMatrix.multiply(m.glmatrix, this.glmatrix, this.glmatrix);
		return;
	};
	
	Matrix3D.prototype.append=function(m){
		GLMatrix.multiply(this.glmatrix, m.glmatrix);
		return;
	};
	
	Matrix3D.prototype.angleAxis=function(angle, axis) {
		var xmx,ymy,zmz,xmy,ymz,zmx,xms,yms,zms;

		//convert from degrees to radians
		angle=angle/(3.14159*2);

		var x = axis[0];
		var y = axis[1];
		var z = axis[2];

		var cos = Math.cos(angle);
		var cosi = 1.0 - cos;
		var sin = Math.sin(angle);

		xms = x * sin;yms = y * sin;zms = z * sin;
		xmx = x * x;ymy = y * y;zmz = z * z;
		xmy = x * y;ymz = y * z;zmx = z * x;

		var matrix=[(cosi * xmx) + cos,(cosi * xmy) - zms,(cosi * zmx) + yms,0,
					(cosi * xmy) + zms,(cosi * ymy) + cos,(cosi * ymz) - xms,0,
					(cosi * zmx) - yms,(cosi * ymz) + xms,(cosi * zmz) + cos,0,
					0,0,0,1];

		return new Matrix3D(matrix);
	};
	
	Matrix3D.prototype.rotate=function(angle, axis) {
		var mat=this.clone();
		GLMatrix.rotate(mat.glmatrix,angle,axis);
		return mat;
	};
	
	Matrix3D.prototype.translateMatrix=function(v){
		return new Matrix3D([
		         			1,0,0,v[0],
		         			0,1,0,v[1],
		         			0,0,1,v[2],
		         			0,0,0,1
		         			]);
	};
	
	Matrix3D.prototype.scaleMatrix=function(v){
		return new Matrix3D([
		         			v[0],0,0,0,
		         			0,v[1],0,0,
		         			0,0,v[2],0,
		         			0,0,0,1
		         			]);
	};
	
	Matrix3D.prototype.appendRotation=function(angle,axis,pivot){
		angle=angle/(3.14159*2);
		Vector3DUtil.negate(axis);
		
		if (pivot)
		{
			var npivot=Vector3DUtil.negate(pivot.slice(0));
			this.appendTranslation(npivot[0], npivot[1], npivot[2]);
		}

		GLMatrix.rotate(this.glmatrix, angle, axis);

		if (pivot)
			this.appendTranslation(pivot[0], pivot[1], pivot[2]);
	};

	Matrix3D.prototype.prependRotation=function(angle,axis,pivot){
		if(pivot)
			this.prepend(this.translateMatrix(Vector3DUtil.negate(pivot.slice(0))));

		this.prepend(this.angleAxis(angle,axis));
		if(pivot)
			this.prepend(this.translateMatrix(pivot));
	};
	
	Matrix3D.prototype.appendScale=function(x,y,z){
		GLMatrix.scale(this.glmatrix, [x,y,z]);
	};
	
	Matrix3D.prototype.prependScale=function(x,y,z){
		this.prepend(this.scaleMatrix([x,y,z]));
	};
	
	Matrix3D.prototype.appendTranslation=function(x,y,z){
		this.append(this.translateMatrix([x,y,z]));
	};
	
	Matrix3D.prototype.prependTranslation=function(x,y,z){
		this.prepend(this.translateMatrix([x,y,z]));
	};
	
	Matrix3D.prototype.identity=function(){
		GLMatrix.identity(this.glmatrix);
		return;
	};
	
	Matrix3D.prototype.transpose=function(){
		GLMatrix.transpose(this.glmatrix);
	};
	
	Matrix3D.prototype.invert=function(){
		GLMatrix.inverse(this.glmatrix);
		return;
	};
	
	Matrix3D.prototype.clone=function(){
		return new Matrix3D(this.glmatrix);
	};
	
	/**
	 * this method is similar to JMatrix3D.multiplyVector except it uses  
	 * the GLMatrix methed which uses the same cell references as the Flash 
	 * version - added to aid in debugging the point constraint problems
	 * @param vector
	 * @returns
	 */
	Matrix3D.prototype.transformVector=function(vector){
		return GLMatrix.multiplyVec3(this.glmatrix, vector);
	};
	
	jigLib.Matrix3D=Matrix3D;
	
})(jigLib);(function(jigLib){
	var Vector3DUtil=jigLib.Vector3DUtil;
	
	/**
	 * @author katopz
	 */
	var JNumber3D={};
	
	JNumber3D.NUM_TINY = 0.00001;
	JNumber3D.NUM_HUGE = 100000;

	JNumber3D.toArray=function(v){
		return [v[0], v[1], v[2]];
	};
	
	JNumber3D.getScaleVector=function(v, s){
		return [v[0]*s,v[1]*s,v[2]*s,v[3]];
	};

	JNumber3D.getDivideVector=function(v, w){
		return (w) ? [v[0] / w, v[1] / w, v[2] / w, 0] : [0, 0, 0, 0];
	};
	
	JNumber3D.getNormal=function(v0, v1, v2){
		var E = v1.slice(0);
		var F = v2.slice(0);
		var N = Vector3DUtil.crossProduct(Vector3DUtil.subtract(E, v0), Vector3DUtil.subtract(F, v1));
		Vector3DUtil.normalize(N);

		return N;
	};

	JNumber3D.copyFromArray=function(v, arr){
		if (arr.length >= 3) v=arr;
	};

	JNumber3D.getLimiteNumber=function(num, min, max){
		var n = num;
		if (n < min) n = min;
		else if (n > max) n = max;

		return n;
	};
	
	jigLib.JNumber3D=JNumber3D;
	
})(jigLib);
(function(jigLib){
	var Vector3DUtil=jigLib.Vector3DUtil;
	var Matrix3D=jigLib.Matrix3D;
	
	/**
	* @author katopz
	*/
	var JMatrix3D={};
	
	JMatrix3D.getTranslationMatrix=function(x, y, z){
		var matrix3D = new Matrix3D();
		matrix3D.appendTranslation(x, y, z);
		return matrix3D;
	};
	
	JMatrix3D.getScaleMatrix=function(x, y, z){
		var matrix3D = new Matrix3D();
		matrix3D.prependScale(x, y, z);
		return matrix3D;
	};
				
	JMatrix3D.getRotationMatrix=function(x, y, z, degree, pivotPoint){
		var matrix3D = new Matrix3D();
		matrix3D.appendRotation(degree, Vector3DUtil.create(x,y,z,0),pivotPoint);
		return matrix3D;
	};
				
	JMatrix3D.getInverseMatrix=function(m){
		var matrix3D = m.clone();
		matrix3D.invert();
		return matrix3D;
	};
	
	JMatrix3D.getTransposeMatrix=function(m){
		var matrix3D = m.clone();
		matrix3D.transpose();
		return matrix3D;
	};

	JMatrix3D.getAppendMatrix3D=function(a, b){
		var matrix3D = a.clone();
		matrix3D.append(b);
		return matrix3D;
	};

	JMatrix3D.getPrependMatrix=function(a, b){
		var matrix3D = a.clone();
		matrix3D.prepend(b);
		return matrix3D;
	};
				
	JMatrix3D.getSubMatrix=function(a, b){
		var num = [16];
		for (var i = 0; i < 16; i++ ) {
			num[i] = a.glmatrix[i] - b.glmatrix[i];
		}
		return new Matrix3D(num);
	};
	
	JMatrix3D.getRotationMatrixAxis=function(degree, rotateAxis){
				var matrix3D = new Matrix3D();
				matrix3D.appendRotation(degree, rotateAxis?rotateAxis:Vector3DUtil.X_AXIS);
				return matrix3D;
	};
				
	JMatrix3D.getCols=function(matrix3D){
		var _rawData =  matrix3D.glmatrix;
		var cols = [];
						
		/*
		cols[0] = Vector3DUtil.create(_rawData[0], _rawData[1], _rawData[2], 0);
		cols[1] = Vector3DUtil.create(_rawData[4], _rawData[5], _rawData[6], 0);
		cols[2] = Vector3DUtil.create(_rawData[8], _rawData[9], _rawData[10], 0);
		
		*/
		cols[0] = Vector3DUtil.create(_rawData[0], _rawData[4], _rawData[8], 0);
		cols[1] = Vector3DUtil.create(_rawData[1], _rawData[5], _rawData[9], 0);
		cols[2] = Vector3DUtil.create(_rawData[2], _rawData[6], _rawData[10], 0);
						
		return cols;
	};

	JMatrix3D.multiplyVector=function(matrix3D, v){
		var vx = v[0];
		var vy = v[1];
		var vz = v[2];

		if (vx == 0 && vy == 0 && vz == 0) { return; }
						
		var _rawData =  matrix3D.glmatrix;
						
		/*
		How did this work in AS3? it looks wrong!
		v[0] = vx * _rawData[0] + vy * _rawData[4] + vz * _rawData[8]  + _rawData[12];
		v[1] = vx * _rawData[1] + vy * _rawData[5] + vz * _rawData[9]  + _rawData[13];
		v[2] = vx * _rawData[2] + vy * _rawData[6] + vz * _rawData[10] + _rawData[14];
		 */
		
		v[0] = vx * _rawData[0] + vy * _rawData[1] + vz * _rawData[2]  + _rawData[3];
		v[1] = vx * _rawData[4] + vy * _rawData[5] + vz * _rawData[6]  + _rawData[7];
		v[2] = vx * _rawData[8] + vy * _rawData[9] + vz * _rawData[10] + _rawData[11];
	};
	
	jigLib.JMatrix3D=JMatrix3D;
	
})(jigLib);
	(function(jigLib){
	var Vector3DUtil=jigLib.Vector3DUtil;
	
	/**
	* @author katopz
	*/
	var JMath3D={};
		
	JMath3D.fromNormalAndPoint=function(normal, point){
			var v = Vector3DUtil.create(normal[0], normal[1], normal[2], 0);
			v[3] = -(v[0]*point[0] + v[1]*point[1] + v[2]*point[2]);
			
			return normal;
	};
		
	JMath3D.getIntersectionLine=function(v, v0, v1){
		var d0 = v[0] * v0[0] + v[1] * v0[1] + v[2] * v0[2] - v[3];
		var d1 = v[0] * v1[0] + v[1] * v1[1] + v[2] * v1[2] - v[3];
		var m = d1 / (d1 - d0);
		return [v1[0] + (v0[0] - v1[0]) * m,
				v1[1] + (v0[1] - v1[1]) * m,
				v1[2] + (v0[2] - v1[2]) * m, 
				0];
	};

	JMath3D.unproject=function(matrix3D, focus, zoom, mX, mY){
		var persp = (focus * zoom) / focus;
		var vector = Vector3DUtil.create(mX / persp, -mY / persp, focus, 0);
		return matrix3D.transformVector(vector);
	};
	
})(jigLib);
(function(jigLib){
	/**
		 * @author katopz
		 */
	var ContactData=function(){};
	ContactData.prototype.pair=null;
	ContactData.prototype.impulse=null;
	
	jigLib.ContactData=ContactData;
})(jigLib);


(function(jigLib){
	/**
	* @author katopz
	*/
	var EdgeData=function(ind0, ind1){
		this.ind0 = ind0;
		this.ind1 = ind1;
	};
	
	jigLib.EdgeData=EdgeData;
})(jigLib);(function(jigLib){

	var Vector3DUtil=jigLib.Vector3DUtil;
	
	var PlaneData=function(pos, nor){
		this.position = pos.slice(0);
		this.normal = nor.slice(0);
		this.distance = Vector3DUtil.dotProduct(this.position, this._normal);
	};
	
	PlaneData.prototype.pointPlaneDistance=function(pt){
		return Vector3DUtil.dotProduct(normal, pt) - distance;
	};
		
	jigLib.PlaneData=PlaneData;
	
})(jigLib);
(function(jigLib){
	/**
	* @author katopz
	*/
	var SpanData=function(){};
	SpanData.prototype.min=null;
	SpanData.prototype.max=null;
	SpanData.prototype.flag=null;
	SpanData.prototype.depth=null;
	
	jigLib.SpanData=SpanData;
})(jigLib);(function(jigLib){
		var PhysicsSystem=jigLib.PhysicsSystem;
	var RigidBody=jigLib.RigidBody;
	
	/**
		 * @author bartekd
		 */
	var AbstractPhysics=function(speed) {
		if(!speed) speed=5;
		this.inittime=(new Date()).getTime();
		this.speed = speed;
		this.physicsSystem = PhysicsSystem.getInstance();
	};
				
		AbstractPhysics.prototype.addBody=function(body){
		this.physicsSystem.addBody(body);
	};
				
		AbstractPhysics.prototype.removeBody=function(body){
		physicsSystem.removeBody(body);
	};
				
		AbstractPhysics.prototype.get_engine=function(){
		return this.physicsSystem ;
	};
				
		AbstractPhysics.prototype.step=function(){
		var stepTime = (new Date()).getTime();
				deltaTime = ((stepTime - this.initTime) / 1000) * this.speed;
				this.initTime = stepTime;
				this.physicsSystem.integrate(deltaTime);
	};
		
	jigLib.AbstractPhysics=AbstractPhysics;
		
})(jigLib);
		(function(jigLib){
	/**
		 * Represents a mesh from a 3D engine inside JigLib.
		 * Its implementation shold allow to get and set a Matrix3D on
		 * the original object.
		 *
		 * In the implementation, JMatrix3D should be translated into
		 * the type proper for a given engine.
		 *
		 * @author bartekd
		 */
	var Matrix3D=jigLib.Matrix3D;
	
	function ISkin3D(){
		this.matrix=new Matrix3D();
	};
	ISkin3D.prototype.get_transform=function(){
		return this.matrix;
	};
	ISkin3D.prototype.set_transform=function(value){
		this.matrix=value;
	};
	
	jigLib.ISkin3D=ISkin3D;
	
})(jigLib);(function(jigLib){
	/**
		 * ...
		 * @author Muzer
		 */
	var ITerrain=function(){
	};
	//Min of coordinate horizontally;
		ITerrain.prototype.get_minW=function(){};
				
	//Min of coordinate vertically;
		ITerrain.prototype.get_minH=function(){};
				
	//Max of coordinate horizontally;
		ITerrain.prototype.get_maxW=function(){};
				
	//Max of coordinate vertically;
		ITerrain.prototype.get_maxH=function(){};
				
	//The horizontal length of each segment;
		ITerrain.prototype.get_dw=function(){};
				
	//The vertical length of each segment;
		ITerrain.prototype.get_dh=function(){};
				
	//Number of segments horizontally.
		ITerrain.prototype.get_sw=function(){};
				
	//Number of segments vertically
		ITerrain.prototype.get_sh=function(){};
				
	//the heights of all vertices
		ITerrain.prototype.get_heights=function(){};
		
	jigLib.ITerrain=ITerrain;
})(jigLib);/*
Copyright (c) 2007 Danny Chapman 
http://www.rowlhouse.co.uk

This software is provided 'as-is', without any express or implied
warranty. In no event will the authors be held liable for any damages
arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it
freely, subject to the following restrictions:
1. The origin of this software must not be misrepresented; you must not
claim that you wrote the original software. If you use this software
in a product, an acknowledgment in the product documentation would be
appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be
misrepresented as being the original software.
3. This notice may not be removed or altered from any source
distribution.
 */

/**
 * @author Muzer(muzerly@gmail.com)
 * @link http://code.google.com/p/jiglibflash
 */

(function(jigLib){
	
	var Vector3DUtil=jigLib.Vector3DUtil;
	var JNumber3D=jigLib.JNumber3D;
	
	var JAABox=function(minPos, maxPos) {
		this._minPos = minPos.slice(0);
		this._maxPos = maxPos.slice(0);
	};
	
	JAABox.prototype._minPos=null;
	JAABox.prototype._maxPos=null;

	JAABox.prototype.get_minPos=function(){
		return this._minPos;
	};
	JAABox.prototype.set_minPos=function(pos){
		this._minPos = pos.slice(0);
	};
				
	JAABox.prototype.get_maxPos=function(){
		return this._maxPos;
	};
	
	JAABox.prototype.set_maxPos=function(pos){
		this._maxPos = pos.slice(0);
	};
				
	JAABox.prototype.get_sideLengths=function() {
		var pos = this._maxPos.slice(0);
		Vector3DUtil.subtract(pos, this._minPos);
		return pos;
	};

	JAABox.prototype.get_centrePos=function(){
		var pos = this._minPos.slice(0);
		return JNumber3D.getScaleVector(Vector3DUtil.add(pos, this._maxPos), 0.5);
	};
				
	JAABox.prototype.move=function(delta){
		Vector3DUtil.add(this._minPos, delta);
		Vector3DUtil.add(this._maxPos, delta);
	};

	JAABox.prototype.clear=function(){
		this._minPos = Vector3DUtil.create(JNumber3D.NUM_HUGE, JNumber3D.NUM_HUGE, JNumber3D.NUM_HUGE, 0);
		this._maxPos = Vector3DUtil.create(-JNumber3D.NUM_HUGE, -JNumber3D.NUM_HUGE, -JNumber3D.NUM_HUGE, 0);
	};

	JAABox.prototype.clone=function(){
		return new JAABox(this._minPos, this._maxPos);
	};

	JAABox.prototype.addPoint=function(pos){
		var _minPos=this._minPos;
		var _maxPos=this._maxPos;
		if (pos[0] < _minPos[0]) _minPos[0] = pos[0] - JNumber3D.NUM_TINY;
		if (pos[0] > _maxPos[0]) _maxPos[0] = pos[0] + JNumber3D.NUM_TINY;
		if (pos[1] < _minPos[1]) _minPos[1] = pos[1] - JNumber3D.NUM_TINY;
		if (pos[1] > _maxPos[1]) _maxPos[1] = pos[1] + JNumber3D.NUM_TINY;
		if (pos[2] < _minPos[2]) _minPos[2] = pos[2] - JNumber3D.NUM_TINY;
		if (pos[2] > _maxPos[2]) _maxPos[2] = pos[2] + JNumber3D.NUM_TINY;
	};

	JAABox.prototype.addBox=function(box){
		var pts = box.getCornerPoints(box.get_currentState());
		this.addPoint(pts[0]);
		this.addPoint(pts[1]);
		this.addPoint(pts[2]);
		this.addPoint(pts[3]);
		this.addPoint(pts[4]);
		this.addPoint(pts[5]);
		this.addPoint(pts[6]);
		this.addPoint(pts[7]);
	};

	JAABox.prototype.addSphere=function(sphere){
		var _minPos=this._minPos;
		var _maxPos=this._maxPos;
		if (sphere.get_currentState().position[0] - sphere.get_radius() < _minPos[0]) 
			_minPos[0] = (sphere.get_currentState().position[0] - sphere.get_radius()) - JNumber3D.NUM_TINY;

		if (sphere.get_currentState().position[0] + sphere.get_radius() > _maxPos[0]) 
			_maxPos[0] = (sphere.get_currentState().position[0] + sphere.get_radius()) + JNumber3D.NUM_TINY;

		if (sphere.get_currentState().position[1] - sphere.get_radius() < _minPos[1]) 
			_minPos[1] = (sphere.get_currentState().position[1] - sphere.get_radius()) - JNumber3D.NUM_TINY;

		if (sphere.get_currentState().position[1] + sphere.get_radius() > _maxPos[1]) 
			_maxPos[1] = (sphere.get_currentState().position[1] + sphere.get_radius()) + JNumber3D.NUM_TINY;

		if (sphere.get_currentState().position[2] - sphere.get_radius() < _minPos[2]) 
			_minPos[2] = (sphere.get_currentState().position[2] - sphere.get_radius()) - JNumber3D.NUM_TINY;

		if (sphere.get_currentState().position[2] + sphere.get_radius() > _maxPos[2]) 
			_maxPos[2] = (sphere.get_currentState().position[2] + sphere.get_radius()) + JNumber3D.NUM_TINY;
	};
				
	JAABox.prototype.addCapsule=function(capsule){
		var pos= capsule.getBottomPos(capsule.get_currentState());
		var _minPos=this._minPos;
		var _maxPos=this._maxPos;
		if (pos[0] - capsule.get_radius() < _minPos[0]) 
			_minPos[0] = (pos[0] - capsule.get_radius()) - JNumber3D.NUM_TINY;

		if (pos[0] + capsule.get_radius() > _maxPos[0]) 
			_maxPos[0] = (pos[0] + capsule.get_radius()) + JNumber3D.NUM_TINY;

		if (pos[1] - capsule.get_radius() < _minPos[1]) 
			_minPos[1] = (pos[1] - capsule.get_radius()) - JNumber3D.NUM_TINY;

		if (pos[1] + capsule.get_radius() > _maxPos[1]) 
			_maxPos[1] = (pos[1] + capsule.get_radius()) + JNumber3D.NUM_TINY;

		if (pos[2] - capsule.get_radius() < _minPos[2]) 
			_minPos[2] = (pos[2] - capsule.get_radius()) - JNumber3D.NUM_TINY;

		if (pos[2] + capsule.get_radius() > _maxPos[2]) 
			_maxPos[2] = (pos[2] + capsule.get_radius()) + JNumber3D.NUM_TINY;

		pos = capsule.getEndPos(capsule.get_currentState());

		if (pos[0] - capsule.get_radius() < _minPos[0]) 
			_minPos[0] = (pos[0] - capsule.get_radius()) - JNumber3D.NUM_TINY;

		if (pos[0] + capsule.get_radius() > _maxPos[0]) 
			_maxPos[0] = (pos[0] + capsule.get_radius()) + JNumber3D.NUM_TINY;

		if (pos[1] - capsule.get_radius() < _minPos[1]) 
			_minPos[1] = (pos[1] - capsule.get_radius()) - JNumber3D.NUM_TINY;

		if (pos[1] + capsule.get_radius() > _maxPos[1]) 
			_maxPos[1] = (pos[1] + capsule.get_radius()) + JNumber3D.NUM_TINY;

		if (pos[2] - capsule.get_radius() < _minPos[2]) 
			_minPos[2] = (pos[2] - capsule.get_radius()) - JNumber3D.NUM_TINY;

		if (pos[2] + capsule.get_radius() > _maxPos[2]) 
			_maxPos[2] = (pos[2] + capsule.get_radius()) + JNumber3D.NUM_TINY;
	};
				
	JAABox.prototype.addSegment=function(seg){
		this.addPoint(seg.origin);
		this.addPoint(seg.getEnd());
	};

	JAABox.prototype.overlapTest=function(box){
		var _minPos=this._minPos;
		var _maxPos=this._maxPos;
		return (
			(_minPos[2] >= box.get_maxPos()[2]) ||
			(_maxPos[2] <= box.get_minPos()[2]) ||
			(_minPos[1] >= box.get_maxPos()[1]) ||
			(_maxPos[1] <= box.get_minPos()[1]) ||
			(_minPos[0] >= box.get_maxPos()[0]) ||
			(_maxPos[0] <= box.get_minPos()[0]) ) ? false : true;
	};

	JAABox.prototype.isPointInside=function(pos){
		var _minPos=this._minPos;
		var _maxPos=this._maxPos;
		return ((pos[0] >= _minPos[0]) && 
				(pos[0] <= _maxPos[0]) && 
				(pos[1] >= _minPos[1]) && 
				(pos[1] <= _maxPos[1]) && 
				(pos[2] >= _minPos[2]) && 
				(pos[2] <= _maxPos[2]));
	};

	JAABox.prototype.toString=function(){
		var _minPos=this._minPos;
		var _maxPos=this._maxPos;
		return [_minPos[0],_minPos[1],_minPos[2],_maxPos[0],_maxPos[1],_maxPos[2]].toString();
	};

	jigLib.JAABox=JAABox;
	
})(jigLib);
/*
   Copyright (c) 2007 Danny Chapman
   http://www.rowlhouse.co.uk

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any damages
   arising from the use of this software.
   Permission is granted to anyone to use this software for any purpose,
   including commercial applications, and to alter it and redistribute it
   freely, subject to the following restrictions:
   1. The origin of this software must not be misrepresented; you must not
   claim that you wrote the original software. If you use this software
   in a product, an acknowledgment in the product documentation would be
   appreciated but is not required.
   2. Altered source versions must be plainly marked as such, and must not be
   misrepresented as being the original software.
   3. This notice may not be removed or altered from any source
   distribution.
 */

/**
 * @author Muzer(muzerly@gmail.com)
 * @link http://code.google.com/p/jiglibflash
 */
 
 (function(jigLib){
	
	 
	var BodyPair=function(_body0, _body1, r0, r1){
		if (_body0.id > _body1.id){
			this.body0 = _body0;
			this.body1 = _body1;
			this.r = r0;
		}else{
			this.body0 = _body1;
			this.body1 = _body0;
			this.r = r1;
		}
	};
	BodyPair.prototype.body0=null;
	BodyPair.prototype.body1=null;
	BodyPair.prototype.r=null;
	
	jigLib.BodyPair=BodyPair;
		
})(jigLib);/*
   Copyright (c) 2007 Danny Chapman
   http://www.rowlhouse.co.uk

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any damages
   arising from the use of this software.
   Permission is granted to anyone to use this software for any purpose,
   including commercial applications, and to alter it and redistribute it
   freely, subject to the following restrictions:
   1. The origin of this software must not be misrepresented; you must not
   claim that you wrote the original software. If you use this software
   in a product, an acknowledgment in the product documentation would be
   appreciated but is not required.
   2. Altered source versions must be plainly marked as such, and must not be
   misrepresented as being the original software.
   3. This notice may not be removed or altered from any source
   distribution.
 */

/**
 * @author Muzer(muzerly@gmail.com)
 * @link http://code.google.com/p/jiglibflash
 */
(function(jigLib){
	
	
	var CachedImpulse=function(_normalImpulse, _normalImpulseAux, _frictionImpulse){
		this.normalImpulse = _normalImpulse;
		this.normalImpulseAux = _normalImpulseAux;
		this.frictionImpulse = _frictionImpulse;
	};
	CachedImpulse.prototype.normalImpulse=null;
	CachedImpulse.prototype.normalImpulseAux=null;
	CachedImpulse.prototype.frictionImpulse=null;
	
	jigLib.CachedImpulse=CachedImpulse;
	
})(jigLib);/*
   Copyright (c) 2007 Danny Chapman
   http://www.rowlhouse.co.uk

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any damages
   arising from the use of this software.
   Permission is granted to anyone to use this software for any purpose,
   including commercial applications, and to alter it and redistribute it
   freely, subject to the following restrictions:
   1. The origin of this software must not be misrepresented; you must not
   claim that you wrote the original software. If you use this software
   in a product, an acknowledgment in the product documentation would be
   appreciated but is not required.
   2. Altered source versions must be plainly marked as such, and must not be
   misrepresented as being the original software.
   3. This notice may not be removed or altered from any source
   distribution.
 */

/**
 * @author Muzer(muzerly@gmail.com)
 * @link http://code.google.com/p/jiglibflash
 */
 
(function(jigLib){
	 
	var MaterialProperties=function(_restitution, _friction){
		if(_restitution==null) _restitution=0.25;
		if(_friction==null) _friction=0.25;
		this._restitution = _restitution;
		this._friction = _friction;
	};
	
	MaterialProperties.prototype._restitution=null;
	MaterialProperties.prototype._friction=null;
	
	MaterialProperties.prototype.get_restitution=function(){
		return this._restitution;
	};

	MaterialProperties.prototype.set_restitution=function(restitution){
		this._restitution = restitution;
	};

	MaterialProperties.prototype.get_friction=function(){
		return this._friction;
	};

	MaterialProperties.prototype.set_friction=function(friction){
		this._friction = friction;
	};
		
	jigLib.MaterialProperties=MaterialProperties;
	
})(jigLib);/*
   Copyright (c) 2007 Danny Chapman
   http://www.rowlhouse.co.uk

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any damages
   arising from the use of this software.
   Permission is granted to anyone to use this software for any purpose,
   including commercial applications, and to alter it and redistribute it
   freely, subject to the following restrictions:
   1. The origin of this software must not be misrepresented; you must not
   claim that you wrote the original software. If you use this software
   in a product, an acknowledgment in the product documentation would be
   appreciated but is not required.
   2. Altered source versions must be plainly marked as such, and must not be
   misrepresented as being the original software.
   3. This notice may not be removed or altered from any source
   distribution.
 */

/**
 * @author Muzer(muzerly@gmail.com)
 * @link http://code.google.com/p/jiglibflash
 */

(function(jigLib){
	
	var PhysicsController=function(){
		this._controllerEnabled = false;
	};
	
	PhysicsController.prototype._controllerEnabled=null;
	
	
	 // implement this to apply whatever forces are needed to the objects this controls
	PhysicsController.prototype.updateController=function(dt){
	};

	// register with the physics system
	PhysicsController.prototype.enableController=function(){
		if (this._controllerEnabled){
			return;
		}
		this._controllerEnabled = true;
		jigLib.PhysicsSystem.getInstance().addController(this);
	};

	// deregister from the physics system
	PhysicsController.prototype.disableController=function(){
		if (!this._controllerEnabled){
			return;
		}
		this._controllerEnabled = false;
		jigLib.PhysicsSystem.getInstance().removeController(this);
	};

	// are we registered with the physics system?
	PhysicsController.prototype.get_controllerEnabled=function(){
		return this._controllerEnabled;
	};
	
	jigLib.PhysicsController=PhysicsController;
	
})(jigLib);(function(jigLib){
	
	
	var Matrix3D=jigLib.Matrix3D;
	var JMaths3D=jigLib.JMaths3D;
	var JMatrix3D=jigLib.JMatrix3D;
	var JNumber3D=jigLib.JNumber3D;
	
	/**
	 * @author katopz
	 *				 Devin Reimer (blog.almostlogical.com)
	 */
	var PhysicsState=function(){
		this.position = [0,0,0,0];
		this._orientation = new Matrix3D();
		this.linVelocity = [0,0,0,0];
		this.rotVelocity = [0,0,0,0];
		this.orientationCols= [];
		this.orientationCols[0] = [0,0,0,0];
		this.orientationCols[1] = [0,0,0,0];
		this.orientationCols[2] = [0,0,0,0];
	};
	
	PhysicsState.prototype.get_orientation=function(){ return this._orientation; };
	
	PhysicsState.prototype.set_orientation=function(val){
		this._orientation = val;			 
		var _rawData = this._orientation.glmatrix;
						
		this.orientationCols[0][0] = _rawData[0];
		this.orientationCols[0][1] = _rawData[1];
		this.orientationCols[0][2] = _rawData[2];
		
		this.orientationCols[1][0] = _rawData[4];
		this.orientationCols[1][1] = _rawData[5];
		this.orientationCols[1][2] = _rawData[6];
		
		this.orientationCols[2][0] = _rawData[8];
		this.orientationCols[2][1] = _rawData[9];
		this.orientationCols[2][2] = _rawData[10];
	};
		
	//here for backwards compatibility should use public function instead unless you need a clone
	PhysicsState.prototype.getOrientationCols=function(){
		return JMatrix3D.getCols(this._orientation);
	};
	
	jigLib.PhysicsState=PhysicsState;
	
})(jigLib);/*
   Copyright (c) 2007 Danny Chapman
   http://www.rowlhouse.co.uk

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any damages
   arising from the use of this software.
   Permission is granted to anyone to use this software for any purpose,
   including commercial applications, and to alter it and redistribute it
   freely, subject to the following restrictions:
   1. The origin of this software must not be misrepresented; you must not
   claim that you wrote the original software. If you use this software
   in a product, an acknowledgment in the product documentation would be
   appreciated but is not required.
   2. Altered source versions must be plainly marked as such, and must not be
   misrepresented as being the original software.
   3. This notice may not be removed or altered from any source
   distribution.
 */

/**
 * @author Muzer(muzerly@gmail.com)
 * @link http://code.google.com/p/jiglibflash
 */
 
(function(jigLib){
	var Vector3DUtil=jigLib.Vector3DUtil;
	var JConfig=jigLib.JConfig;
	var Matrix3D=jigLib.Matrix3D;
	var JMatrix3D=jigLib.JMatrix3D;
	var JNumber3D=jigLib.JNumber3D;
	var MaterialProperties=jigLib.MaterialProperties;
	var PhysicsState=jigLib.PhysicsState;
	var PhysicsSystem=jigLib.PhysicsSystem;
	var JAABox=jigLib.JAABox;
	
	var RigidBody=function(skin){
		this._useDegrees = (JConfig.rotationType == "DEGREES") ? true : false;
		
		this._id = RigidBody.idCounter++;

		this._skin = skin;
		this._material = new MaterialProperties();

		this._bodyInertia = new Matrix3D();
		this._bodyInvInertia = JMatrix3D.getInverseMatrix(this._bodyInertia);

		this._currState = new PhysicsState();
		this._oldState = new PhysicsState();
		this._storeState = new PhysicsState();
		this._invOrientation = JMatrix3D.getInverseMatrix(this._currState.get_orientation());
		this._currLinVelocityAux = [0,0,0,0];
		this._currRotVelocityAux = [0,0,0,0];

		this._force = [0,0,0,0];
		this._torque = [0,0,0,0];
			
		this._linVelDamping = [0.995, 0.995, 0.995, 0];
		this._rotVelDamping = [0.5, 0.5, 0.5, 0];
		this._maxLinVelocities = 500;
		this._maxRotVelocities = 50;

		this._velChanged = false;
		this._inactiveTime = 0;
		
		this._doShockProcessing = true;

		this.isActive = this._activity = true;
		this._movable = true;
		this._origMovable = true;

		this.collisions = [];
		this._constraints = [];
		this._nonCollidables = [];

		this._storedPositionForActivation = [0,0,0,0];
		this._bodiesToBeActivatedOnMovement = [];
		this._lastPositionForDeactivation = this._currState.position.slice(0);
		this._lastOrientationForDeactivation = this._currState.get_orientation().clone();

		this._type = "Object3D";
		this._boundingSphere = 0;
		this._boundingBox = new JAABox([0,0,0,0], [0,0,0,0]);
		this._boundingBox.clear();
	};
	
	RigidBody.idCounter = 0;
	
	RigidBody.prototype._id=null;
	RigidBody.prototype._skin=null;
	RigidBody.prototype._type=null;
	RigidBody.prototype._boundingSphere=null;
	RigidBody.prototype._boundingBox=null;
	RigidBody.prototype._currState=null;
	RigidBody.prototype._oldState=null;
	RigidBody.prototype._storeState=null;
	RigidBody.prototype._invOrientation=null;
	RigidBody.prototype._currLinVelocityAux=null;
	RigidBody.prototype._currRotVelocityAux=null;

	RigidBody.prototype._mass=null;
	RigidBody.prototype._invMass=null;
	RigidBody.prototype._bodyInertia=null;
	RigidBody.prototype._bodyInvInertia=null;
	RigidBody.prototype._worldInertia=null;
	RigidBody.prototype._worldInvInertia=null;

	RigidBody.prototype._force=null;
	RigidBody.prototype._torque=null;
		
	RigidBody.prototype._linVelDamping=null;
	RigidBody.prototype._rotVelDamping=null;
	RigidBody.prototype._maxLinVelocities=null;
	RigidBody.prototype._maxRotVelocities=null;

	RigidBody.prototype._velChanged=null;
	RigidBody.prototype._activity=null;
	RigidBody.prototype._movable=null;
	RigidBody.prototype._origMovable=null;
	RigidBody.prototype._inactiveTime=null;
	RigidBody.prototype._doShockProcessing=null;

	// The list of bodies that need to be activated when we move away from our stored position
	RigidBody.prototype._bodiesToBeActivatedOnMovement=null;

	RigidBody.prototype._storedPositionForActivation=null;// The position stored when we need to notify other bodies
	RigidBody.prototype._lastPositionForDeactivation=null;// last position for when trying the deactivate
	RigidBody.prototype._lastOrientationForDeactivation=null;// last orientation for when trying to deactivate

	RigidBody.prototype._material=null;

	RigidBody.prototype._rotationX = 0;
	RigidBody.prototype._rotationY = 0;
	RigidBody.prototype._rotationZ = 0;
	RigidBody.prototype._useDegrees=null;

	RigidBody.prototype._nonCollidables=null;
	RigidBody.prototype._constraints=null;
	RigidBody.prototype.collisions=null;
	
	RigidBody.prototype.isActive=null;
	
	RigidBody.prototype.radiansToDegrees=function(rad){
		return rad * 180 / Math.PI;
	};
	
	RigidBody.prototype.degreesToRadians=function(deg){
		return deg * Math.PI / 180;
	};
	
	RigidBody.prototype.get_rotationX=function(){
		return this._rotationX;//(_useDegrees) ? radiansToDegrees(_rotationX) : _rotationX;
	};
	
	RigidBody.prototype.get_rotationY=function(){
		return this._rotationY;//(_useDegrees) ? radiansToDegrees(_rotationY) : _rotationY;
	};

	RigidBody.prototype.get_rotationZ=function(){
		return this._rotationZ;//(_useDegrees) ? radiansToDegrees(_rotationZ) : _rotationZ;
	};
	
	/**
	* px - angle in Radians or Degrees
	*/
	RigidBody.prototype.set_rotationX=function(px){
		//var rad:Number = (_useDegrees) ? degreesToRadians(px) : px;
		this._rotationX = px;
		this.setOrientation(this.createRotationMatrix());
	};

	/**
	* py - angle in Radians or Degrees
	*/
	RigidBody.prototype.set_rotationY=function(py){
		//var rad:Number = (_useDegrees) ? degreesToRadians(py) : py;
		this._rotationY = py;
		this.setOrientation(this.createRotationMatrix());
	};

	/**
	* pz - angle in Radians or Degrees
	*/
	RigidBody.prototype.set_rotationZ=function(pz){
		//var rad:Number = (_useDegrees) ? degreesToRadians(pz) : pz;
		this._rotationZ = pz;
		this.setOrientation(this.createRotationMatrix());
	};
	
	/**
	 * @param vect - [x,y,z] rotation
	 * @returns
	 */
	RigidBody.prototype.setRotation=function(vect){
		this._rotationX=vect[0];
		this._rotationY=vect[1];
		this._rotationZ=vect[2];
		this.setOrientation(this.createRotationMatrix());
	};

	RigidBody.prototype.pitch=function(rot){
		this.setOrientation(JMatrix3D.getAppendMatrix3D(this.get_currentState().orientation, JMatrix3D.getRotationMatrixAxis(rot, Vector3DUtil.X_AXIS)));
	};

	RigidBody.prototype.yaw=function(rot){
		this.setOrientation(JMatrix3D.getAppendMatrix3D(this.get_currentState().orientation, JMatrix3D.getRotationMatrixAxis(rot, Vector3DUtil.Y_AXIS)));
	};

	RigidBody.prototype.roll=function(rot){
		this.setOrientation(JMatrix3D.getAppendMatrix3D(this.get_currentState().orientation, JMatrix3D.getRotationMatrixAxis(rot, Vector3DUtil.Z_AXIS)));
	};
	
	RigidBody.prototype.createRotationMatrix=function(){
		var matrix3D = new Matrix3D();
		matrix3D.appendRotation(this._rotationX, Vector3DUtil.X_AXIS);
		matrix3D.appendRotation(this._rotationY, Vector3DUtil.Y_AXIS);
		matrix3D.appendRotation(this._rotationZ, Vector3DUtil.Z_AXIS);
		return matrix3D;
	};

	RigidBody.prototype.setOrientation=function(orient){
		this._currState.set_orientation(orient.clone());
		this.updateInertia();
		this.updateState();
	};

	RigidBody.prototype.get_position=function(){
		return this._currState.position;
	};

	RigidBody.prototype.get_x=function(){
		return this._currState.position[0];
	};

	RigidBody.prototype.get_y=function(){
		return this._currState.position[1];
	};

	RigidBody.prototype.get_z=function(){
		return _currState.position[2];
	};

	RigidBody.prototype.set_x=function(px){
		this._currState.position[0] = px;
		this.updateState();
	};

	RigidBody.prototype.set_y=function(py){
		this._currState.position[1] = py;
		this.updateState();
	};

	RigidBody.prototype.set_z=function(pz){
		this._currState.position[2] = pz;
		this.updateState();
	};
	
	RigidBody.prototype.moveTo=function(pos){
		this._currState.position = pos.slice(0);
		this.updateState();
	};

	RigidBody.prototype.updateState=function(){
		this._currState.linVelocity = [0,0,0,0];
		this._currState.rotVelocity = [0,0,0,0];
		this.copyCurrentStateToOld();
		this.updateBoundingBox();
	};

	RigidBody.prototype.setVelocity=function(vel){
		this._currState.linVelocity = vel.slice(0);
	};

	RigidBody.prototype.setAngVel=function(angVel){
		this._currState.rotVelocity = angVel.slice(0);
	};

	RigidBody.prototype.setVelocityAux=function(vel){
		this._currLinVelocityAux = vel.slice(0);
	};

	RigidBody.prototype.setAngVelAux=function(angVel){
		this._currRotVelocityAux = angVel.slice(0);
	};

	RigidBody.prototype.addGravity=function(){
		if (!this._movable){
			return;
		}
		this._force = Vector3DUtil.add(this._force, JNumber3D.getScaleVector(jigLib.PhysicsSystem.getInstance().get_gravity(), this._mass));
		this._velChanged = true;
	};
	
	RigidBody.prototype.addExternalForces=function(dt){
		this.addGravity();
	};

	RigidBody.prototype.addWorldTorque=function(t){
		if (!this._movable){
			return;
		}
		this._torque = Vector3DUtil.add(this._torque, t);
		this._velChanged = true;
		this.setActive();
	};

	RigidBody.prototype.addBodyTorque=function(t){
		if (!this._movable){
			return;
		}
		JMatrix3D.multiplyVector(this._currState.get_orientation(), t);
		this.addWorldTorque(t);
	};

	// functions to add forces in the world coordinate frame
	RigidBody.prototype.addWorldForce=function(f, p){
		if (!this._movable){
			return;
		}
		this._force = Vector3DUtil.add(this._force, f);
		this.addWorldTorque(Vector3DUtil.crossProduct(Vector3DUtil.subtract(p, this._currState.position), f));
		this._velChanged = true;
		this.setActive();
	};

	// functions to add forces in the body coordinate frame
	RigidBody.prototype.addBodyForce=function(f, p){
		if (!this._movable){
			return;
		}
		JMatrix3D.multiplyVector(this._currState.get_orientation(), f);
		JMatrix3D.multiplyVector(this._currState.get_orientation(), p);
		this.addWorldForce(f, Vector3DUtil.add(this._currState.position, p));
	};

	// This just sets all forces etc to zero
	RigidBody.prototype.clearForces=function(){
		this._force = [0,0,0,0];
		this._torque = [0,0,0,0];
	};
	

	// functions to add impulses in the world coordinate frame
	RigidBody.prototype.applyWorldImpulse=function(impulse, pos){
		if (!this._movable) return;
		
		this._currState.linVelocity = Vector3DUtil.add(this._currState.linVelocity, JNumber3D.getScaleVector(impulse, this._invMass));

		var rotImpulse = Vector3DUtil.crossProduct(Vector3DUtil.subtract(pos, this._currState.position), impulse);
		JMatrix3D.multiplyVector(this._worldInvInertia, rotImpulse);
		this._currState.rotVelocity = Vector3DUtil.add(this._currState.rotVelocity, rotImpulse);

		this._velChanged = true;
	};

	RigidBody.prototype.applyWorldImpulseAux=function(impulse, pos){
		if (!this._movable) return;
		
		this._currLinVelocityAux = Vector3DUtil.add(this._currLinVelocityAux, JNumber3D.getScaleVector(impulse, this._invMass));

		var rotImpulse = Vector3DUtil.crossProduct(Vector3DUtil.subtract(pos, this._currState.position), impulse);
		JMatrix3D.multiplyVector(this._worldInvInertia, rotImpulse);
		this._currRotVelocityAux = Vector3DUtil.add(this._currRotVelocityAux, rotImpulse);

		this._velChanged = true;
	};

	// functions to add impulses in the body coordinate frame
	RigidBody.prototype.applyBodyWorldImpulse=function(impulse, delta){
		if (!this._movable) return;
		
		this._currState.linVelocity = Vector3DUtil.add(this._currState.linVelocity, JNumber3D.getScaleVector(impulse, this._invMass));
		var rotImpulse = Vector3DUtil.crossProduct(delta, impulse);
		JMatrix3D.multiplyVector(this._worldInvInertia, rotImpulse);
		this._currState.rotVelocity = Vector3DUtil.add(this._currState.rotVelocity, rotImpulse);

		this._velChanged = true;
	};

	RigidBody.prototype.applyBodyWorldImpulseAux=function(impulse, delta){
		if (!this._movable) return;
		
		this._currLinVelocityAux = Vector3DUtil.add(this._currLinVelocityAux, JNumber3D.getScaleVector(impulse, this._invMass));

		var rotImpulse = Vector3DUtil.crossProduct(delta, impulse);
		JMatrix3D.multiplyVector(this._worldInvInertia, rotImpulse);
		this._currRotVelocityAux = Vector3DUtil.add(this._currRotVelocityAux, rotImpulse);

		this._velChanged = true;
	};

	RigidBody.prototype.addConstraint=function(constraint){
		if (!this.findConstraint(constraint)){
			this._constraints.push(constraint);
		}
	};

	RigidBody.prototype.removeConstraint=function(constraint){
		if (this.findConstraint(constraint)){
			this._constraints.splice(this._constraints.indexOf(constraint), 1);
		}
	};

	RigidBody.prototype.removeAllConstraints=function(){
		this._constraints = [];
	};

	RigidBody.prototype.findConstraint=function(constraint){
		for(var i=0, cl=this._constraints.length; i<cl; i++){
			if (constraint == this._constraints[i]){
				return true;
			}
		}
		return false;
	};

	// implementation updates the velocity/angular rotation with the force/torque.
	RigidBody.prototype.updateVelocity=function(dt){
		if (!this._movable || !this._activity){
			return;
		}
		this._currState.linVelocity = Vector3DUtil.add(this._currState.linVelocity, JNumber3D.getScaleVector(this._force, this._invMass * dt));

		var rac = JNumber3D.getScaleVector(this._torque, dt);
		JMatrix3D.multiplyVector(this._worldInvInertia, rac);
		this._currState.rotVelocity = Vector3DUtil.add(this._currState.rotVelocity, rac);
	};
	
	// Updates the position with the auxiliary velocities, and zeros them
	RigidBody.prototype.updatePositionWithAux=function(dt){
		if (!this._movable || !this._activity){
			this._currLinVelocityAux = [0,0,0,0];
			this._currRotVelocityAux = [0,0,0,0];
			return;
		}
		
		var ga = jigLib.PhysicsSystem.getInstance().get_gravityAxis();
		
		if (ga != -1){
			var arr = JNumber3D.toArray(this._currLinVelocityAux);
			arr[(ga + 1) % 3] *= 0.1;
			arr[(ga + 2) % 3] *= 0.1;
			JNumber3D.copyFromArray(this._currLinVelocityAux, arr);
		}

		var angMomBefore = this._currState.rotVelocity.slice(0);
		JMatrix3D.multiplyVector(this._worldInertia, angMomBefore);
		
		this._currState.position = Vector3DUtil.add(this._currState.position, JNumber3D.getScaleVector(Vector3DUtil.add(this._currState.linVelocity, this._currLinVelocityAux), dt));

		var dir = Vector3DUtil.add(this._currState.rotVelocity, this._currRotVelocityAux);
		var ang = Vector3DUtil.get_length(dir) * 180 / Math.PI;
		if (ang > 0){
			Vector3DUtil.normalize(dir);
			ang *= dt;
			var rot = JMatrix3D.getRotationMatrix(dir[0], dir[1], dir[2], ang);
			this._currState.set_orientation(JMatrix3D.getAppendMatrix3D(this._currState.get_orientation(), rot));
				
			this.updateInertia();
		}
		this._currLinVelocityAux = [0,0,0,0];
		this._currRotVelocityAux = [0,0,0,0];
		
		JMatrix3D.multiplyVector(this._worldInvInertia, angMomBefore);
		this._currState.rotVelocity = angMomBefore.slice(0);
			
		this.updateBoundingBox();
	};

	RigidBody.prototype.postPhysics=function(dt){};

	// function provided for the use of Physics system
	RigidBody.prototype.tryToFreeze=function(dt){
		if (!this._movable || !this._activity){
			return;
		}
			
		if (Vector3DUtil.get_length(Vector3DUtil.subtract(this._currState.position, this._lastPositionForDeactivation)) > JConfig.posThreshold){
			this._lastPositionForDeactivation = this._currState.position.slice(0);
			this._inactiveTime = 0;
			return;
		}
		
		var ot = JConfig.orientThreshold;
		var deltaMat = JMatrix3D.getSubMatrix(this._currState.get_orientation(), this._lastOrientationForDeactivation);

		var cols = JMatrix3D.getCols(deltaMat);

		if (Vector3DUtil.get_length(cols[0]) > ot || Vector3DUtil.get_length(cols[1]) > ot || Vector3DUtil.get_length(cols[2]) > ot){
			this._lastOrientationForDeactivation = this._currState.get_orientation().clone();
			this._inactiveTime = 0;
			return;
		}

		if (this.getShouldBeActive()){
			return;
		}

		this._inactiveTime += dt;
		if (this._inactiveTime > JConfig.deactivationTime){
			this._lastPositionForDeactivation = this._currState.position.slice(0);
			this._lastOrientationForDeactivation = this._currState.get_orientation().clone();
			this.setInactive();
		}
	};

	RigidBody.prototype.set_mass=function(m){
		this._mass = m;
		this._invMass = 1 / m;
		this.setInertia(this.getInertiaProperties(m));
	};

	RigidBody.prototype.setInertia=function(matrix3D){
		this._bodyInertia =  matrix3D.clone();
		this._bodyInvInertia = JMatrix3D.getInverseMatrix(this._bodyInertia.clone());
			
		this.updateInertia();
	};
	
	RigidBody.prototype.updateInertia=function(){
		this._invOrientation = JMatrix3D.getTransposeMatrix(this._currState.get_orientation());
			
		this._worldInertia = JMatrix3D.getAppendMatrix3D(
			this._invOrientation,
			JMatrix3D.getAppendMatrix3D(this._currState.get_orientation(), this._bodyInertia)
		);

		this._worldInvInertia = JMatrix3D.getAppendMatrix3D(
			this._invOrientation,
				JMatrix3D.getAppendMatrix3D(this._currState.get_orientation(), this._bodyInvInertia)
			);
	};

	// prevent velocity updates etc 
	RigidBody.prototype.get_movable=function(){
		return this._movable;
	};

	RigidBody.prototype.set_movable=function(mov){
		if (this._type == "PLANE" || this._type == "TERRAIN") 
			return;

		this._movable = mov;
		this.isActive = this._activity = mov;
		this._origMovable = mov;
	};

	RigidBody.prototype.internalSetImmovable=function(){
		if (this._type == "PLANE" || this._type == "TERRAIN") 
			return;
		this._origMovable = this._movable;
		this._movable = false;
	};

	RigidBody.prototype.internalRestoreImmovable=function(){
		if (this._type == "PLANE" || this._type == "TERRAIN") 
			return;
		this._movable = this._origMovable;
	};

	RigidBody.prototype.getVelChanged=function(){
		return this._velChanged;
	};

	RigidBody.prototype.clearVelChanged=function(){
		this._velChanged = false;
	};

	RigidBody.prototype.setActive=function(activityFactor){
		if(!activityFactor) activityFactor=1;
		if (this._movable){
			this.isActive = this._activity = true;
			this._inactiveTime = (1 - activityFactor) * JConfig.deactivationTime;
		}
	};

	RigidBody.prototype.setInactive=function(){
		if (this._movable){
			this.isActive = this._activity = false;
		}
	};

	// Returns the velocity of a point at body-relative position
	RigidBody.prototype.getVelocity=function(relPos){
		return Vector3DUtil.add(this._currState.linVelocity, Vector3DUtil.crossProduct(this._currState.rotVelocity, relPos));
	};

	// As GetVelocity but just uses the aux velocities
	RigidBody.prototype.getVelocityAux=function(relPos){
		return Vector3DUtil.add(this._currLinVelocityAux, Vector3DUtil.crossProduct(this._currRotVelocityAux, relPos));
	};
		

	// indicates if the velocity is above the threshold for freezing
	RigidBody.prototype.getShouldBeActive=function(){
		return ((Vector3DUtil.get_length(this._currState.linVelocity) > JConfig.velThreshold) || (Vector3DUtil.get_length(this._currState.rotVelocity) > JConfig.angVelThreshold));
	};

	RigidBody.prototype.getShouldBeActiveAux=function(){
		return ((Vector3DUtil.get_length(this._currLinVelocityAux) > JConfig.velThreshold) || (Vector3DUtil.get_length(this._currRotVelocityAux) > JConfig.angVelThreshold));
	};

	// damp movement as the body approaches deactivation
	RigidBody.prototype.dampForDeactivation=function(){
		this._currState.linVelocity[0] *= this._linVelDamping[0];
		this._currState.linVelocity[1] *= this._linVelDamping[1];
		this._currState.linVelocity[2] *= this._linVelDamping[2];
		this._currState.rotVelocity[0] *= this._rotVelDamping[0];
		this._currState.rotVelocity[1] *= this._rotVelDamping[1];
		this._currState.rotVelocity[2] *= this._rotVelDamping[2];
			
		this._currLinVelocityAux[0] *= this._linVelDamping[0];
		this._currLinVelocityAux[1] *= this._linVelDamping[1];
		this._currLinVelocityAux[2] *= this._linVelDamping[2];
		this._currRotVelocityAux[0] *= this._rotVelDamping[0];
		this._currRotVelocityAux[1] *= this._rotVelDamping[1];
		this._currRotVelocityAux[2] *= this._rotVelDamping[2];
			
		var r = 0.5;
		var frac = this._inactiveTime / JConfig.deactivationTime;
		if (frac < r){
			return;
		}

		var scale = 1 - ((frac - r) / (1 - r));
		if (scale < 0){
			scale = 0;
		}else if (scale > 1){
			scale = 1;
		}
		this._currState.linVelocity = JNumber3D.getScaleVector(this._currState.linVelocity, scale);
		this._currState.rotVelocity = JNumber3D.getScaleVector(this._currState.rotVelocity, scale);
	};

	// function provided for use of physics system. Activates any
	// body in its list if it's moved more than a certain distance,
	// in which case it also clears its list.
	RigidBody.prototype.doMovementActivations=function(){
		var numBodies = this._bodiesToBeActivatedOnMovement.length;
		if (numBodies == 0 || Vector3DUtil.get_length(Vector3DUtil.subtract(this._currState.position, this._storedPositionForActivation)) < JConfig.posThreshold)
			return;
		
		for (var i = 0; i<numBodies; i++){
			jigLib.PhysicsSystem.getInstance().activateObject(this._bodiesToBeActivatedOnMovement[i]);
		}
		this._bodiesToBeActivatedOnMovement = [];
	};

	// adds the other body to the list of bodies to be activated if
	// this body moves more than a certain distance from either a
	// previously stored position, or the position passed in.
	RigidBody.prototype.addMovementActivation=function(pos, otherBody){
		var len = this._bodiesToBeActivatedOnMovement.length;
		for (var i = 0; i < len; i++){
			if (this._bodiesToBeActivatedOnMovement[i] == otherBody){
				return;
			}
		}
		if (this._bodiesToBeActivatedOnMovement.length == 0){
			this._storedPositionForActivation = pos;
		}
		this._bodiesToBeActivatedOnMovement.push(otherBody);
	};

	// Marks all constraints/collisions as being unsatisfied
	RigidBody.prototype.setConstraintsAndCollisionsUnsatisfied=function(){
		for(var i=0, cl=this._constraints.length; i<cl; i++){
			this._constraints[i].set_satisfied(false);
		}
		for(var i=0, cll=this.collisions.length; i<cll; i++){
			this.collisions[i].satisfied = false;
		}
	};

	RigidBody.prototype.segmentIntersect=function(out, seg, state){
		return false;
	};

	RigidBody.prototype.getInertiaProperties=function(m){
		return new Matrix3D();
	};
		
	RigidBody.prototype.updateBoundingBox=function(){
	};

	RigidBody.prototype.hitTestObject3D=function(obj3D){
		var num1 = Vector3DUtil.get_length(Vector3DUtil.subtract(this._currState.position, obj3D.get_currentState().position));
		var num2 = this._boundingSphere + obj3D.get_boundingSphere();

		if (num1 <= num2){
			return true;
		}

		return false;
	};

	RigidBody.prototype.findNonCollidablesBody=function(body){
		for(var i=0, ncl=this._nonCollidables.length; i<ncl; i++){
			if (body == this._nonCollidables[i])
				return true;
		}
		return false;
	};

	RigidBody.prototype.disableCollisions=function(body){
		if (!this.findNonCollidablesBody(body)){
			this._nonCollidables.push(body);
		}
	};

	RigidBody.prototype.enableCollisions=function(body){
		if (this.findNonCollidablesBody(body)){
			this._nonCollidables.splice(this._nonCollidables.indexOf(body), 1);
		}
	};

	// copies the current position etc to old - normally called only by physicsSystem.
	RigidBody.prototype.copyCurrentStateToOld=function(){
		this._oldState.position = this._currState.position.slice(0);
		this._oldState.set_orientation(this._currState.get_orientation().clone());
		this._oldState.linVelocity = this._currState.linVelocity.slice(0);
		this._oldState.rotVelocity = this._currState.rotVelocity.slice(0);
	};

	// Copy our current state into the stored state
	RigidBody.prototype.storeState=function(){
		this._storeState.position = this._currState.position.slice(0);
		this._storeState.set_orientation(this._currState.get_orientation().clone());
		this._storeState.linVelocity = this._currState.linVelocity.slice(0);
		this._storeState.rotVelocity = this._currState.rotVelocity.slice(0);
	};

	// restore from the stored state into our current state.
	RigidBody.prototype.restoreState=function(){
		this._currState.position = this._storeState.position.slice(0);
		this._currState.set_orientation(this._storeState.get_orientation().clone());
		this._currState.linVelocity = this._storeState.linVelocity.slice(0);
		this._currState.rotVelocity = this._storeState.rotVelocity.slice(0);
	};

	// the "working" state
	RigidBody.prototype.get_currentState=function(){
		return this._currState;
	};

	// the previous state - copied explicitly using copyCurrentStateToOld
	RigidBody.prototype.get_oldState=function(){
		return this._oldState;
	};

	RigidBody.prototype.get_id=function(){
		return this._id;
	};

	RigidBody.prototype.get_type=function(){
		return this._type;
	};

	RigidBody.prototype.get_skin=function(){
		return this._skin;
	};

	RigidBody.prototype.get_boundingSphere=function(){
		return this._boundingSphere;
	};
		
	RigidBody.prototype.get_boundingBox=function(){
		return this._boundingBox;
	};

	// force in world frame
	RigidBody.prototype.get_force=function(){
		return this._force;
	};

	// torque in world frame
	RigidBody.prototype.get_mass=function(){
		return this._mass;
	};

	RigidBody.prototype.get_invMass=function(){
		return this._invMass;
	};

	// inertia tensor in world space
	RigidBody.prototype.get_worldInertia=function(){
		return this._worldInertia;
	};

	// inverse inertia in world frame
	RigidBody.prototype.get_worldInvInertia=function(){
		return this._worldInvInertia;
	};

	RigidBody.prototype.get_nonCollidables=function(){
		return this._nonCollidables;
	};
	
	RigidBody.prototype.get_doShockProcessing=function(){
		return this._doShockProcessing;
	};
	RigidBody.prototype.set_doShockProcessing=function(doShock){
		this._doShockProcessing = doShock;
	};

	//every dimension should be set to 0-1;
	RigidBody.prototype.set_linVelocityDamping=function(vel){
		this._linVelDamping[0] = JNumber3D.getLimiteNumber(vel[0], 0, 1);
		this._linVelDamping[1] = JNumber3D.getLimiteNumber(vel[1], 0, 1);
		this._linVelDamping[2] = JNumber3D.getLimiteNumber(vel[2], 0, 1);
	};
		
	RigidBody.prototype.get_linVelocityDamping=function(){
		return this._linVelDamping;
	};
		
	//every dimension should be set to 0-1;
	RigidBody.prototype.set_rotVelocityDamping=function(vel){
		this._rotVelDamping[0] = JNumber3D.getLimiteNumber(vel[0], 0, 1);
		this._rotVelDamping[1] = JNumber3D.getLimiteNumber(vel[1], 0, 1);
		this._rotVelDamping[2] = JNumber3D.getLimiteNumber(vel[2], 0, 1);
	};
	
	RigidBody.prototype.get_rotVelocityDamping=function(){
		return this._rotVelDamping;
	};
		
	//limit the max value of body's line velocity
	RigidBody.prototype.set_maxLinVelocities=function(vel){
		this._maxLinVelocities = JNumber3D.getLimiteNumber(Math.abs(vel), 0, 500);
	};
	RigidBody.prototype.get_maxLinVelocities=function(){
		return this._maxLinVelocities;
	};

	//limit the max value of body's angle velocity
	RigidBody.prototype.set_maxRotVelocities=function(vel){
		this._maxRotVelocities = JNumber3D.getLimiteNumber(Math.abs(vel), JNumber3D.NUM_TINY, 50);
	};
	
	RigidBody.prototype.get_maxRotVelocities=function(){
		return this._maxRotVelocities;
	};

	RigidBody.prototype.limitVel=function(){
		this._currState.linVelocity[0] = JNumber3D.getLimiteNumber(this._currState.linVelocity[0], -this._maxLinVelocities, this._maxLinVelocities);
		this._currState.linVelocity[1] = JNumber3D.getLimiteNumber(this._currState.linVelocity[1], -this._maxLinVelocities, this._maxLinVelocities);
		this._currState.linVelocity[2] = JNumber3D.getLimiteNumber(this._currState.linVelocity[2], -this._maxLinVelocities, this._maxLinVelocities);
	};

	RigidBody.prototype.limitAngVel=function(){
		var fx = Math.abs(this._currState.rotVelocity[0]) / this._maxRotVelocities;
		var fy = Math.abs(this._currState.rotVelocity[1]) / this._maxRotVelocities;
		var fz = Math.abs(this._currState.rotVelocity[2]) / this._maxRotVelocities;
		var f = Math.max(fx, fy, fz);
		if (f > 1){
			this._currState.rotVelocity = JNumber3D.getDivideVector(this._currState.rotVelocity, f);
		}
	};

	RigidBody.prototype.getTransform=function(){
		if (this._skin != null){
			return this._skin.get_transform();
		}else{
			return null;
		}
	};

	//update skin
	RigidBody.prototype.updateObject3D=function(){
		if (this._skin != null){
			this._skin.set_transform(JMatrix3D.getAppendMatrix3D(this._currState.get_orientation(), JMatrix3D.getTranslationMatrix(this._currState.position[0], this._currState.position[1], this._currState.position[2])));
		}
	};

	RigidBody.prototype.get_material=function(){
		return this._material;
	};

	//coefficient of elasticity
	RigidBody.prototype.get_restitution=function(){
		return this._material.get_restitution();
	};

	RigidBody.prototype.set_restitution=function(restitution){
		this._material.set_restitution(JNumber3D.getLimiteNumber(restitution, 0, 1));
	};

	//coefficient of friction
	RigidBody.prototype.get_friction=function(){
		return this._material.get_friction();
	};

	RigidBody.prototype.set_friction=function(friction){
		this._material.set_friction(JNumber3D.getLimiteNumber(friction, 0, 1));
	};
	
	jigLib.RigidBody=RigidBody;
})(jigLib);(function(jigLib){
	var JEffect=function(){
		this.enabled = true;
	};
	
	JEffect.prototype._eventEnabled=false;
	JEffect.prototype.__defineGetter__('enabled', function() { return this._eventEnabled; });
	JEffect.prototype.__defineSetter__('enabled', 
										function(bool) {
											  				if (bool == this._eventEnabled) return;
											  				this._eventEnabled = bool;
											  				if (bool) jigLib.PhysicsSystem.getInstance().addEvent(this);
											  				else jigLib.PhysicsSystem.getInstance().removeEvent(this);
														});
	
	/**
	 * this should be implemented by the effect to apply force to 
	 * bodies in the physics system as appropriate.
	 * 
	 * @returns
	 */
	JEffect.prototype.Apply=function(){
		return false;
	};
	
	jigLib.JEffect=JEffect;
})(jigLib);(function(jigLib){
	var Vector3DUtil=jigLib.Vector3DUtil;
	/**
	 * @author Jim Sangwine
	 * 
	 * This effect has a radius within which it will repel bodies depending on the defined force 
	 * and their distance (the closer the object, the stronger the effect). 
	 * 
	 * This effect will only be applied during a single cycle of the PhysicsSystem, imparting a sudden impulse.
	 * 
	 * This effect can either be placed at an arbitrary location in the scene, or it can be attached to a parent object.
	 * 
	 * @param {Array}	location	vector array in the format [x,y,z]
	 * @param {Number}	radius		radius of effect - at [radius] distance, gravity effect will be 0
	 * @param {Number}	force		the force of the explosion at 0 distance (impulse will be force/distance)
	 * @param {Object}	parent		optional - a RigidBody that the gravitational field will follow - excluded from effect
	 * @param {Boolean}	relativity	optional - toggle whether or not the parent obeys the theory of relativity 
	 **/
	var Explosion=function(_location, _radius, _force, _parent, _relativity) {
		this.Super();
		this.location=_location;
		this.radius=_radius;
		this.force=_force;
		if (_parent) this.parent=_parent;
		if (_parent && _relativity) this.relativity=true;
		// set to NOT fire instantly...
		this.enabled = false;
	};
	jigLib.extend(Explosion,jigLib.JEffect);

	Explosion.prototype.location = null;
	Explosion.prototype.radius = null;
	Explosion.prototype.force = null;
	Explosion.prototype.parent = null;
	Explosion.prototype.relativity = false;

	/**
	 * Sets the effect to fire the next time Apply() is called
	 **/
	Explosion.prototype.explode = function() {
		this.enabled = true;
	};
	
	/**
	 * Applies the effect to the relevant bodies.
	 * Typically called by PhysicsSystem.handleAllEffects. 
	 **/
	Explosion.prototype.Apply = function() {
		this.enabled = false;
		var system=jigLib.PhysicsSystem.getInstance();
		
		var bodies=system.get_bodies();
		var i=bodies.length;
		var curBody, distance, force, forceV;
		var forceVP=[0,0,0,0];
		
		if (this.parent)
			this.location = this.parent.get_position();
		
		this._affectedBodies=[];
		while(i--) {
			curBody=bodies[i];
			if (this.parent && curBody == this.parent) continue;
			
			// handle normal bodies first
			if (curBody._type!="PLANE")
			{
				distance=Vector3DUtil.distance(curBody.get_position(), this.location);
				if (distance < this.radius)
				{
					forceV=Vector3DUtil.subtract(curBody.get_position(), this.location);
					force=(1-(distance / this.radius)) * this.force;
					Vector3DUtil.scaleBy(forceV, force);
					
					if(this.relativity) forceVP = Vector3DUtil.add(forceV,forceVP);
					
					if(curBody.get_movable()) 
					{
						system.activateObject(curBody);
						curBody.addWorldForce(forceV, this.location);
					}
				}
			}
			else if (this.relativity)
			{
				// allow ground and wall type immovable bodies to impart relative force to the exploding body
				distance=curBody.pointPlaneDistance(this.location);
				if (distance<this.radius)
				{
					forceV=Vector3DUtil.negate(curBody.get_normal().slice(0));
					force=(1-(distance / this.radius)) * (this.force*2);
					Vector3DUtil.scaleBy(forceV, force);
					forceVP = Vector3DUtil.add(forceV,forceVP);
				}
			}
		}
		if(this.relativity) {
			Vector3DUtil.limitSum(forceVP,this.force);
			Vector3DUtil.negate(forceVP);
			system.activateObject(this.parent);
			this.parent.applyWorldImpulse(forceVP, this.location);
		}
	};
	
	jigLib.Explosion=Explosion;
})(jigLib);(function(jigLib){
	var Vector3DUtil=jigLib.Vector3DUtil;
	/**
	 * @author Jim Sangwine
	 * 
	 * This effect has a radius within which it will either attract or repel bodies depending on the defined force 
	 * (positive values attract, negative repel) and their distance (the closer the object, the stronger the effect).
	 * 
	 * This effect will be applied continuously as long as this.enabled == true
	 * 
	 * This effect can either be placed at an arbitrary location in the scene, or it can be attached to a parent object.
	 * 
	 * @param {Array}	location	vector array in the format [x,y,z]
	 * @param {Number}	radius		radius of effect - at [radius] distance, gravity effect will be 0
	 * @param {Number}	force		the force of gravity at 0 distance (impulse will be force/distance)
	 * @param {Object}	parent		optional - a RigidBody that the gravitational field will follow - excluded from effect 
	 **/
	var GravityField=function(_location, _radius, _force, _parent) {
		this.Super();
		this.location=_location;
		this.radius=_radius;
		this.force=_force;
		if (_parent) this.parent=_parent;
	};
	jigLib.extend(GravityField,jigLib.JEffect);

	GravityField.prototype.location = null;
	GravityField.prototype.radius = null;
	GravityField.prototype.force = null;
	GravityField.prototype.parent = null;
	
	/**
	 * Applies the effect to the relevant bodies.
	 * Typically called by PhysicsSystem.handleAllEffects. 
	 * 
	 * @returns
	 */
	GravityField.prototype.Apply = function() {
		var system=jigLib.PhysicsSystem.getInstance();
		var bodies=system.get_bodies();
		var i=bodies.length-1;
		var curBody, distance, force, forceV;
		
		if (this.parent)
			this.location = this.parent.get_position();
		
		this._affectedBodies=[];
		do {
			curBody=bodies[i];
			if (!curBody.get_movable() || (this.parent && curBody == this.parent)) continue;

			distance=Vector3DUtil.distance(curBody.get_position(), this.location);
			if (distance < this.radius)
			{
				forceV=Vector3DUtil.subtract(curBody.get_position(), this.location);
				force=(1-(distance / this.radius)) * this.force;
				Vector3DUtil.scaleBy(forceV, force);
				Vector3DUtil.negate(forceV);
				system.activateObject(curBody);
				curBody.applyWorldImpulse(forceV, this.location);
			}
		} while(i--);
	};
	
	jigLib.GravityField=GravityField;
})(jigLib);(function(jigLib){
	var Vector3DUtil=jigLib.Vector3DUtil;
	/**
	 * @author Jim Sangwine
	 * 
	 * This effect has global influence - All objects that are movable in the scene will be affected, apart from those
	 * added to the exclusions array. 
	 * 
	 * This effect will be applied continuously as long as this.enabled == true.
	 * 
	 * This effect accepts a vector to define it's direction of influence.
	 * 
	 * @param {Array}	direction	vector array in the format [x,y,z] defines the force of the effect in each direction
	 * @param {Array}	exclusions	optional - a list of bodies that should be excluded from the effect 
	 **/
	var Wind=function(_direction, _exclusions) {
		this.Super();
		this.direction=_direction;
		if (_exclusions) this.exclusions=_exclusions;
	};
	jigLib.extend(Wind,jigLib.JEffect);

	Wind.prototype.direction = null;
	Wind.prototype.exclusions = [];
	
	/**
	 * Searches exclusions for a given body
	 */
	Wind.prototype.isExcluded = function(body) {
		var i=this.exclusions.length;
		while (i--) { if (this.exclusions[i] == body) return true; }
		return false;
	};
	
	/**
	 * Applies the effect to the relevant bodies.
	 * Typically called by PhysicsSystem.handleAllEffects. 
	 * 
	 * @returns
	 */
	Wind.prototype.Apply = function() {
		var system=jigLib.PhysicsSystem.getInstance();
		var bodies=system.get_bodies();
		var i=bodies.length;
		var curBody;
		
		this._affectedBodies=[];
		while(i--) {
			curBody=bodies[i];
			if (!curBody.get_movable() || this.isExcluded(curBody)) continue;
			system.activateObject(curBody);
			curBody.applyWorldImpulse(this.direction, curBody.get_position());
		}
	};
	
	jigLib.Wind=Wind;
})(jigLib);(function(jigLib){
	
	var Vector3DUtil=jigLib.Vector3DUtil;
	var JMatrix3D=jigLib.JMatrix3D;
	var JNumber3D=jigLib.JNumber3D;
	var ISkin3D=jigLib.ISkin3D;
	var PhysicsState=jigLib.PhysicsState;
	var RigidBody=jigLib.RigidBody;
	var EdgeData=jigLib.EdgeData;
	var SpanData=jigLib.SpanData;

	/**
	 * @author Muzer(muzerly@gmail.com)
	 * @link http://code.google.com/p/jiglibflash
	 */
	
	var JBox=function(skin, width, depth, height){
		//	calling "this.Super" causes recursion in inheritance chains longer than 1
		//this.Super(skin);
		jigLib.RigidBody.call(this);
		
		this._edges=[new EdgeData( 0, 1 ), new EdgeData( 3, 1 ), new EdgeData( 2, 3 ),
					new EdgeData( 2, 0 ), new EdgeData( 4, 5 ), new EdgeData( 5, 7 ),
					new EdgeData( 6, 7 ), new EdgeData( 4, 6 ), new EdgeData( 7, 1 ),
					new EdgeData( 5, 3 ), new EdgeData( 4, 2 ), new EdgeData( 6, 0 )];
		
		this._face=[[6, 7, 1, 0], [5, 4, 2, 3],
					[3, 1, 7, 5], [4, 6, 0, 2],
					[1, 3, 2, 0], [7, 6, 4, 5]];

		this._type = "BOX";

		this._sideLengths = Vector3DUtil.create(width, height, depth, 0);
		this._boundingSphere = 0.5 * Vector3DUtil.get_length(this._sideLengths);
		this.initPoint();
		this.set_mass(1);
		this.updateBoundingBox();
	};
	
	jigLib.extend(JBox,jigLib.RigidBody);
	JBox.prototype._sideLengths=null;
	JBox.prototype._points=null;
	JBox.prototype._edges=null; 
	JBox.prototype._face=null; 

	JBox.prototype.initPoint=function(){
		var halfSide = this.getHalfSideLengths();
		this._points = [];
		this._points[0] = Vector3DUtil.create(halfSide[0], -halfSide[1], halfSide[2], 0);
		this._points[1] = Vector3DUtil.create(halfSide[0], halfSide[1], halfSide[2], 0);
		this._points[2] = Vector3DUtil.create(-halfSide[0], -halfSide[1], halfSide[2], 0);
		this._points[3] = Vector3DUtil.create(-halfSide[0], halfSide[1], halfSide[2], 0);
		this._points[4] = Vector3DUtil.create(-halfSide[0], -halfSide[1], -halfSide[2], 0);
		this._points[5] = Vector3DUtil.create(-halfSide[0], halfSide[1], -halfSide[2], 0);
		this._points[6] = Vector3DUtil.create(halfSide[0], -halfSide[1], -halfSide[2], 0);
		this._points[7] = Vector3DUtil.create(halfSide[0], halfSide[1], -halfSide[2], 0);
	};

	JBox.prototype.set_sideLengths=function(size){
		this._sideLengths = size.slice(0);
		this._boundingSphere = 0.5 * this._sideLengths.length;
		this.initPoint();
		this.setInertia(this.getInertiaProperties(this.get_mass()));
		this.setActive();
		this.updateBoundingBox();
	};

	//Returns the full side lengths
	JBox.prototype.get_sideLengths=function(){
		return this._sideLengths;
	};

	JBox.prototype.get_edges=function(){
		return this._edges;
	};

	JBox.prototype.getVolume=function(){
		return (this._sideLengths[0] * this._sideLengths[1] * this._sideLengths[2]);
	};

	JBox.prototype.getSurfaceArea=function(){
		return 2 * (this._sideLengths[0] * this._sideLengths[1] + this._sideLengths[0] * this._sideLengths[2] + this._sideLengths[1] * this._sideLengths[2]);
	};

	// Returns the half-side lengths
	JBox.prototype.getHalfSideLengths=function(){
		return JNumber3D.getScaleVector(this._sideLengths, 0.5);
	};

	// Gets the minimum and maximum extents of the box along the axis, relative to the centre of the box.
	JBox.prototype.getSpan=function(axis){
		var cols= this.get_currentState().getOrientationCols();
		var obj = new SpanData();
		var s = Math.abs(Vector3DUtil.dotProduct(axis, cols[0])) * (0.5 * this._sideLengths[0]);
		var u = Math.abs(Vector3DUtil.dotProduct(axis, cols[1])) * (0.5 * this._sideLengths[1]);
		var d = Math.abs(Vector3DUtil.dotProduct(axis, cols[2])) * (0.5 * this._sideLengths[2]);
		var r = s + u + d;
		var p = Vector3DUtil.dotProduct(this.get_currentState().position, axis);
		obj.min = p - r;
		obj.max = p + r;

		return obj;
	};

	// Gets the corner points
	JBox.prototype.getCornerPoints=function(state){
		var vertex;
		var arr = [];
						
		var transform = JMatrix3D.getTranslationMatrix(state.position[0], state.position[1], state.position[2]);
		transform = JMatrix3D.getAppendMatrix3D(state.get_orientation(), transform);
						
		for(var i=0, pl=this._points.length; i<pl; i++){
			var _point=this._points[i];
			vertex=Vector3DUtil.create(_point[0], _point[1], _point[2], 0);
			JMatrix3D.multiplyVector(transform, vertex);
			arr.push(vertex);
			//arr.push(transform.transformVector(new Vector3D(_point[0], _point[1], _point[2])));
		}
		//arr.fixed = true;
		return arr;
	};
				
	// Gets the corner points in another box space
         JBox.prototype.getCornerPointsInBoxSpace=function(thisState, boxState){
                        
		var max = JMatrix3D.getTransposeMatrix(boxState.get_orientation());
		var pos = Vector3DUtil.subtract(thisState.position,boxState.position);
		JMatrix3D.multiplyVector(max, pos);
                        
		var orient = JMatrix3D.getAppendMatrix3D(thisState.get_orientation(), max);
                        
		var arr = [];
                        
		var transform = JMatrix3D.getTranslationMatrix(pos[0], pos[1], pos[2]);
		transform = JMatrix3D.getAppendMatrix3D(orient, transform);
                        
		for(var i=0;i<this._points.length;i++){
			_point=this._points[i].slice(0);
			JMatrix3D.multiplyVector(transform,_point);
			arr[i] = _point;
		}
		return arr;
	};
				
	JBox.prototype.getSqDistanceToPoint=function(state, closestBoxPoint, point){
		closestBoxPoint.pos = Vector3DUtil.subtract(point, state.position);
		JMatrix3D.multiplyVector(JMatrix3D.getTransposeMatrix(state.get_orientation()), closestBoxPoint.pos);

		var delta = 0;
		var sqDistance = 0;
		var halfSideLengths = this.getHalfSideLengths();

		if (closestBoxPoint.pos[0] < -halfSideLengths[0]){
			delta = closestBoxPoint.pos[0] + halfSideLengths[0];
			sqDistance += (delta * delta);
			closestBoxPoint.pos[0] = -halfSideLengths[0];
		}else if (closestBoxPoint.pos[0] > halfSideLengths[0]){
			delta = closestBoxPoint.pos[0] - halfSideLengths[0];
			sqDistance += (delta * delta);
			closestBoxPoint.pos[0] = halfSideLengths[0];
		}

		if (closestBoxPoint.pos[1] < -halfSideLengths[1]){
			delta = closestBoxPoint.pos[1] + halfSideLengths[1];
			sqDistance += (delta * delta);
			closestBoxPoint.pos[1] = -halfSideLengths[1];
		}else if (closestBoxPoint.pos[1] > halfSideLengths[1]){
			delta = closestBoxPoint.pos[1] - halfSideLengths[1];
			sqDistance += (delta * delta);
			closestBoxPoint.pos[1] = halfSideLengths[1];
		}

		if (closestBoxPoint.pos[2] < -halfSideLengths[2]){
			delta = closestBoxPoint.pos[2] + halfSideLengths[2];
			sqDistance += (delta * delta);
			closestBoxPoint.pos[2] = -halfSideLengths[2];
		}else if (closestBoxPoint.pos[2] > halfSideLengths[2]){
			delta = (closestBoxPoint.pos[2] - halfSideLengths[2]);
			sqDistance += (delta * delta);
			closestBoxPoint.pos[2] = halfSideLengths[2];
		}
		JMatrix3D.multiplyVector(state.get_orientation(), closestBoxPoint.pos);
		closestBoxPoint.pos = Vector3DUtil.add(state.position, closestBoxPoint.pos);
		return sqDistance;
	};

	// Returns the distance from the point to the box, (-ve if the
	// point is inside the box), and optionally the closest point on the box.
	JBox.prototype.getDistanceToPoint=function(state, closestBoxPoint, point){
		return Math.sqrt(this.getSqDistanceToPoint(state, closestBoxPoint, point));
	};

	JBox.prototype.pointIntersect=function(pos){
		var p = Vector3DUtil.subtract(pos, this.get_currentState().position);
		var h = JNumber3D.getScaleVector(this._sideLengths, 0.5);
		var dirVec;
		var cols = this.get_currentState().getOrientationCols();
		for (var dir; dir < 3; dir++){
			dirVec = cols[dir].slice(0);
			Vector3DUtil.normalize(dirVec);
			if (Math.abs(Vector3DUtil.dotProduct(dirVec, p)) > JNumber3D.toArray(h)[dir] + JNumber3D.NUM_TINY){
				return false;
			}
		}
		return true;
	};

	JBox.prototype.getSupportVertices=function(axis){
		var vertices = [];
		var d = [1,1,1];
		var H;
		var temp = this.get_currentState().getOrientationCols();
		Vector3DUtil.normalize(temp[0]);
		Vector3DUtil.normalize(temp[1]);
		Vector3DUtil.normalize(temp[2]);
		for (var i = 0; i < 3; i++){
			d[i] = Vector3DUtil.dotProduct(axis, temp[i]);
			if (Math.abs(d[i]) > 1 - 0.001){
				var f = (d[i] < 0) ? (i * 2) : (i * 2) + 1;
				for (var j = 0; j < 4; j++){
					H = this._points[this._face[f][j]];
					var _vj = vertices[j] = this.get_currentState().position.slice(0);
					_vj = Vector3DUtil.add(_vj, JNumber3D.getScaleVector(temp[0], H[0]));
					_vj = Vector3DUtil.add(_vj, JNumber3D.getScaleVector(temp[1], H[1]));
					_vj = Vector3DUtil.add(_vj, JNumber3D.getScaleVector(temp[2], H[2]));
				}
				return vertices;
			}
		}

		for (i = 0; i < 3; i++){
			if (Math.abs(d[i]) < 0.005){
				var k;
				var m = (i + 1) % 3;
				var n = (i + 2) % 3;

				H = this.get_currentState().position.slice(0);
				k = (d[m] > 0) ? -1 : 1;
				H = Vector3DUtil.add(H, JNumber3D.getScaleVector(temp[m], k * JNumber3D.toArray(this._sideLengths)[m] / 2));
				k = (d[n] > 0) ? -1 : 1;
				H = Vector3DUtil.add(H, JNumber3D.getScaleVector(temp[n], k * JNumber3D.toArray(this._sideLengths)[n] / 2));

				vertices[0] = Vector3DUtil.add(H, JNumber3D.getScaleVector(temp[i], JNumber3D.toArray(this._sideLengths)[i] / 2));
				vertices[1] = Vector3DUtil.add(H, JNumber3D.getScaleVector(temp[i], -JNumber3D.toArray(this._sideLengths)[i] / 2));
				return vertices;
			}
		}

		var _v0 =vertices[0] = this.get_currentState().position.slice(0);
		k = (d[0] > 0) ? -1 : 1;
		vertices[0] = Vector3DUtil.add(_v0, JNumber3D.getScaleVector(temp[0], k * this._sideLengths[0] / 2));
		k = (d[1] > 0) ? -1 : 1;
		vertices[0] = Vector3DUtil.add(_v0, JNumber3D.getScaleVector(temp[1], k * this._sideLengths[1] / 2));
		k = (d[2] > 0) ? -1 : 1;
		vertices[0] = Vector3DUtil.add(_v0, JNumber3D.getScaleVector(temp[2], k * this._sideLengths[2] / 2));
		return vertices;
	};
	

	JBox.prototype.segmentIntersect=function(out, seg, state){
		out.fracOut = 0;
		out.posOut = [0,0,0,0];
		out.normalOut = [0,0,0,0];

		var frac = JNumber3D.NUM_HUGE;
		var min = -JNumber3D.NUM_HUGE;
		var max = JNumber3D.NUM_HUGE;
		var dirMin = 0;
		var dirMax = 0;
		var dir = 0;
		var p = Vector3DUtil.subtract(state.position, seg.origin);
		var h = JNumber3D.getScaleVector(this._sideLengths, 0.5);

		//var tempV:Vector3D;
		var e;
		var f;
		var t;
		var t1;
		var t2;
						
		var orientationCol = state.getOrientationCols();
		var directionVectorArray = JNumber3D.toArray(h);
		var directionVectorNumber;
		for (dir = 0; dir < 3; dir++){
			directionVectorNumber = directionVectorArray[dir];
			e = Vector3DUtil.dotProduct(orientationCol[dir], p);
			f = Vector3DUtil.dotProduct(orientationCol[dir], seg.delta);
			if (Math.abs(f) > JNumber3D.NUM_TINY){
				t1 = (e + directionVectorNumber) / f;
				t2 = (e - directionVectorNumber) / f;
				if (t1 > t2){
					t = t1;
					t1 = t2;
					t2 = t;
				}
				if (t1 > min){
					min = t1;
					dirMin = dir;
				}
				if (t2 < max){
					max = t2;
					dirMax = dir;
				}
				if (min > max) return false;
				if (max < 0) return false;
			}else if (-e - directionVectorNumber > 0 || -e + directionVectorNumber < 0){
				return false;
			}
		}

		if (min > 0){
			dir = dirMin;
			frac = min;
		}else{
			dir = dirMax;
			frac = max;
		}
		if (frac < 0) frac = 0;
		/*if (frac > 1)
		frac = 1;*/
		if (frac > 1 - JNumber3D.NUM_TINY){
			return false;
		}
		out.fracOut = frac;
		out.posOut = seg.getPoint(frac);

		if (Vector3DUtil.dotProduct(orientationCol[dir], seg.delta) < 0)
			out.normalOut = JNumber3D.getScaleVector(orientationCol[dir], -1);
		else
			out.normalOut = orientationCol[dir];

		return true;
	};

	JBox.prototype.getInertiaProperties=function(m){
		return JMatrix3D.getScaleMatrix(
			(m / 12) * (this._sideLengths[1] * this._sideLengths[1] + this._sideLengths[2] * this._sideLengths[2]),
			(m / 12) * (this._sideLengths[0] * this._sideLengths[0] + this._sideLengths[2] * this._sideLengths[2]),
			(m / 12) * (this._sideLengths[0] * this._sideLengths[0] + this._sideLengths[1] * this._sideLengths[1]));
	};
				
	JBox.prototype.updateBoundingBox=function(){
		this._boundingBox.clear();
		this._boundingBox.addBox(this);
	};
	
	jigLib.JBox=JBox;
	
})(jigLib);	
/*
Copyright (c) 2007 Danny Chapman 
http://www.rowlhouse.co.uk

This software is provided 'as-is', without any express or implied
warranty. In no event will the authors be held liable for any damages
arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it
freely, subject to the following restrictions:
1. The origin of this software must not be misrepresented; you must not
claim that you wrote the original software. If you use this software
in a product, an acknowledgment in the product documentation would be
appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be
misrepresented as being the original software.
3. This notice may not be removed or altered from any source
distribution.
 */

/**
 * @author Muzer(muzerly@gmail.com)
 * @link http://code.google.com/p/jiglibflash
 */
 
(function(jigLib){
	var Vector3DUtil=jigLib.Vector3DUtil;
	var JMatrix3D=jigLib.JMatrix3D;
	var JNumber3D=jigLib.JNumber3D;
	var ISkin3D=jigLib.ISkin3D;
	var PhysicsState=jigLib.PhysicsState;
	var RigidBody=jigLib.RigidBody;
	var JSegment=jigLib.JSegment;
	
	var JCapsule=function(skin, r, l) {
		this.Super(skin);
		this._type = "CAPSULE";
		this._radius = r;
		this._length = l;
		this._boundingSphere = this.getBoundingSphere(r, l);
		this.set_mass(1);
		this.updateBoundingBox();
	};
	jigLib.extend(JCapsule,jigLib.RigidBody);
	
	JCapsule.prototype._length=null;
	JCapsule.prototype._radius=null;
	
	JCapsule.prototype.set_radius=function(r){
		this._radius = r;
		this._boundingSphere = getBoundingSphere(this._radius, this._length);
		this.setInertia(this.getInertiaProperties(this.get_mass()));
		this.updateBoundingBox();
		this.setActive();
	};
	
	JCapsule.prototype.get_radius=function(){
		return this._radius;
	};
				 
	JCapsule.prototype.set_length=function(l){
		this._length = l;
		this._boundingSphere = getBoundingSphere(this._radius, this._length);
		this.setInertia(this.getInertiaProperties(this.get_mass()));
		this.updateBoundingBox();
		this.setActive();
	};
	
	JCapsule.prototype.get_length=function(){
		return this._length;
	};
	
	JCapsule.prototype.getBottomPos=function(state){
		var temp = state.getOrientationCols()[1];
		//Vector3DUtil.normalize(temp);
		return Vector3DUtil.add(state.position, JNumber3D.getScaleVector(temp, -this._length / 2 - this._radius));
	};
				 
	JCapsule.prototype.getEndPos=function(state){
		var temp = state.getOrientationCols()[1];
		//Vector3DUtil.normalize(temp);
		return Vector3DUtil.add(state.position, JNumber3D.getScaleVector(temp, this._length / 2 + this._radius));
	};
				 
	JCapsule.prototype.segmentIntersect=function(out, seg, state){
		out.fracOut = 0;
		out.posOut = [0,0,0,0];
		out.normalOut = [0,0,0,0];
						
		var Ks = seg.delta;
		var kss = Vector3DUtil.dotProduct(Ks, Ks);
		var radiusSq = this._radius * this._radius;
						
		var cols = state.getOrientationCols();
		var cylinderAxis = new JSegment(getBottomPos(state), cols[1]);
		var Ke = cylinderAxis.delta;
		var Kg = Vector3DUtil.subtract(cylinderAxis.origin, seg.origin);
		var kee = Vector3DUtil.dotProduct(Ke, Ke);
		if (Math.abs(kee) < JNumber3D.NUM_TINY) {
			return false;
		}
						
		var kes = Vector3DUtil.dotProduct(Ke, Ks);
		var kgs = Vector3DUtil.dotProduct(Kg, Ks);
		var keg = Vector3DUtil.dotProduct(Ke, Kg);
		var kgg = Vector3DUtil.dotProduct(Kg, Kg);
						
		var distSq = Vector3DUtil.get_lengthSquared(Vector3DUtil.subtract(Kg, JNumber3D.getDivideVector(JNumber3D.getScaleVector(Ke, keg), kee)));
		if (distSq < radiusSq) {
			out.fracOut = 0;
			out.posOut = seg.origin.slice(0);
			out.normalOut = Vector3DUtil.subtract(out.posOut, getBottomPos(state));
			out.normalOut = Vector3DUtil.subtract(out.normalOut, JNumber3D.getScaleVector(cols[1], Vector3DUtil.dotProduct(out.normalOut, cols[1])));
			Vector3DUtil.normalize(out.normalOut);
			return true;
		}
						
		var ar = kee * kss - (kes * kes);
		if (Math.abs(a) < JNumber3D.NUM_TINY) {
			return false;
		}
		var b = 2 * (keg * kes - kee * kgs);
		var c = kee * (kgg - radiusSq) - (keg * keg);
		var blah = (b * b) - 4 * a * c;
		if (blah < 0) {
			return false;
		}
		var t = ( -b - Math.sqrt(blah)) / (2 * a);
		if (t < 0 || t > 1) {
			return false;
		}
		out.fracOut = t;
		out.posOut = seg.getPoint(t);
		out.normalOut = Vector3DUtil.subtract(out.posOut, getBottomPos(state));
		out.normalOut = Vector3DUtil.subtract(out.normalOut, JNumber3D.getScaleVector(cols[1], Vector3DUtil.dotProduct(out.normalOut, cols[1])));
		Vector3DUtil.normalize(out.normalOut);
		return true;
	};

	JCapsule.prototype.getInertiaProperties=function(m){
		var cylinderMass = m * Math.PI * this._radius * this._radius * this._length / this.getVolume();
		var Ixx = 0.25 * cylinderMass * this._radius * this._radius + (1 / 12) * cylinderMass * this._length * this._length;
		var Iyy = 0.5 * cylinderMass * this._radius * this._radius;
		var Izz= Ixx;
						 
		var endMass = m - cylinderMass;
		Ixx += (0.4 * endMass * this._radius * this._radius + endMass * Math.pow(0.5 * this._length, 2));
		Iyy += (0.2 * endMass * this._radius * this._radius);
		Izz += (0.4 * endMass * this._radius * this._radius + endMass * Math.pow(0.5 * this._length, 2));
						
						 /*
						var inertiaTensor:JMatrix3D = new JMatrix3D();
						inertiaTensor.n11 = Ixx;
						inertiaTensor.n22 = Iyy;
						inertiaTensor.n33 = Izz;
						*/
						
		return JMatrix3D.getScaleMatrix(Ixx, Iyy, Izz);
	};
				
	JCapsule.prototype.updateBoundingBox=function(){
		this._boundingBox.clear();
		this._boundingBox.addCapsule(this);
	};
				
	JCapsule.prototype.getBoundingSphere=function(r, l){
		return Math.sqrt(Math.pow(l / 2, 2) + r * r) + r;
	};
				
	JCapsule.prototype.getVolume=function(){
		return (4 / 3) * Math.PI * this._radius * this._radius * this._radius + this._length * Math.PI * this._radius * this._radius;
	};
	
	jigLib.JCapsule=JCapsule;
	
})(jigLib);
/*
   Copyright (c) 2007 Danny Chapman
   http://www.rowlhouse.co.uk

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any damages
   arising from the use of this software.
   Permission is granted to anyone to use this software for any purpose,
   including commercial applications, and to alter it and redistribute it
   freely, subject to the following restrictions:
   1. The origin of this software must not be misrepresented; you must not
   claim that you wrote the original software. If you use this software
   in a product, an acknowledgment in the product documentation would be
   appreciated but is not required.
   2. Altered source versions must be plainly marked as such, and must not be
   misrepresented as being the original software.
   3. This notice may not be removed or altered from any source
   distribution.
 */

/**
 * @author Muzer(muzerly@gmail.com)
 * @link http://code.google.com/p/jiglibflash
 */

(function(jigLib){
	var Vector3DUtil=jigLib.Vector3DUtil;
	var JMatrix3D=jigLib.JMatrix3D;
	var JNumber3D=jigLib.JNumber3D;
	var JConfig=jigLib.JConfig;
	var ISkin3D=jigLib.ISkin3D;
	var PhysicsState=jigLib.PhysicsState;
	var RigidBody=jigLib.RigidBody;
	
	var JPlane=function(skin, initNormal){
		this.Super(skin);
		if (initNormal == undefined) {
			this._initNormal = [0, 0, -1, 0];
			this._normal = this._initNormal.slice(0);
		}else{
			this._initNormal = initNormal.slice(0);
			this._normal = this._initNormal.slice(0);
		}
						
		this._distance = 0;
		this._type = "PLANE";
		this._movable=false;
	};
	jigLib.extend(JPlane,jigLib.RigidBody);
	
	JPlane.prototype._initNormal=null;
	JPlane.prototype._normal=null;
	JPlane.prototype._distance=null;

	JPlane.prototype.get_normal=function(){
		return this._normal;
	};

	JPlane.prototype.get_distance=function(){
		return this._distance;
	};

	JPlane.prototype.pointPlaneDistance=function(pt){
		return Vector3DUtil.dotProduct(this._normal, pt) - this._distance;
	};

	JPlane.prototype.segmentIntersect=function(out, seg, state){
		out.fracOut = 0;
		out.posOut = [0,0,0,0];
		out.normalOut = [0,0,0,0];

		var frac = 0;

		var t;

		var denom = Vector3DUtil.dotProduct(this._normal, seg.delta);
		if (Math.abs(denom) > JNumber3D.NUM_TINY){
			t = -1 * (Vector3DUtil.dotProduct(this._normal, seg.origin) - this._distance) / denom;

			if (t < 0 || t > 1){
				return false;
			}else{
				frac = t;
				out.fracOut = frac;
				out.posOut = seg.getPoint(frac);
				out.normalOut = this._normal.slice(0);
				Vector3DUtil.normalize(out.normalOut);
				return true;
			}
		}else{
			return false;
		}
	};

	JPlane.prototype.updateState=function(){
		this.Super.prototype.updateState.call(this);
		this._normal = this._initNormal.slice(0);
		JMatrix3D.multiplyVector(this._currState._orientation, this._normal);
		//_normal = _currState.orientation.transformVector(new Vector3D(0, 0, -1));
		this._distance = Vector3DUtil.dotProduct(this._currState.position, this._normal);
	};

	jigLib.JPlane=JPlane;

})(jigLib);
/*
   Copyright (c) 2007 Danny Chapman
   http://www.rowlhouse.co.uk

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any damages
   arising from the use of this software.
   Permission is granted to anyone to use this software for any purpose,
   including commercial applications, and to alter it and redistribute it
   freely, subject to the following restrictions:
   1. The origin of this software must not be misrepresented; you must not
   claim that you wrote the original software. If you use this software
   in a product, an acknowledgment in the product documentation would be
   appreciated but is not required.
   2. Altered source versions must be plainly marked as such, and must not be
   misrepresented as being the original software.
   3. This notice may not be removed or altered from any source
   distribution.
 */

/**
 * @author Muzer(muzerly@gmail.com)
 * @link http://code.google.com/p/jiglibflash
 */

(function(jigLib){
	var Vector3DUtil=jigLib.Vector3DUtil;
	var JNumber3D=jigLib.JNumber3D;
	
	var JRay=function(_origin, _dir){
		this.origin = _origin;
		this.dir = _dir;
	};
	JRay.prototype.origin=null;
	JRay.prototype.dir=null;
	
	JRay.prototype.getOrigin=function(t){
		return Vector3DUtil.add(this.origin, JNumber3D.getScaleVector(this.dir, t));
	};
	
	jigLib.JRay=JRay;
	
})(jigLib);
/*
   Copyright (c) 2007 Danny Chapman
   http://www.rowlhouse.co.uk

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any damages
   arising from the use of this software.
   Permission is granted to anyone to use this software for any purpose,
   including commercial applications, and to alter it and redistribute it
   freely, subject to the following restrictions:
   1. The origin of this software must not be misrepresented; you must not
   claim that you wrote the original software. If you use this software
   in a product, an acknowledgment in the product documentation would be
   appreciated but is not required.
   2. Altered source versions must be plainly marked as such, and must not be
   misrepresented as being the original software.
   3. This notice may not be removed or altered from any source
   distribution.
 */

/**
 * @author Muzer(muzerly@gmail.com)
 * @link http://code.google.com/p/jiglibflash
 */
 
 (function(jigLib){
	var Vector3DUtil=jigLib.Vector3DUtil;
	var JNumber3D=jigLib.JNumber3D;
	var PhysicsState=jigLib.PhysicsState;
	var JRay=jigLib.JRay;
	 
	 
	var JSegment=function(_origin, _delta){
		this.origin = _origin;
		this.delta = _delta;
	};
	JSegment.prototype.origin=null;
	JSegment.prototype.delta=null;
	
	JSegment.prototype.getPoint=function(t){
		return Vector3DUtil.add(this.origin, JNumber3D.getScaleVector(this.delta, t));
	};

	JSegment.prototype.getEnd=function(){
		return Vector3DUtil.add(this.origin, this.delta);
	};

	JSegment.prototype.clone=function(){
		return new JSegment(this.origin, this.delta);
	};
	
	JSegment.prototype.segmentSegmentDistanceSq=function(out, seg){
		out.t0 = 0;
		out.t1 = 0;

		var kDiff = Vector3DUtil.subtract(this.origin, seg.origin);
		var fA00 = Vector3DUtil.get_lengthSquared(this.delta);
		var fA01 = -Vector3DUtil.dotProduct(this.delta, seg.delta);
		var fA11 = Vector3DUtil.get_lengthSquared(seg.delta);
		var fB0 = Vector3DUtil.dotProduct(kDiff, this.delta);
		var fC = Vector3DUtil.get_lengthSquared(kDiff);
		var fDet = Math.abs(fA00 * fA11 - fA01 * fA01);
		var fB1;
		var fS;
		var fT;
		var fSqrDist;
		var fTmp;

		if (fDet >= JNumber3D.NUM_TINY){
			fB1 = -Vector3DUtil.dotProduct(kDiff, seg.delta);
			fS = fA01 * fB1 - fA11 * fB0;
			fT = fA01 * fB0 - fA00 * fB1;

			if (fS >= 0){
				if (fS <= fDet){
					if (fT >= 0){
						if (fT <= fDet){
							var fInvDet = 1 / fDet;
							fS *= fInvDet;
							fT *= fInvDet;
							fSqrDist = fS * (fA00 * fS + fA01 * fT + 2 * fB0) + fT * (fA01 * fS + fA11 * fT + 2 * fB1) + fC;
						}else{
							fT = 1;
							fTmp = fA01 + fB0;
							if (fTmp >= 0){
								fS = 0;
								fSqrDist = fA11 + 2 * fB1 + fC;
							}else if (-fTmp >= fA00){
								fS = 1;
								fSqrDist = fA00 + fA11 + fC + 2 * (fB1 + fTmp);
							}else{
								fS = -fTmp / fA00;
								fSqrDist = fTmp * fS + fA11 + 2 * fB1 + fC;
							}
						}
					}else{
						fT = 0;
						if (fB0 >= 0){
							fS = 0;
							fSqrDist = fC;
						}else if (-fB0 >= fA00){
							fS = 1;
							fSqrDist = fA00 + 2 * fB0 + fC;
						}else{
							fS = -fB0 / fA00;
							fSqrDist = fB0 * fS + fC;
						}
					}
				}else{
					if (fT >= 0){
						if (fT <= fDet){
							fS = 1;
							fTmp = fA01 + fB1;
							if (fTmp >= 0){
								fT = 0;
								fSqrDist = fA00 + 2 * fB0 + fC;
							}else if (-fTmp >= fA11){
								fT = 1;
								fSqrDist = fA00 + fA11 + fC + 2 * (fB0 + fTmp);
							}else{
								fT = -fTmp / fA11;
								fSqrDist = fTmp * fT + fA00 + 2 * fB0 + fC;
							}
						}else{
							fTmp = fA01 + fB0;
							if (-fTmp <= fA00){
								fT = 1;
								if (fTmp >= 0){
									fS = 0;
									fSqrDist = fA11 + 2 * fB1 + fC;
								}else{
									fS = -fTmp / fA00;
									fSqrDist = fTmp * fS + fA11 + 2 * fB1 + fC;
								}
							}else{
								fS = 1;
								fTmp = fA01 + fB1;
								if (fTmp >= 0){
									fT = 0;
									fSqrDist = fA00 + 2 * fB0 + fC;
								}else if (-fTmp >= fA11){
									fT = 1;
									fSqrDist = fA00 + fA11 + fC + 2 * (fB0 + fTmp);
								}else{
									fT = -fTmp / fA11;
									fSqrDist = fTmp * fT + fA00 + 2 * fB0 + fC;
								}
							}
						}
					}else{
						if (-fB0 < fA00){
							fT = 0;
							if (fB0 >= 0){
								fS = 0;
								fSqrDist = fC;
							}else{
								fS = -fB0 / fA00;
								fSqrDist = fB0 * fS + fC;
							}
						}else{
							fS = 1;
							fTmp = fA01 + fB1;
							if (fTmp >= 0){
								fT = 0;
								fSqrDist = fA00 + 2 * fB0 + fC;
							}else if (-fTmp >= fA11){
								fT = 1;
								fSqrDist = fA00 + fA11 + fC + 2 * (fB0 + fTmp);
							}else{
								fT = -fTmp / fA11;
								fSqrDist = fTmp * fT + fA00 + 2 * fB0 + fC;
							}
						}
					}
				}
			}else{
				if (fT >= 0){
					if (fT <= fDet){
						fS = 0;
						if (fB1 >= 0){
							fT = 0;
							fSqrDist = fC;
						}else if (-fB1 >= fA11){
							fT = 1;
							fSqrDist = fA11 + 2 * fB1 + fC;
						}else{
							fT = -fB1 / fA11;
							fSqrDist = fB1 * fT + fC;
						}
					}else{
						fTmp = fA01 + fB0;
						if (fTmp < 0){
							fT = 1;
							if (-fTmp >= fA00){
								fS = 1;
								fSqrDist = fA00 + fA11 + fC + 2 * (fB1 + fTmp);
							}else{
								fS = -fTmp / fA00;
								fSqrDist = fTmp * fS + fA11 + 2 * fB1 + fC;
							}
						}else{
							fS = 0;
							if (fB1 >= 0){
								fT = 0;
								fSqrDist = fC;
							}else if (-fB1 >= fA11){
								fT = 1;
								fSqrDist = fA11 + 2 * fB1 + fC;
							}else{
								fT = -fB1 / fA11;
								fSqrDist = fB1 * fT + fC;
							}
						}
					}
				}else{
					if (fB0 < 0){
						fT = 0;
						if (-fB0 >= fA00){
							fS = 1;
							fSqrDist = fA00 + 2 * fB0 + fC;
						}else{
							fS = -fB0 / fA00;
							fSqrDist = fB0 * fS + fC;
						}
					}else{
						fS = 0;
						if (fB1 >= 0){
							fT = 0;
							fSqrDist = fC;
						}else if (-fB1 >= fA11){
							fT = 1;
							fSqrDist = fA11 + 2 * fB1 + fC;
						}else{
							fT = -fB1 / fA11;
							fSqrDist = fB1 * fT + fC;
						}
					}
				}
			}
		}else{
			if (fA01 > 0){
				if (fB0 >= 0){
					fS = 0;
					fT = 0;
					fSqrDist = fC;
				}else if (-fB0 <= fA00){
					fS = -fB0 / fA00;
					fT = 0;
					fSqrDist = fB0 * fS + fC;
				}else{
					fB1 = -Vector3DUtil.dotProduct(kDiff, seg.delta);
					fS = 1;
					fTmp = fA00 + fB0;
					if (-fTmp >= fA01){
						fT = 1;
						fSqrDist = fA00 + fA11 + fC + 2 * (fA01 + fB0 + fB1);
					}else{
						fT = -fTmp / fA01;
						fSqrDist = fA00 + 2 * fB0 + fC + fT * (fA11 * fT + 2 * (fA01 + fB1));
					}
				}
			}else{
				if (-fB0 >= fA00){
					fS = 1;
					fT = 0;
					fSqrDist = fA00 + 2 * fB0 + fC;
				}else if (fB0 <= 0) {
					fS = -fB0 / fA00;
					fT = 0;
					fSqrDist = fB0 * fS + fC;
				}else{
					fB1 = -Vector3DUtil.dotProduct(kDiff, seg.delta);
					fS = 0;
					if (fB0 >= -fA01){
						fT = 1;
						fSqrDist = fA11 + 2 * fB1 + fC;
					}else{
						fT = -fB0 / fA01;
						fSqrDist = fC + fT * (2 * fB1 + fA11 * fT);
					}
				}
			}
		}

		out.t0 = fS;
		out.t1 = fT;
		return Math.abs(fSqrDist);
	};

	JSegment.prototype.pointSegmentDistanceSq=function(out, pt){
		out.t = 0;

		var kDiff = Vector3DUtil.subtract(pt,  this.origin);
		var fT = Vector3DUtil.dotProduct(kDiff, this.delta);

		if (fT <= 0){
			fT = 0;
		}else{
			var fSqrLen = Vector3DUtil.get_lengthSquared(this._delta);
			if (fT >= fSqrLen){
				fT = 1;
				kDiff = Vector3DUtil.subtract(kDiff, this._delta);
			}else{
				fT /= fSqrLen;
				kDiff = Vector3DUtil.subtract(kDiff, JNumber3D.getScaleVector(this._delta, fT));
			}
		}

		out.t = fT;
		return Vector3DUtil.get_lengthSquared(kDiff);
	};

	JSegment.prototype.segmentBoxDistanceSq=function(out, rkBox, boxState){
		out.pfLParam = 0;
		out.pfLParam0 = 0;
		out.pfLParam1 = 0;
		out.pfLParam2 = 0;

		var obj = {};
		var kRay = new JRay(this.origin, this.delta);
		var fSqrDistance = this.sqrDistanceLine(obj, kRay, rkBox, boxState);
		if (obj.num >= 0){
			if (obj.num <= 1){
				out.pfLParam = obj.num;
				out.pfLParam0 = obj.num0;
				out.pfLParam1 = obj.num1;
				out.pfLParam2 = obj.num2;
				return Math.max(fSqrDistance, 0);
			}else{
				fSqrDistance = this.sqrDistancePoint(out, Vector3DUtil.add(this.origin, this.delta), rkBox, boxState);
				out.pfLParam = 1;
				return Math.max(fSqrDistance, 0);
			}
		}else{
			fSqrDistance = this.sqrDistancePoint(out, this.origin, rkBox, boxState);
			out.pfLParam = 0;
			return Math.max(fSqrDistance, 0);
		}
	};

	JSegment.prototype.sqrDistanceLine=function(out, rkLine, rkBox, boxState){
		var orientationCols = boxState.getOrientationCols();
		out.num = 0;
		out.num0 = 0;
		out.num1 = 0;
		out.num2 = 0;

		var kDiff = Vector3DUtil.subtract(rkLine.origin, boxState.position);
		var kPnt = Vector3DUtil.create( Vector3DUtil.dotProduct(kDiff, orientationCols[0]),
										Vector3DUtil.dotProduct(kDiff, orientationCols[1]),
										Vector3DUtil.dotProduct(kDiff, orientationCols[2]), 
										0);

		var kDir = Vector3DUtil.create( Vector3DUtil.dotProduct(rkLine.dir, orientationCols[0]),
										Vector3DUtil.dotProduct(rkLine.dir, orientationCols[1]),
										Vector3DUtil.dotProduct(rkLine.dir, orientationCols[2]), 
							            0);
						
		var kPntArr = JNumber3D.toArray(kPnt);
		var kDirArr = JNumber3D.toArray(kDir);
						
		var bReflect = [1,1,1,0];
		for (var i = 0; i < 3; i++){
			if (kDirArr[i] < 0){
				kPntArr[i] = -kPntArr[i];
				kDirArr[i] = -kDirArr[i];
				bReflect[i] = true;
			}else{
				bReflect[i] = false;
			}
		}

		JNumber3D.copyFromArray(kPnt, kPntArr);
		JNumber3D.copyFromArray(kDir, kDirArr);
						
		var obj = {};
		obj.rkPnt = kPnt.slice(0);
		obj.pfLParam = 0;
		obj.rfSqrDistance = 0;

		if (kDir[0] > 0){
			if (kDir[1] > 0){
				if (kDir[2] > 0){
					this.caseNoZeros(obj, kDir, rkBox);
					out.num = obj.pfLParam;
				}else{
					this.case0(obj, 0, 1, 2, kDir, rkBox);
					out.num = obj.pfLParam;
				}
			}else{
				if (kDir[2] > 0){
					this.case0(obj, 0, 2, 1, kDir, rkBox);
					out.num = obj.pfLParam;
				}else{
					this.case00(obj, 0, 1, 2, kDir, rkBox);
					out.num = obj.pfLParam;
				}
			}
		}else{
			if (kDir[1] > 0){
				if (kDir[2] > 0){
					this.case0(obj, 1, 2, 0, kDir, rkBox);
					out.num = obj.pfLParam;
				}else{
					this.case00(obj, 1, 0, 2, kDir, rkBox);
					out.num = obj.pfLParam;
				}
			}else{
				if (kDir[2] > 0){
					this.case00(obj, 2, 0, 1, kDir, rkBox);
					out.num = obj.pfLParam;
				}else{
					this.case000(obj, rkBox);
					out.num = 0;
				}
			}
		}

		kPntArr = JNumber3D.toArray(obj.rkPnt);
		for (i = 0; i < 3; i++){
			if (bReflect[i]) kPntArr[i] = -kPntArr[i];
		}
		JNumber3D.copyFromArray(obj.rkPnt, kPntArr);

		out.num0 = obj.rkPnt[0];
		out.num1 = obj.rkPnt[1];
		out.num2 = obj.rkPnt[2];

		return Math.max(obj.rfSqrDistance, 0);
	};
	

	JSegment.prototype.sqrDistancePoint=function(out, rkPoint, rkBox, boxState){
		var orientationVector = boxState.getOrientationCols();
		var kDiff = Vector3DUtil.subtract(rkPoint, boxState.position);
		var kClosest = Vector3DUtil.create( Vector3DUtil.dotProduct(kDiff, orientationVector[0]),
							                Vector3DUtil.dotProduct(kDiff, orientationVector[1]),
							                Vector3DUtil.dotProduct(kDiff, orientationVector[2]), 
							                0);

		var fSqrDistance = 0;
		var fDelta;
		var boxHalfSide = rkBox.getHalfSideLengths();

		if (kClosest[0] < -boxHalfSide[0]){
			fDelta = kClosest[0] + boxHalfSide[0];
			fSqrDistance += (fDelta * fDelta);
			kClosest[0] = -boxHalfSide[0];
		}else if (kClosest[0] > boxHalfSide[0]){
			fDelta = kClosest[0] - boxHalfSide[0];
			fSqrDistance += (fDelta * fDelta);
			kClosest[0] = boxHalfSide[0];
		}

		if (kClosest[1] < -boxHalfSide[1]){
			fDelta = kClosest[1] + boxHalfSide[1];
			fSqrDistance += (fDelta * fDelta);
			kClosest[1] = -boxHalfSide[1];
		}else if (kClosest[1] > boxHalfSide[1]){
			fDelta = kClosest[1] - boxHalfSide[1];
			fSqrDistance += (fDelta * fDelta);
			kClosest[1] = boxHalfSide[1];
		}

		if (kClosest[2] < -boxHalfSide[2]){
			fDelta = kClosest[2] + boxHalfSide[2];
			fSqrDistance += (fDelta * fDelta);
			kClosest[2] = -boxHalfSide[2];
		}else if (kClosest[2] > boxHalfSide[2]){
			fDelta = kClosest[2] - boxHalfSide[2];
			fSqrDistance += (fDelta * fDelta);
			kClosest[2] = boxHalfSide[2];
		}

		out.pfLParam0 = kClosest[0];
		out.pfLParam1 = kClosest[1];
		out.pfLParam2 = kClosest[2];

		return Math.max(fSqrDistance, 0);
	};

	JSegment.prototype.face=function(out, i0, i1, i2, rkDir, rkBox, rkPmE){
		var kPpE = [0,0,0,0];
		var fLSqr;
		var fInv;
		var fTmp;
		var fParam;
		var fT;
		var fDelta;

		var boxHalfSide = rkBox.getHalfSideLengths();
		var boxHalfArr = JNumber3D.toArray(boxHalfSide);
		var rkPntArr = JNumber3D.toArray(out.rkPnt);
		var rkDirArr = JNumber3D.toArray(rkDir);
		var kPpEArr = JNumber3D.toArray(kPpE);
		var rkPmEArr = JNumber3D.toArray(rkPmE);

		kPpEArr[i1] = rkPntArr[i1] + boxHalfArr[i1];
		kPpEArr[i2] = rkPntArr[i2] + boxHalfArr[i2];
		JNumber3D.copyFromArray(rkPmE, kPpEArr);

		if (rkDirArr[i0] * kPpEArr[i1] >= rkDirArr[i1] * rkPmEArr[i0]){
			if (rkDirArr[i0] * kPpEArr[i2] >= rkDirArr[i2] * rkPmEArr[i0]){
				rkPntArr[i0] = boxHalfArr[i0];
				fInv = 1 / rkDirArr[i0];
				rkPntArr[i1] -= (rkDirArr[i1] * rkPmEArr[i0] * fInv);
				rkPntArr[i2] -= (rkDirArr[i2] * rkPmEArr[i0] * fInv);
				out.pfLParam = -rkPmEArr[i0] * fInv;
				JNumber3D.copyFromArray(out.rkPnt, rkPntArr);
			}else{
				fLSqr = rkDirArr[i0] * rkDirArr[i0] + rkDirArr[i2] * rkDirArr[i2];
				fTmp = fLSqr * kPpEArr[i1] - rkDirArr[i1] * (rkDirArr[i0] * rkPmEArr[i0] + rkDirArr[i2] * kPpEArr[i2]);
				if (fTmp <= 2 * fLSqr * boxHalfArr[i1]){
					fT = fTmp / fLSqr;
					fLSqr += (rkDirArr[i1] * rkDirArr[i1]);
					fTmp = kPpEArr[i1] - fT;
					fDelta = rkDirArr[i0] * rkPmEArr[i0] + rkDirArr[i1] * fTmp + rkDirArr[i2] * kPpEArr[i2];
					fParam = -fDelta / fLSqr;
					out.rfSqrDistance += (rkPmEArr[i0] * rkPmEArr[i0] + fTmp * fTmp + kPpEArr[i2] * kPpEArr[i2] + fDelta * fParam);

					out.pfLParam = fParam;
					rkPntArr[i0] = boxHalfArr[i0];
					rkPntArr[i1] = fT - boxHalfArr[i1];
					rkPntArr[i2] = -boxHalfArr[i2];
					JNumber3D.copyFromArray(out.rkPnt, rkPntArr);
				}else{
					fLSqr += (rkDirArr[i1] * rkDirArr[i1]);
					fDelta = rkDirArr[i0] * rkPmEArr[i0] + rkDirArr[i1] * rkPmEArr[i1] + rkDirArr[i2] * kPpEArr[i2];
					fParam = -fDelta / fLSqr;
					out.rfSqrDistance += (rkPmEArr[i0] * rkPmEArr[i0] + rkPmEArr[i1] * rkPmEArr[i1] + kPpEArr[i2] * kPpEArr[i2] + fDelta * fParam);

					out.pfLParam = fParam;
					rkPntArr[i0] = boxHalfArr[i0];
					rkPntArr[i1] = boxHalfArr[i1];
					rkPntArr[i2] = -boxHalfArr[i2];
					JNumber3D.copyFromArray(out.rkPnt, rkPntArr);
				}
			}
		}else{
			if (rkDirArr[i0] * kPpEArr[i2] >= rkDirArr[i2] * rkPmEArr[i0])
			{
				fLSqr = rkDirArr[i0] * rkDirArr[i0] + rkDirArr[i1] * rkDirArr[i1];
				fTmp = fLSqr * kPpEArr[i2] - rkDirArr[i2] * (rkDirArr[i0] * rkPmEArr[i0] + rkDirArr[i1] * kPpEArr[i1]);
				if (fTmp <= 2 * fLSqr * boxHalfArr[i2]){
					fT = fTmp / fLSqr;
					fLSqr += (rkDirArr[i2] * rkDirArr[i2]);
					fTmp = kPpEArr[i2] - fT;
					fDelta = rkDirArr[i0] * rkPmEArr[i0] + rkDirArr[i1] * kPpEArr[i1] + rkDirArr[i2] * fTmp;
					fParam = -fDelta / fLSqr;
					out.rfSqrDistance += (rkPmEArr[i0] * rkPmEArr[i0] + kPpEArr[i1] * kPpEArr[i1] + fTmp * fTmp + fDelta * fParam);

					out.pfLParam = fParam;
					rkPntArr[i0] = boxHalfArr[i0];
					rkPntArr[i1] = -boxHalfArr[i1];
					rkPntArr[i2] = fT - boxHalfArr[i2];
					JNumber3D.copyFromArray(out.rkPnt, rkPntArr);
				}else{
					fLSqr += (rkDirArr[i2] * rkDirArr[i2]);
					fDelta = rkDirArr[i0] * rkPmEArr[i0] + rkDirArr[i1] * kPpEArr[i1] + rkDirArr[i2] * rkPmEArr[i2];
					fParam = -fDelta / fLSqr;
					out.rfSqrDistance += (rkPmEArr[i0] * rkPmEArr[i0] + kPpEArr[i1] * kPpEArr[i1] + rkPmEArr[i2] * rkPmEArr[i2] + fDelta * fParam);

					out.pfLParam = fParam;
					rkPntArr[i0] = boxHalfArr[i0];
					rkPntArr[i1] = -boxHalfArr[i1];
					rkPntArr[i2] = boxHalfArr[i2];
					JNumber3D.copyFromArray(out.rkPnt, rkPntArr);
				}
			}else{
				fLSqr = rkDirArr[i0] * rkDirArr[i0] + rkDirArr[i2] * rkDirArr[i2];
				fTmp = fLSqr * kPpEArr[i1] - rkDirArr[i1] * (rkDirArr[i0] * rkPmEArr[i0] + rkDirArr[i2] * kPpEArr[i2]);
				if (fTmp >= 0){
					if (fTmp <= 2 * fLSqr * boxHalfArr[i1]){
						fT = fTmp / fLSqr;
						fLSqr += (rkDirArr[i1] * rkDirArr[i1]);
						fTmp = kPpEArr[i1] - fT;
						fDelta = rkDirArr[i0] * rkPmEArr[i0] + rkDirArr[i1] * fTmp + rkDirArr[i2] * kPpEArr[i2];
						fParam = -fDelta / fLSqr;
						out.rfSqrDistance += (rkPmEArr[i0] * rkPmEArr[i0] + fTmp * fTmp + kPpEArr[i2] * kPpEArr[i2] + fDelta * fParam);

						out.pfLParam = fParam;
						rkPntArr[i0] = boxHalfArr[i0];
						rkPntArr[i1] = fT - boxHalfArr[i1];
						rkPntArr[i2] = -boxHalfArr[i2];
						JNumber3D.copyFromArray(out.rkPnt, rkPntArr);
					}else{
						fLSqr += (rkDirArr[i1] * rkDirArr[i1]);
						fDelta = rkDirArr[i0] * rkPmEArr[i0] + rkDirArr[i1] * rkPmEArr[i1] + rkDirArr[i2] * kPpEArr[i2];
						fParam = -fDelta / fLSqr;
						out.rfSqrDistance += (rkPmEArr[i0] * rkPmEArr[i0] + rkPmEArr[i1] * rkPmEArr[i1] + kPpEArr[i2] * kPpEArr[i2] + fDelta * fParam);

						out.pfLParam = fParam;
						rkPntArr[i0] = boxHalfArr[i0];
						rkPntArr[i1] = boxHalfArr[i1];
						rkPntArr[i2] = -boxHalfArr[i2];
						JNumber3D.copyFromArray(out.rkPnt, rkPntArr);
					}
					return;
				}

				fLSqr = rkDirArr[i0] * rkDirArr[i0] + rkDirArr[i1] * rkDirArr[i1];
				fTmp = fLSqr * kPpEArr[i2] - rkDirArr[i2] * (rkDirArr[i0] * rkPmEArr[i0] + rkDirArr[i1] * kPpEArr[i1]);
				if (fTmp >= 0){
					if (fTmp <= 2 * fLSqr * boxHalfArr[i2]){
						fT = fTmp / fLSqr;
						fLSqr += (rkDirArr[i2] * rkDirArr[i2]);
						fTmp = kPpEArr[i2] - fT;
						fDelta = rkDirArr[i0] * rkPmEArr[i0] + rkDirArr[i1] * kPpEArr[i1] + rkDirArr[i2] * fTmp;
						fParam = -fDelta / fLSqr;
						out.rfSqrDistance += (rkPmEArr[i0] * rkPmEArr[i0] + kPpEArr[i1] * kPpEArr[i1] + fTmp * fTmp + fDelta * fParam);

						out.pfLParam = fParam;
						rkPntArr[i0] = boxHalfArr[i0];
						rkPntArr[i1] = -boxHalfArr[i1];
						rkPntArr[i2] = fT - boxHalfArr[i2];
						JNumber3D.copyFromArray(out.rkPnt, rkPntArr);
					}else{
						fLSqr += (rkDirArr[i2] * rkDirArr[i2]);
						fDelta = rkDirArr[i0] * rkPmEArr[i0] + rkDirArr[i1] * kPpEArr[i1] + rkDirArr[i2] * rkPmEArr[i2];
						fParam = -fDelta / fLSqr;
						out.rfSqrDistance += (rkPmEArr[i0] * rkPmEArr[i0] + kPpEArr[i1] * kPpEArr[i1] + rkPmEArr[i2] * rkPmEArr[i2] + fDelta * fParam);

						out.pfLParam = fParam;
						rkPntArr[i0] = boxHalfArr[i0];
						rkPntArr[i1] = -boxHalfArr[i1];
						rkPntArr[i2] = boxHalfArr[i2];
						JNumber3D.copyFromArray(out.rkPnt, rkPntArr);
					}
					return;
				}

				fLSqr += (rkDirArr[i2] * rkDirArr[i2]);
				fDelta = rkDirArr[i0] * rkPmEArr[i0] + rkDirArr[i1] * kPpEArr[i1] + rkDirArr[i2] * kPpEArr[i2];
				fParam = -fDelta / fLSqr;
				out.rfSqrDistance += (rkPmEArr[i0] * rkPmEArr[i0] + kPpEArr[i1] * kPpEArr[i1] + kPpEArr[i2] * kPpEArr[i2] + fDelta * fParam);

				out.pfLParam = fParam;
				rkPntArr[i0] = boxHalfArr[i0];
				rkPntArr[i1] = -boxHalfArr[i1];
				rkPntArr[i2] = -boxHalfArr[i2];
				JNumber3D.copyFromArray(out.rkPnt, rkPntArr);
			}
		}
	};
	
	JSegment.prototype.caseNoZeros=function(out, rkDir, rkBox){
		var boxHalfSide = rkBox.getHalfSideLengths();
		var kPmE = Vector3DUtil.create(out.rkPnt[0] - boxHalfSide[0], out.rkPnt[1] - boxHalfSide[1], out.rkPnt[2] - boxHalfSide[2], 0);

		var fProdDxPy = rkDir[0] * kPmE[1];
		var fProdDyPx = rkDir[1] * kPmE[0];
		var fProdDzPx;
		var fProdDxPz;
		var fProdDzPy;
		var fProdDyPz;

		if (fProdDyPx >= fProdDxPy){
			fProdDzPx = rkDir[2] * kPmE[0];
			fProdDxPz = rkDir[0] * kPmE[2];
			if (fProdDzPx >= fProdDxPz)
				this.face(out, 0, 1, 2, rkDir, rkBox, kPmE);
			else
				this.face(out, 2, 0, 1, rkDir, rkBox, kPmE);
		}else{
			fProdDzPy = rkDir[2] * kPmE[1];
			fProdDyPz = rkDir[1] * kPmE[2];
			if (fProdDzPy >= fProdDyPz)
				this.face(out, 1, 2, 0, rkDir, rkBox, kPmE);
			else
				this.face(out, 2, 0, 1, rkDir, rkBox, kPmE);
		}
	};

	JSegment.prototype.case0=function(out, i0, i1, i2, rkDir, rkBox){
		var boxHalfSide = rkBox.getHalfSideLengths();
		var boxHalfArr = JNumber3D.toArray(boxHalfSide);
		var rkPntArr = JNumber3D.toArray(out.rkPnt);
		var rkDirArr = JNumber3D.toArray(rkDir);
		var fPmE0 = rkPntArr[i0] - boxHalfArr[i0];
		var fPmE1 = rkPntArr[i1] - boxHalfArr[i1];
		var fProd0 = rkDirArr[i1] * fPmE0;
		var fProd1 = rkDirArr[i0] * fPmE1;
		var fDelta;
		var fInvLSqr;
		var fInv;

		if (fProd0 >= fProd1){
			rkPntArr[i0] = boxHalfArr[i0];

			var fPpE1 = rkPntArr[i1] + boxHalfArr[i1];
			fDelta = fProd0 - rkDirArr[i0] * fPpE1;
			if (fDelta >= 0){
				fInvLSqr = 1 / (rkDirArr[i0] * rkDirArr[i0] + rkDirArr[i1] * rkDirArr[i1]);
				out.rfSqrDistance += (fDelta * fDelta * fInvLSqr);

				rkPntArr[i1] = -boxHalfArr[i1];
				out.pfLParam = -(rkDirArr[i0] * fPmE0 + rkDirArr[i1] * fPpE1) * fInvLSqr;
			}else{
				fInv = 1 / rkDirArr[i0];
				rkPntArr[i1] -= (fProd0 * fInv);
				out.pfLParam = -fPmE0 * fInv;
			}
			JNumber3D.copyFromArray(out.rkPnt, rkPntArr);
		}else{
			rkPntArr[i1] = boxHalfArr[i1];

			var fPpE0 = rkPntArr[i0] + boxHalfArr[i0];
			fDelta = fProd1 - rkDirArr[i1] * fPpE0;
			if (fDelta >= 0){
				fInvLSqr = 1 / (rkDirArr[i0] * rkDirArr[i0] + rkDirArr[i1] * rkDirArr[i1]);
				out.rfSqrDistance += (fDelta * fDelta * fInvLSqr);

				rkPntArr[i0] = -boxHalfArr[i0];
				out.pfLParam = -(rkDirArr[i0] * fPpE0 + rkDirArr[i1] * fPmE1) * fInvLSqr;
			}else{
				fInv = 1 / rkDirArr[i1];
				rkPntArr[i0] -= (fProd1 * fInv);
				out.pfLParam = -fPmE1 * fInv;
			}
			JNumber3D.copyFromArray(out.rkPnt, rkPntArr);
		}

		if (rkPntArr[i2] < -boxHalfArr[i2]){
			fDelta = rkPntArr[i2] + boxHalfArr[i2];
			out.rfSqrDistance += (fDelta * fDelta);
			rkPntArr[i2] = -boxHalfArr[i2];
		}else if (rkPntArr[i2] > boxHalfArr[i2]){
			fDelta = rkPntArr[i2] - boxHalfArr[i2];
			out.rfSqrDistance += (fDelta * fDelta);
			rkPntArr[i2] = boxHalfArr[i2];
		}
		JNumber3D.copyFromArray(out.rkPnt, rkPntArr);
	};

	JSegment.prototype.case00=function(out, i0, i1, i2, rkDir, rkBox){
		var fDelta = 0;
		var boxHalfSide = rkBox.getHalfSideLengths();
		var boxHalfArr = JNumber3D.toArray(boxHalfSide);
		var rkPntArr = JNumber3D.toArray(out.rkPnt);
		var rkDirArr = JNumber3D.toArray(rkDir);
		out.pfLParam = (boxHalfArr[i0] - rkPntArr[i0]) / rkDirArr[i0];

		rkPntArr[i0] = boxHalfArr[i0];

		if (rkPntArr[i1] < -boxHalfArr[i1]){
			fDelta = rkPntArr[i1] + boxHalfArr[i1];
			out.rfSqrDistance += (fDelta * fDelta);
			rkPntArr[i1] = -boxHalfArr[i1];
		}else if (rkPntArr[i1] > boxHalfArr[i1]) {
			fDelta = rkPntArr[i1] - boxHalfArr[i1];
			out.rfSqrDistance += (fDelta * fDelta);
			rkPntArr[i1] = boxHalfArr[i1];
		}

		if (rkPntArr[i2] < -boxHalfArr[i2]){
			fDelta = rkPntArr[i2] + boxHalfArr[i2];
			out.rfSqrDistance += (fDelta * fDelta);
			rkPntArr[i2] = -boxHalfArr[i2];
		}else if (rkPntArr[i2] > boxHalfArr[i2]){
			fDelta = rkPntArr[i2] - boxHalfArr[i2];
			out.rfSqrDistance += (fDelta * fDelta);
			rkPntArr[i2] = boxHalfArr[i2];
		}

		JNumber3D.copyFromArray(out.rkPnt, rkPntArr);
	};

	JSegment.prototype.case000=function(out, rkBox){
		var fDelta = 0;
		var boxHalfSide = rkBox.getHalfSideLengths();

		if (out.rkPnt[0] < -boxHalfSide[0]){
			fDelta = out.rkPnt[0] + boxHalfSide[0];
			out.rfSqrDistance += (fDelta * fDelta);
			out.rkPnt[0] = -boxHalfSide[0];
		}else if (out.rkPnt[0] > boxHalfSide[0]){
			fDelta = out.rkPnt[0] - boxHalfSide[0];
			out.rfSqrDistance += (fDelta * fDelta);
			out.rkPnt[0] = boxHalfSide[0];
		}

		if (out.rkPnt[1] < -boxHalfSide[1]){
			fDelta = out.rkPnt[1] + boxHalfSide[1];
			out.rfSqrDistance += (fDelta * fDelta);
			out.rkPnt[1] = -boxHalfSide[1];
		}else if (out.rkPnt[1] > boxHalfSide[1]){
			fDelta = out.rkPnt[1] - boxHalfSide[1];
			out.rfSqrDistance += (fDelta * fDelta);
			out.rkPnt[1] = boxHalfSide[1];
		}

		if (out.rkPnt[2] < -boxHalfSide[2]){
			fDelta = out.rkPnt[2] + boxHalfSide[2];
			out.rfSqrDistance += (fDelta * fDelta);
			out.rkPnt[2] = -boxHalfSide[2];
		}else if (out.rkPnt[2] > boxHalfSide[2]){
			fDelta = out.rkPnt[2] - boxHalfSide[2];
			out.rfSqrDistance += (fDelta * fDelta);
			out.rkPnt[2] = boxHalfSide[2];
		}
	};
	
	
	jigLib.JSegment=JSegment;
	
 })(jigLib);
/*
   Copyright (c) 2007 Danny Chapman
   http://www.rowlhouse.co.uk

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any damages
   arising from the use of this software.
   Permission is granted to anyone to use this software for any purpose,
   including commercial applications, and to alter it and redistribute it
   freely, subject to the following restrictions:
   1. The origin of this software must not be misrepresented; you must not
   claim that you wrote the original software. If you use this software
   in a product, an acknowledgment in the product documentation would be
   appreciated but is not required.
   2. Altered source versions must be plainly marked as such, and must not be
   misrepresented as being the original software.
   3. This notice may not be removed or altered from any source
   distribution.
 */

/**
 * @author Muzer(muzerly@gmail.com)
 * @link http://code.google.com/p/jiglibflash
 */
 
(function(jigLib){
	var Vector3DUtil=jigLib.Vector3DUtil;
	var JMatrix3D=jigLib.JMatrix3D;
	var JNumber3D=jigLib.JNumber3D;
	var ISkin3D=jigLib.ISkin3D;
	var PhysicsState=jigLib.PhysicsState;
	var RigidBody=jigLib.RigidBody;

	var JSphere=function(skin, r){
		this.Super(skin);
		this._type = "SPHERE";
		this._radius = r;
		this._boundingSphere = this._radius;
		this.set_mass(1);
		this.updateBoundingBox();
	};
	jigLib.extend(JSphere,jigLib.RigidBody);
	JSphere.prototype.name=null;
	JSphere.prototype._radius=null;

	JSphere.prototype.set_radius=function(r){
		this._radius = r;
		this._boundingSphere = this._radius;
		this.setInertia(this.getInertiaProperties(this.get_mass()));
		this.setActive();
		this.updateBoundingBox();
	};

	JSphere.prototype.get_radius=function(){
		return this._radius;
	};

	JSphere.prototype.segmentIntersect=function(out, seg, state){
		out.fracOut = 0;
		out.posOut = [0,0,0,0];
		out.normalOut = [0,0,0,0];

		var frac = 0;
		var r = seg.delta;
		var s = Vector3DUtil.subtract(seg.origin, state.position);

		var radiusSq = this._radius * this._radius;
		var rSq = Vector3DUtil.get_lengthSquared(r);
		if (rSq < radiusSq){
			out.fracOut = 0;
			out.posOut = seg.origin.slice(0);
			out.normalOut = Vector3DUtil.subtract(out.posOut, state.position);
			Vector3DUtil.normalize(out.normalOut);
			return true;
		}

		var sDotr = Vector3DUtil.dotProduct(s, r);
		var sSq = Vector3DUtil.get_lengthSquared(s);
		var sigma = sDotr * sDotr - rSq * (sSq - radiusSq);
		if (sigma < 0){
			return false;
		}
		var sigmaSqrt = Math.sqrt(sigma);
		var lambda1 = (-sDotr - sigmaSqrt) / rSq;
		var lambda2 = (-sDotr + sigmaSqrt) / rSq;
		if (lambda1 > 1 || lambda2 < 0){
			return false;
		}
		frac = Math.max(lambda1, 0);
		out.fracOut = frac;
		out.posOut = seg.getPoint(frac);
		out.normalOut = Vector3DUtil.subtract(out.posOut, state.position);
		Vector3DUtil.normalize(out.normalOut);
		return true;
	};

	JSphere.prototype.getInertiaProperties=function(m){
		var Ixx = 0.4 * m * this._radius * this._radius;
		return JMatrix3D.getScaleMatrix(Ixx, Ixx, Ixx);
	};
				
	JSphere.prototype.updateBoundingBox=function(){
		this._boundingBox.clear();
		this._boundingBox.addSphere(this);
	};
	
	jigLib.JSphere=JSphere;
	
})(jigLib);


(function(jigLib){
	var Vector3DUtil=jigLib.Vector3DUtil;
	var JNumber3D=jigLib.JNumber3D;
	var ISkin3D=jigLib.ISkin3D;
	var PhysicsState=jigLib.PhysicsState;
	var RigidBody=jigLib.RigidBody;
	var ITerrain=jigLib.ITerrain;
	
	/**
	* ...
	* @author Muzer
	*/
	
	var JTerrain=function(tr){
		this.Super(null);
		this._terrain = tr;
		this.set_movable(false);
		this._type = "TERRAIN";
	};
	jigLib.extend(JTerrain,jigLib.RigidBody);
	JTerrain.prototype._terrain=null;
	
	JTerrain.prototype.get_terrainMesh=function(){
		return this._terrain;
	};
				
	JTerrain.prototype.getHeightByIndex=function(i, j){
		i = this.limiteInt(i, 0, _terrain.sw);
		j = this.limiteInt(j, 0, _terrain.sh);
		return _terrain.heights[i][j];
	};
	
	JTerrain.prototype.getHeightAndNormalByPoint=function(point){
		var w = this.limiteInt(point[0], this._terrain.minW, this._terrain.maxW);
		var h = this.limiteInt(point[2], this._terrain.minH, this._terrain.maxH);
						
		var i0 = ((w - _terrain.minW) / this._terrain.dw)|0;
		var j0 = ((h - _terrain.minH) / this._terrain.dh)|0;
		i0 = this.limiteInt(i0, 0, this._terrain.sw);
		j0 = this.limiteInt(j0, 0, this._terrain.sh);
		
		var i1 = i0 + 1;
		var j1 = j0 + 1;
		i1 = this.limiteInt(i1, 0, this._terrain.sw);
		j1 = this.limiteInt(j1, 0, this._terrain.sh);
						
		var iFrac = 1 - (w - (i0 * this._terrain.dw + this._terrain.minW)) / this._terrain.dw;
		var jFrac = (h - (j0 * this._terrain.dh + this._terrain.minH)) / this._terrain.dh;
		iFrac = JNumber3D.getLimiteNumber(iFrac, 0, 1);
		jFrac = JNumber3D.getLimiteNumber(jFrac, 0, 1);
						
		var h00 = this._terrain.heights[i0][j0];
		var h01 = this._terrain.heights[i0][j1];
		var h10 = this._terrain.heights[i1][j0];
		var h11 = this._terrain.heights[i1][j1];
						
		var obj = { };
		obj.height = 0;
		obj.normal = [0,0,0,0];
		var plane;
		if (iFrac < jFrac || i0==i1 || j0 == j1){
			obj.normal = Vector3DUtil.crossProduct( [0, h11 - h10, this._terrain.dh, 0],
													[this._terrain.dw, h11 - h01, 0, 0]);
			Vector3DUtil.normalize(obj.normal);
								
			plane = new PlaneData([(i1 * this._terrain.dw + this._terrain.minW), h11, (j1 * this._terrain.dh + this._terrain.minH), 0], 
								  obj.normal);
			obj.height = plane.pointPlaneDistance(point);
		}else{
			obj.normal = Vector3DUtil.crossProduct( [0, h01 - h00, this._terrain.dh, 0], 
													[this._terrain.dw, h10 - h00, 0, 0]);
			Vector3DUtil.normalize(obj.normal);
								
			plane = new PlaneData([(i0 * this._terrain.dw + this._terrain.minW), h00, (j0 * this._terrain.dh + this._terrain.minH), 0], 
			                      obj.normal);
			obj.height = plane.pointPlaneDistance(point);
		}
		return obj;
	};
				
	JTerrain.prototype.getHeightByPoint=function(point){
		return this.getHeightAndNormalByPoint(point).height;
	};
				
	JTerrain.prototype.getNormalByPoint=function(point){
		return this.getHeightAndNormalByPoint(point).normal;
	};
				
	JTerrain.prototype.getSurfacePosByPoint=function(point){
		return [point[0], this.getHeightAndNormalByPoint(point).height, point[2], 0];
	};
	
	   
	JTerrain.prototype.segmentIntersect=function(out, seg, state){
		out.fracOut = 0;
		out.posOut = [0,0,0,0];
		out.normalOut = [0,0,0,0];
						
		if (seg.delta[1] > -JNumber3D.NUM_TINY) 
			return false;

		var obj1 = this.getHeightAndNormalByPoint(seg.origin);
		if (obj1.height < 0) 
			return false;

		var obj2 = getHeightAndNormalByPoint(seg.getEnd());
		if (obj2.height > 0) 
			return false;

		var depthEnd = -obj2.height;
		var weightStart = 1 / (JNumber3D.NUM_TINY + obj1.height);
		var weightEnd = 1 / (JNumber3D.NUM_TINY + obj2.height);
						
		Vector3DUtil.scaleBy(obj1.normal, weightStart);
		Vector3DUtil.scaleBy(obj2.normal, weightEnd);
		out.normalOut = Vector3DUtil.add(obj1.normal, obj2.normal);
		Vector3DUtil.scaleBy(out.normalOut, 1 / (weightStart + weightEnd));
						
		out.fracOut = obj1.height / (obj1.height + depthEnd + JNumber3D.NUM_TINY);
		out.posOut = seg.getPoint(out.fracOut);
						
		return true;
	};
				
	JTerrain.prototype.limiteInt=function(num,min,max){
		var n = num;
		if (n < min){
			n = min;
		}else if (n > max){
			n = max;
		}
		return n;
	};
	
	jigLib.JTerrain=JTerrain;
	
})(jigLib);/*
   Copyright (c) 2007 Danny Chapman
   http://www.rowlhouse.co.uk

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any damages
   arising from the use of this software.
   Permission is granted to anyone to use this software for any purpose,
   including commercial applications, and to alter it and redistribute it
   freely, subject to the following restrictions:
   1. The origin of this software must not be misrepresented; you must not
   claim that you wrote the original software. If you use this software
   in a product, an acknowledgment in the product documentation would be
   appreciated but is not required.
   2. Altered source versions must be plainly marked as such, and must not be
   misrepresented as being the original software.
   3. This notice may not be removed or altered from any source
   distribution.
 */

/**
 * @author Muzer(muzerly@gmail.com)
 * @link http://code.google.com/p/jiglibflash
 */
 (function(jigLib){
	var CollPointInfo=function(){
		this.accumulatedFrictionImpulse=[0,0,0,0];
	};
	
	CollPointInfo.prototype.initialPenetration=null;
		CollPointInfo.prototype.r0;
		CollPointInfo.prototype.r1;
		CollPointInfo.prototype.position;

		CollPointInfo.prototype.minSeparationVel = 0;
		CollPointInfo.prototype.denominator = 0;

		CollPointInfo.prototype.accumulatedNormalImpulse = 0;
		CollPointInfo.prototype.accumulatedNormalImpulseAux = 0;
		CollPointInfo.prototype.accumulatedFrictionImpulse = null;
	
	jigLib.CollPointInfo=CollPointInfo;
})(jigLib);/*
   Copyright (c) 2007 Danny Chapman
   http://www.rowlhouse.co.uk

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any damages
   arising from the use of this software.
   Permission is granted to anyone to use this software for any purpose,
   including commercial applications, and to alter it and redistribute it
   freely, subject to the following restrictions:
   1. The origin of this software must not be misrepresented; you must not
   claim that you wrote the original software. If you use this software
   in a product, an acknowledgment in the product documentation would be
   appreciated but is not required.
   2. Altered source versions must be plainly marked as such, and must not be
   misrepresented as being the original software.
   3. This notice may not be removed or altered from any source
   distribution.
 */

/**
 * @author Muzer(muzerly@gmail.com)
 * @link http://code.google.com/p/jiglibflash
 */

 (function(jigLib){
	var MaterialProperties=jigLib.MaterialProperties;
	 
	var CollisionInfo=function(){
		this.mat=new MaterialProperties();
		this.pointInfo=[];
	};
	CollisionInfo.prototype.mat=null;
	CollisionInfo.prototype.objInfo=null;
	CollisionInfo.prototype.dirToBody=null;
	CollisionInfo.prototype.pointInfo=null;
	CollisionInfo.prototype.satisfied=null;
	
	jigLib.CollisionInfo=CollisionInfo;
})(jigLib);
/*
   Copyright (c) 2007 Danny Chapman
   http://www.rowlhouse.co.uk

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any damages
   arising from the use of this software.
   Permission is granted to anyone to use this software for any purpose,
   including commercial applications, and to alter it and redistribute it
   freely, subject to the following restrictions:
   1. The origin of this software must not be misrepresented; you must not
   claim that you wrote the original software. If you use this software
   in a product, an acknowledgment in the product documentation would be
   appreciated but is not required.
   2. Altered source versions must be plainly marked as such, and must not be
   misrepresented as being the original software.
   3. This notice may not be removed or altered from any source
   distribution.
 */

/**
 * @author Muzer(muzerly@gmail.com)
 * @link http://code.google.com/p/jiglibflash
 */
 
 (function(jigLib){
	 var CollDetectInfo=function(){
		 
	 };
	 CollDetectInfo.prototype.body0=null;
	 CollDetectInfo.prototype.body1=null;
	 
	 jigLib.CollDetectInfo=CollDetectInfo;
 })(jigLib);/*
   Copyright (c) 2007 Danny Chapman
   http://www.rowlhouse.co.uk

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any damages
   arising from the use of this software.
   Permission is granted to anyone to use this software for any purpose,
   including commercial applications, and to alter it and redistribute it
   freely, subject to the following restrictions:
   1. The origin of this software must not be misrepresented; you must not
   claim that you wrote the original software. If you use this software
   in a product, an acknowledgment in the product documentation would be
   appreciated but is not required.
   2. Altered source versions must be plainly marked as such, and must not be
   misrepresented as being the original software.
   3. This notice may not be removed or altered from any source
   distribution.
 */

/**
 * @author Muzer(muzerly@gmail.com)
 * @link http://code.google.com/p/jiglibflash
 */

(function(jigLib){
	
	var CollDetectFunctor=function(){
	};
	CollDetectFunctor.prototype.name=null;
	CollDetectFunctor.prototype.type0=null;
	CollDetectFunctor.prototype.type1=null;
	
	CollDetectFunctor.prototype.collDetect=function(info,collArr){
	};
	
	jigLib.CollDetectFunctor=CollDetectFunctor;
	
})(jigLib);/*
   Copyright (c) 2007 Danny Chapman
   http://www.rowlhouse.co.uk

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any damages
   arising from the use of this software.
   Permission is granted to anyone to use this software for any purpose,
   including commercial applications, and to alter it and redistribute it
   freely, subject to the following restrictions:
   1. The origin of this software must not be misrepresented; you must not
   claim that you wrote the original software. If you use this software
   in a product, an acknowledgment in the product documentation would be
   appreciated but is not required.
   2. Altered source versions must be plainly marked as such, and must not be
   misrepresented as being the original software.
   3. This notice may not be removed or altered from any source
   distribution.
 */

/**
 * @author Muzer(muzerly@gmail.com)
 * @link http://code.google.com/p/jiglibflash
 */
(function(jigLib){
	var Vector3DUtil=jigLib.Vector3DUtil;
	var JNumber3D=jigLib.JNumber3D;
	var JMatrix3D=jigLib.JMatrix3D;
	var JConstraint=jigLib.JConstraint;
	var JSegment=jigLib.JSegment;
	var JConfig=jigLib.JConfig;
	var JSphere=jigLib.JSphere;
	var MaterialProperties=jigLib.MaterialProperties;
	var PhysicsState=jigLib.PhysicsState;
	var EdgeData=jigLib.EdgeData;
	var SpanData=jigLib.SpanData;
	var CollPointInfo=jigLib.CollPointInfo;
	var CollisionInfo=jigLib.CollisionInfo;
	
	var CollDetectBoxBox=function(){
		this.name = "BoxBox";
		this.type0 = "BOX";
		this.type1 = "BOX";
	};
	
	jigLib.extend(CollDetectBoxBox,jigLib.CollDetectFunctor);
	
	CollDetectBoxBox.prototype.MAX_SUPPORT_VERTS = 10;
	CollDetectBoxBox.prototype.combinationDist=null;
	
	//Returns true if disjoint.  Returns false if intersecting
	CollDetectBoxBox.prototype.disjoint=function(out, axis, box0, box1){
		var obj0 = box0.getSpan(axis);
		var obj1 = box1.getSpan(axis);
		var obj0Min = obj0.min;
		var obj0Max = obj0.max;
		var obj1Min = obj1.min;
		var obj1Max = obj1.max;
		var mmin = Math.min;
		
		if (obj0Min > (obj1Max + JConfig.collToll + JNumber3D.NUM_TINY) || obj1Min > (obj0Max + JConfig.collToll + JNumber3D.NUM_TINY)){
			out.flag = true;
			return true;
		}
		if ((obj0Max > obj1Max) && (obj1Min > obj0Min)){
			out.depth = mmin(obj0Max - obj1Min, obj1Max - obj0Min);
		}else if ((obj1Max > obj0Max) && (obj0Min > obj1Min)){
			out.depth = mmin(obj1Max - obj0Min, obj0Max - obj1Min);
		}else{
			out.depth = (obj0Max < obj1Max) ? obj0Max : obj1Max;
			out.depth -= (obj0Min > obj1Min) ? obj0Min : obj1Min;
		}
		out.flag = false;
		return false;
	};
	
	
	CollDetectBoxBox.prototype.addPoint=function(contactPoints, pt, combinationDistanceSq){
		for(var i=0,cpsl=contactPoints.length;i<cpsl;i++){
			var contactPoint=contactPoints[i];
			if (Vector3DUtil.get_lengthSquared(Vector3DUtil.subtract(contactPoint, pt)) < combinationDistanceSq){
				contactPoint = JNumber3D.getDivideVector(Vector3DUtil.add(contactPoint, pt), 2);
				return false;
			}
		}
		contactPoints.push(pt);
		return true;
	};

				
	CollDetectBoxBox.prototype.getSupportPoint=function(box, axis) {
		var orientationCol = box.get_currentState().getOrientationCols();
		var _as = Vector3DUtil.dotProduct(axis,orientationCol[0]);
		var _au = Vector3DUtil.dotProduct(axis,orientationCol[1]);
		var _ad = Vector3DUtil.dotProduct(axis,orientationCol[2]);
						
		var p = box.get_currentState().position.slice(0);
  
		var sideLengths=box.get_sideLengths();
		
		if (_as < -JNumber3D.NUM_TINY) {
			p = Vector3DUtil.add(p,JNumber3D.getScaleVector(orientationCol[0], 0.5 * sideLengths[0]));
		}else if (_as >= JNumber3D.NUM_TINY) {
			p = Vector3DUtil.subtract(p,JNumber3D.getScaleVector(orientationCol[0], 0.5 * sideLengths[0]));
		}
  
		if (_au < -JNumber3D.NUM_TINY) {
			p = Vector3DUtil.add(p,JNumber3D.getScaleVector(orientationCol[1], 0.5 * sideLengths[1]));
		}else if (_au > JNumber3D.NUM_TINY) {
			p = Vector3DUtil.subtract(p,JNumber3D.getScaleVector(orientationCol[1], 0.5 * sideLengths[1]));
		}
  
		if (_ad < -JNumber3D.NUM_TINY) {
			p = Vector3DUtil.add(p,JNumber3D.getScaleVector(orientationCol[2], 0.5 * sideLengths[2]));
		}else if (_ad > JNumber3D.NUM_TINY) {
			p = Vector3DUtil.subtract(p,JNumber3D.getScaleVector(orientationCol[2], 0.5 * sideLengths[2]));
		}
		return p;
	};

	CollDetectBoxBox.prototype.getAABox2EdgeIntersectionPoints=function(contactPoint, origBoxSides, origBoxState, edgePt0, edgePt1){
		var jDir;
		var kDir;
		var dist0;
		var dist1;
		var frac;
		var num=0;
		var pt;
		var edgeDir = Vector3DUtil.subtract(edgePt1, edgePt0);
				 Vector3DUtil.normalize(edgeDir);
		var ptArr=[];
		var faceOffsets=[];
		var edgePt0Arr = edgePt0;
		var edgePt1Arr = edgePt1;
		var edgeDirArr = edgeDir;
		var sidesArr = JNumber3D.getScaleVector(origBoxSides, 0.5);
		for (var iDir= 2; iDir >= 0; iDir--) {
			if (Math.abs(edgeDirArr[iDir]) < 0.1) {
				continue;
			}
			jDir = (iDir + 1) % 3;
			kDir = (iDir + 2) % 3;
			faceOffsets = [ -sidesArr[iDir], sidesArr[iDir]];
			for (var iFace= 1; iFace >= 0; iFace-- ) {
				dist0 = edgePt0Arr[iDir] - faceOffsets[iFace];
				dist1 = edgePt1Arr[iDir] - faceOffsets[iFace];
				frac = -1;
				if (dist0 * dist1 < -JNumber3D.NUM_TINY) {
					frac = -dist0 / (dist1 - dist0);
				}else if (Math.abs(dist0) < JNumber3D.NUM_TINY) {
					frac = 0;
				}else if (Math.abs(dist1) < JNumber3D.NUM_TINY) {
					frac = 1;
				}
				if (frac >= 0) {
					pt = Vector3DUtil.add(JNumber3D.getScaleVector(edgePt0, 1 - frac),JNumber3D.getScaleVector(edgePt1, frac));
					ptArr = pt;
					if ((ptArr[jDir] > -sidesArr[jDir] - JNumber3D.NUM_TINY) && (ptArr[jDir] < sidesArr[jDir] + JNumber3D.NUM_TINY) && (ptArr[kDir] > -sidesArr[kDir] - JNumber3D.NUM_TINY) && (ptArr[kDir] < sidesArr[kDir] + JNumber3D.NUM_TINY) ) {
						pt=pt.splice(0);
						JMatrix3D.multiplyVector(origBoxState.get_orientation(),pt);
						pt = Vector3DUtil.add(pt,origBoxState.position);
						this.addPoint(contactPoint, pt, combinationDist);
						if (++num == 2) {
							return num;
						}
					}
				}
			}
		}
		return num;
	};
				
	CollDetectBoxBox.prototype.getBox2BoxEdgesIntersectionPoints=function(contactPoint, box0, box1, newState){
		var num = 0;
		var seg;
		var box0State = (newState) ? box0.get_currentState() : box0.get_oldState();
		var box1State= (newState) ? box1.get_currentState() : box1.get_oldState();
		var boxPts = box1.getCornerPointsInBoxSpace(box1State, box0State);
		
		var boxEdges = box1.get_edges();
		var edgePt0;
		var edgePt1;
		for(var i=0;i<boxEdges.length;i++){
		var boxEdge=boxEdges[i];
			edgePt0 = boxPts[boxEdge.ind0];
			edgePt1 = boxPts[boxEdge.ind1];
			num += this.getAABox2EdgeIntersectionPoints(contactPoint, box0.get_sideLengths(), box0State, edgePt0, edgePt1);
			if (num >= 8) {
				return num;
			}
		}
		return num;
	};

		CollDetectBoxBox.prototype.getBoxBoxIntersectionPoints=function(contactPoint, box0, box1, newState){
		this.getBox2BoxEdgesIntersectionPoints(contactPoint, box0, box1, newState);
		this.getBox2BoxEdgesIntersectionPoints(contactPoint, box1, box0, newState);
		return Vector3DUtil.get_length(contactPoint);
	};
				
		CollDetectBoxBox.prototype.collDetect=function(info, collArr){
		var box0 = info.body0;
		var box1 = info.body1;

		if (!box0.hitTestObject3D(box1)) return;

		if (JConfig.aabbDetection && !box0.get_boundingBox().overlapTest(box1.get_boundingBox())) return;

		var numTiny= JNumber3D.NUM_TINY;
		var numHuge= JNumber3D.NUM_HUGE;

		var dirs0Arr = box0.get_currentState().getOrientationCols();
		var dirs1Arr = box1.get_currentState().getOrientationCols();

		// the 15 potential separating axes
		var axes = [dirs0Arr[0], dirs0Arr[1], dirs0Arr[2],
								dirs1Arr[0], dirs1Arr[1], dirs1Arr[2],
								Vector3DUtil.crossProduct(dirs0Arr[0],dirs1Arr[0]),
								Vector3DUtil.crossProduct(dirs0Arr[1],dirs1Arr[0]),
								Vector3DUtil.crossProduct(dirs0Arr[2],dirs1Arr[0]),
								Vector3DUtil.crossProduct(dirs0Arr[0],dirs1Arr[1]),
								Vector3DUtil.crossProduct(dirs0Arr[1],dirs1Arr[1]),
								Vector3DUtil.crossProduct(dirs0Arr[2],dirs1Arr[1]),
								Vector3DUtil.crossProduct(dirs0Arr[0],dirs1Arr[2]),
								Vector3DUtil.crossProduct(dirs0Arr[1],dirs1Arr[2]),
								Vector3DUtil.crossProduct(dirs0Arr[2],dirs1Arr[2])];

		var l2;
		// the overlap depths along each axis
		var overlapDepths = [];
		var i= 0;
		var axesLength = axes.length;

		// see if the boxes are separate along any axis, and if not keep a 
		// record of the depths along each axis
		for (i = 0; i < axesLength; i++){
			var _overlapDepth = overlapDepths[i] = new SpanData();
			_overlapDepth.depth = numHuge;

			l2 = Vector3DUtil.get_lengthSquared(axes[i]);
			if (l2 < numTiny) continue;
								
			var ax = axes[i].slice(0);
			Vector3DUtil.normalize(ax);
			if (this.disjoint(overlapDepths[i], ax, box0, box1)) return;
		}

		// The box overlap, find the separation depth closest to 0.
		var minDepth = numHuge;
		var minAxis = -1;
		axesLength = axes.length;
		for (i = 0; i < axesLength; i++){
			l2 = Vector3DUtil.get_lengthSquared(axes[i]);
			if (l2 < numTiny) continue;

			// If this axis is the minimum, select it
			if (overlapDepths[i].depth < minDepth){
				minDepth = overlapDepths[i].depth;
				minAxis =i;
			}
		}
						
		if (minAxis == -1) return;
						
		// Make sure the axis is facing towards the box0. if not, invert it
		var N= axes[minAxis].splice(0);
		if (Vector3DUtil.dotProduct(Vector3DUtil.subtract(box1.get_currentState().position,box0.get_currentState().position),N) > 0) 
			N = JNumber3D.getScaleVector(N, -1);
						
		var contactPointsFromOld = true;
		var contactPoints = [];
		var box0lengths=box0.get_sideLengths();
		var box1lengths=box1.get_sideLengths();
		combinationDist = 0.05 * Math.min(Math.min(box0lengths[0], box0lengths[1], box0lengths[2]), Math.min(box1lengths[0], box1lengths[1], box1lengths[2]));
		combinationDist += (JConfig.collToll * 3.464);
		combinationDist *= combinationDist;

		if (minDepth > -JNumber3D.NUM_TINY)
			this.getBoxBoxIntersectionPoints(contactPoints, box0, box1, false);
						
		if (contactPoints.length == 0){
			contactPointsFromOld = false;
			this.getBoxBoxIntersectionPoints(contactPoints, box0, box1, true);
		}
						
		var bodyDelta = Vector3DUtil.subtract(Vector3DUtil.subtract(box0.get_currentState().position,box0.get_oldState().position),Vector3DUtil.subtract(box1.get_currentState().position,box1.get_oldState().position));
		var bodyDeltaLen = Vector3DUtil.dotProduct(bodyDelta,N);
		var oldDepth = minDepth + bodyDeltaLen;
						
		var SATPoint = [];
		switch(minAxis){
			//-----------------------------------------------------------------
			// Box0 face, Box1 Corner collision
			//-----------------------------------------------------------------
		case 0:
		case 1:
		case 2:
			//-----------------------------------------------------------------
			// Get the lowest point on the box1 along box1 normal
			//-----------------------------------------------------------------
			SATPoint = this.getSupportPoint(box1, JNumber3D.getScaleVector(N, -1));
			break;
		//-----------------------------------------------------------------
		// We have a Box2 corner/Box1 face collision
		//-----------------------------------------------------------------
		case 3:
		case 4:
		case 5:
			//-----------------------------------------------------------------
			// Find with vertex on the triangle collided
			//-----------------------------------------------------------------
			SATPoint = this.getSupportPoint(box0, N);
			break;
		//-----------------------------------------------------------------
		// We have an edge/edge colliiosn
		//-----------------------------------------------------------------
		case 6:
		case 7:
		case 8:
		case 9:
		case 10:
		case 11:
		case 12:
		case 13:
		case 14:
			//-----------------------------------------------------------------
			// Retrieve which edges collided.
			//-----------------------------------------------------------------
			i = minAxis - 6;
			var ia = (i / 3)|0;
			var ib= i - ia * 3;
			//-----------------------------------------------------------------
			// find two P0, P1 point on both edges. 
			//-----------------------------------------------------------------
			var P0 = this.getSupportPoint(box0, N);
			var P1 = this.getSupportPoint(box1, JNumber3D.getScaleVector(N, -1));
	  
			//-----------------------------------------------------------------
			// Find the edge intersection. 
			//-----------------------------------------------------------------
	 
			//-----------------------------------------------------------------
			// plane along N and F, and passing through PB
			//-----------------------------------------------------------------
			var planeNormal = Vector3DUtil.crossProduct(N,dirs1Arr[ib]);
			var planeD = Vector3DUtil.dotProduct(planeNormal,P1);
	  
			//-----------------------------------------------------------------
			// find the intersection t, where Pintersection = P0 + t*box edge dir
			//-----------------------------------------------------------------
			var div = Vector3DUtil.dotProduct(dirs0Arr[ia],planeNormal);
	  
			//-----------------------------------------------------------------
			// plane and ray colinear, skip the intersection.
			//-----------------------------------------------------------------
			if (Math.abs(div) < JNumber3D.NUM_TINY) return;
	  
			var t = (planeD - Vector3DUtil.dotProduct(P0,planeNormal)) / div;
	  
			//-----------------------------------------------------------------
			// point on edge of box0
			//-----------------------------------------------------------------
			P0 = Vector3DUtil.add(P0,JNumber3D.getScaleVector(dirs0Arr[ia], t));
			SATPoint =Vector3DUtil.add(P0,JNumber3D.getScaleVector(N, 0.5 * minDepth));
			break;
		}

		var collPts;
		if (contactPoints.length > 0){
			collPts = [];

			var minDist = JNumber3D.NUM_HUGE;
			var maxDist = -JNumber3D.NUM_HUGE;
			var dist;
			var depth;
			var depthScale;
			var cpInfo;
			var contactPoint;

			for(var j=0;j<contactPoints.length;j++){
				contactPoint=contactPoints[j];

				dist = Vector3DUtil.get_length(Vector3DUtil.subtract(contactPoint,SATPoint));
						
				if (dist < minDist) minDist = dist;

				if (dist > maxDist) maxDist = dist;
			}

			if (maxDist < minDist + JNumber3D.NUM_TINY) maxDist = minDist + JNumber3D.NUM_TINY;

			i = 0;
							  
			for(var j=0;j<contactPoints.length;j++){
				contactPoint=contactPoints[j];
				dist = Vector3DUtil.get_length(Vector3DUtil.subtract(contactPoint,SATPoint));
				depthScale = (dist - minDist) / (maxDist - minDist);
				depth = (1 - depthScale) * oldDepth;
				cpInfo = new CollPointInfo();
						
				if (contactPointsFromOld) {
					cpInfo.r0 = Vector3DUtil.subtract(contactPoint,box0.get_oldState().position);
					cpInfo.r1 = Vector3DUtil.subtract(contactPoint,box1.get_oldState().position);
				} else {
					cpInfo.r0 = Vector3DUtil.subtract(contactPoint,box0.get_currentState().position);
					cpInfo.r1 = Vector3DUtil.subtract(contactPoint,box1.get_currentState().position);
				}
						
				cpInfo.initialPenetration = depth;
				collPts[i++] = cpInfo;
			}
		}else{
			cpInfo = new CollPointInfo();
			cpInfo.r0 = Vector3DUtil.subtract(SATPoint,box0.get_currentState().position);
			cpInfo.r1 = Vector3DUtil.subtract(SATPoint,box1.get_currentState().position);
			cpInfo.initialPenetration = oldDepth;

			collPts = [];
			collPts[0] = cpInfo;
		}
		var collInfo = new CollisionInfo();
		collInfo.objInfo = info;
		collInfo.dirToBody = N;
		collInfo.pointInfo = collPts;

		var mat = new MaterialProperties();
		mat.set_restitution(Math.sqrt(box0.get_material().get_restitution() * box1.get_material().get_restitution()));
		mat.set_friction(Math.sqrt(box0.get_material().get_friction() * box1.get_material().get_friction()));
		collInfo.mat = mat;
		collArr.push(collInfo);

		info.body0.collisions.push(collInfo);
		info.body1.collisions.push(collInfo);
	};

	jigLib.CollDetectBoxBox=CollDetectBoxBox;
	
})(jigLib);
/*
   Copyright (c) 2007 Danny Chapman
   http://www.rowlhouse.co.uk

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any damages
   arising from the use of this software.
   Permission is granted to anyone to use this software for any purpose,
   including commercial applications, and to alter it and redistribute it
   freely, subject to the following restrictions:
   1. The origin of this software must not be misrepresented; you must not
   claim that you wrote the original software. If you use this software
   in a product, an acknowledgment in the product documentation would be
   appreciated but is not required.
   2. Altered source versions must be plainly marked as such, and must not be
   misrepresented as being the original software.
   3. This notice may not be removed or altered from any source
   distribution.
 */

/**
 * @author Muzer(muzerly@gmail.com)
 * @link http://code.google.com/p/jiglibflash
 */
 
(function(jigLib){
	var Vector3DUtil=jigLib.Vector3DUtil;
	var JNumber3D=jigLib.JNumber3D;
	var JConstraint=jigLib.JConstraint;
	var JConfig=jigLib.JConfig;
	var JPlane=jigLib.JPlane;
	var JSegment=jigLib.JSegment;
	var JBox=jigLib.JBox;
	var MaterialProperties=jigLib.MaterialProperties;
	var RigidBody=jigLib.RigidBody;
	var CollPointInfo=jigLib.CollPointInfo;
	var CollisionInfo=jigLib.CollisionInfo;
	
	var CollDetectBoxPlane=function(){
		this.name = "BoxPlane";
		this.type0 = "BOX";
		this.type1 = "PLANE";
	};
	jigLib.extend(CollDetectBoxPlane,jigLib.CollDetectFunctor);

	CollDetectBoxPlane.prototype.collDetect=function(info, collArr){
		var tempBody;
		if (info.body0.get_type() == "PLANE"){
			tempBody = info.body0;
			info.body0 = info.body1;
			info.body1 = tempBody;
		}

		var box = info.body0;
		var plane = info.body1;

		var centreDist= plane.pointPlaneDistance(box.get_currentState().position);

		if (centreDist > box.get_boundingSphere() + JConfig.collToll)
			return;
		
		var newPts = box.getCornerPoints(box.get_currentState());
		var oldPts = box.getCornerPoints(box.get_oldState());
		var collPts = [];
		var cpInfo;
		var newPt;
		var oldPt;
		var newDepth;
		var oldDepth;
		
		for (var i=0; i<8; i++){
			newPt = newPts[i];
			oldPt = oldPts[i];
			newDepth = -1 * plane.pointPlaneDistance(newPt);
			oldDepth = -1 * plane.pointPlaneDistance(oldPt);
			if (Math.max(newDepth, oldDepth) > -JConfig.collToll){
				cpInfo = new CollPointInfo();
				cpInfo.r0 = Vector3DUtil.subtract(oldPt, box.get_oldState().position);
				cpInfo.r1 = Vector3DUtil.subtract(oldPt, plane.get_oldState().position);
				cpInfo.initialPenetration = oldDepth;
				collPts.push(cpInfo);
			}
		}
		if (collPts.length > 0){
			var collInfo = new CollisionInfo();
			collInfo.objInfo = info;
			collInfo.dirToBody = plane.get_normal();
			collInfo.pointInfo = collPts;

			var mat = new MaterialProperties();
			mat.set_restitution(Math.sqrt(box.get_material().get_restitution() * plane.get_material().get_restitution()));
			mat.set_friction(Math.sqrt(box.get_material().get_friction() * plane.get_material().get_friction()));
			collInfo.mat = mat;
			collArr.push(collInfo);
			info.body0.collisions.push(collInfo);
			info.body1.collisions.push(collInfo);
		}
	};
	
	jigLib.CollDetectBoxPlane=CollDetectBoxPlane;
	
})(jigLib);/*
   Copyright (c) 2007 Danny Chapman
   http://www.rowlhouse.co.uk

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any damages
   arising from the use of this software.
   Permission is granted to anyone to use this software for any purpose,
   including commercial applications, and to alter it and redistribute it
   freely, subject to the following restrictions:
   1. The origin of this software must not be misrepresented; you must not
   claim that you wrote the original software. If you use this software
   in a product, an acknowledgment in the product documentation would be
   appreciated but is not required.
   2. Altered source versions must be plainly marked as such, and must not be
   misrepresented as being the original software.
   3. This notice may not be removed or altered from any source
   distribution.
 */

/**
 * @author Muzer(muzerly@gmail.com)
 * @link http://code.google.com/p/jiglibflash
 */
 
(function(jigLib){
	var Vector3DUtil=jigLib.Vector3DUtil;
	var JNumber3D=jigLib.JNumber3D;
	var JConstraint=jigLib.JConstraint;
	var JConfig=jigLib.JConfig;
	var JTerrain=jigLib.JTerrain;
	var JBox=jigLib.JBox;
	var MaterialProperties=jigLib.MaterialProperties;
	var RigidBody=jigLib.RigidBody;
	
	var CollDetectBoxTerrain=function(){
		this.name = "BoxTerrain";
		this.type0 = "BOX";
		this.type1 = "TERRAIN";
	};
	jigLib.extend(CollDetectBoxTerrain,jigLib.CollDetectFunctor);
	
	CollDetectBoxTerrain.prototype.collDetect=function(info, collArr){
		var tempBody;
		if (info.body0.type == "TERRAIN"){
			tempBody = info.body0;
			info.body0 = info.body1;
			info.body1 = tempBody;
		}
						
		var box = info.body0;
		var terrain = info.body1;
						
		var oldPts = box.getCornerPoints(box.oldState);
		var newPts = box.getCornerPoints(box.currentState);
		var collNormal = [0,0,0,0];
						
		var obj;
		var dist;
		var newPt;
		var oldPt;
						
		var collPts = [];
		var cpInfo;
						
		for (var i = 0; i < 8; i++ ) {
			newPt = newPts[i];
			obj = terrain.getHeightAndNormalByPoint(newPt);
								
			if (obj.height < JConfig.collToll) {
				oldPt = oldPts[i];
				dist = terrain.getHeightByPoint(oldPt);
				collNormal = Vector3DUtil.add(collNormal, obj.normal);
				cpInfo = new CollPointInfo();
				cpInfo.r0 = Vector3DUtil.subtract(oldPt, box.oldState.position);
				cpInfo.r1 = Vector3DUtil.subtract(oldPt, terrain.oldState.position);
				cpInfo.initialPenetration = -dist;
				collPts.push(cpInfo);
			}
		}
						
		if (collPts.length > 0) {
			Vector3DUtil.normalize(collNormal);
			var collInfo = new CollisionInfo();
			collInfo.objInfo = info;
			collInfo.dirToBody = collNormal;
			collInfo.pointInfo = collPts;
			var mat = new MaterialProperties();
			mat.restitution = Math.sqrt(box.material.restitution * terrain.material.restitution);
			mat.friction = Math.sqrt(box.material.friction * terrain.material.friction);
			collInfo.mat = mat;
			collArr.push(collInfo);
			info.body0.collisions.push(collInfo);
			info.body1.collisions.push(collInfo);
		};
	};
	
	jigLib.CollDetectBoxTerrain=CollDetectBoxTerrain;
	
})(jigLib);/*
   Copyright (c) 2007 Danny Chapman
   http://www.rowlhouse.co.uk

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any damages
   arising from the use of this software.
   Permission is granted to anyone to use this software for any purpose,
   including commercial applications, and to alter it and redistribute it
   freely, subject to the following restrictions:
   1. The origin of this software must not be misrepresented; you must not
   claim that you wrote the original software. If you use this software
   in a product, an acknowledgment in the product documentation would be
   appreciated but is not required.
   2. Altered source versions must be plainly marked as such, and must not be
   misrepresented as being the original software.
   3. This notice may not be removed or altered from any source
   distribution.
 */

/**
 * @author Muzer(muzerly@gmail.com)
 * @link http://code.google.com/p/jiglibflash
 */

(function(jigLib){
	var Vector3DUtil=jigLib.Vector3DUtil;
	var JMatrix3D=jigLib.JMatrix3D;
	var JNumber3D=jigLib.JNumber3D;
	var JConstraint=jigLib.JConstraint;
	var JConfig=jigLib.JConfig;
	var JCapsule=jigLib.JCapsule;
	var JSegment=jigLib.JSegment;
	var JBox=jigLib.JBox;
	var MaterialProperties=jigLib.MaterialProperties;
	var RigidBody=jigLib.RigidBody;
	var CollPointInfo=jigLib.CollPointInfo;
	var CollisionInfo=jigLib.CollisionInfo;
	
	var CollDetectCapsuleBox=function(){
		this.name = "CapsuleBox";
		this.type0 = "CAPSULE";
		this.type1 = "BOX";
	};
	jigLib.extend(CollDetectCapsuleBox,jigLib.CollDetectFunctor);

	CollDetectCapsuleBox.prototype.collDetect=function(info, collArr){
		var tempBody;
		if (info.body0.get_type() == "BOX"){
			tempBody = info.body0;
			info.body0 = info.body1;
			info.body1 = tempBody;
		}

		var capsule = info.body0;
		var box = info.body1;

		if (!capsule.hitTestObject3D(box)){
			return;
		}
		if (JConfig.aabbDetection && !capsule.get_boundingBox().overlapTest(box.get_boundingBox())) {
			return;
		}

		var collPts = [];
		var cpInfo;

		var averageNormal = [0,0,0,0];
		var oldSeg = new JSegment(capsule.getEndPos(capsule.get_oldState()), JNumber3D.getScaleVector(capsule.get_oldState().getOrientationCols()[1], -Vector3DUtil.get_length(capsule)));
		var newSeg = new JSegment(capsule.getEndPos(capsule.get_currentState()), JNumber3D.getScaleVector(capsule.get_currentState().getOrientationCols()[1], -Vector3DUtil.get_length(capsule)));
		var radius = capsule.get_radius();

		var oldObj = {};
		var oldDistSq= oldSeg.segmentBoxDistanceSq(oldObj, box, box.get_oldState());
		var newObj = {};
		var newDistSq = newSeg.segmentBoxDistanceSq(newObj, box, box.get_currentState());
		var arr = box.get_oldState().getOrientationCols();

		if (Math.min(oldDistSq, newDistSq) < Math.pow(radius + JConfig.collToll, 2)){
			var segPos = oldSeg.getPoint(Number(oldObj.pfLParam));
			var boxPos = box.get_oldState().position.slice(0);
			boxPos = Vector3DUtil.add(boxPos, JNumber3D.getScaleVector(arr[0], oldObj.pfLParam0));
			boxPos = Vector3DUtil.add(boxPos, JNumber3D.getScaleVector(arr[1], oldObj.pfLParam1));
			boxPos = Vector3DUtil.add(boxPos, JNumber3D.getScaleVector(arr[2], oldObj.pfLParam2));

			var dist = Math.sqrt(oldDistSq);
			var depth = radius - dist;

			var dir;
			if (dist > JNumber3D.NUM_TINY){
				dir = Vector3DUtil.subtract(segPos, boxPos);
				Vector3DUtil.normalize(dir);
			}else if (Vector3DUtil.get_length(Vector3DUtil.subtract(segPos, box.get_oldState().position)) > JNumber3D.NUM_TINY){
				dir = Vector3DUtil.subtract(segPos, box.get_oldState().position);
				Vector3DUtil.normalize(dir);
			}else{
				dir = Vector3DUtil.Y_AXIS;
				JMatrix3D.multiplyVector(JMatrix3D.getRotationMatrix(0, 0, 1, 360 * Math.random()), dir);
			}
			averageNormal = Vector3DUtil.add(averageNormal, dir);

			cpInfo = new CollPointInfo();
			cpInfo.r0 = Vector3DUtil.subtract(boxPos, capsule.get_oldState().position);
			cpInfo.r1 = Vector3DUtil.subtract(boxPos, box.get_oldState().position);
			cpInfo.initialPenetration = depth;
			collPts.push(cpInfo);
		}


		oldSeg = new JSegment(capsule.getBottomPos(capsule.get_oldState()), JNumber3D.getScaleVector(capsule.get_oldState().getOrientationCols()[1], Vector3DUtil.get_length(capsule)));
		newSeg = new JSegment(capsule.getBottomPos(capsule.get_currentState()), JNumber3D.getScaleVector(capsule.get_currentState().getOrientationCols()[1], Vector3DUtil.get_length(capsule)));

		oldObj = {};
		oldDistSq = oldSeg.segmentBoxDistanceSq(oldObj, box, box.get_oldState());
		newObj = {};
		newDistSq = newSeg.segmentBoxDistanceSq(newObj, box, box.get_currentState());

		if (Math.min(oldDistSq, newDistSq) < Math.pow(radius + JConfig.collToll, 2)){
			segPos = oldSeg.getPoint(Number(oldObj.pfLParam));
			boxPos = box.get_oldState().position.slice(0);
			boxPos = Vector3DUtil.add(boxPos, JNumber3D.getScaleVector(arr[0], oldObj.pfLParam0));
			boxPos = Vector3DUtil.add(boxPos, JNumber3D.getScaleVector(arr[1], oldObj.pfLParam1));
			boxPos = Vector3DUtil.add(boxPos, JNumber3D.getScaleVector(arr[2], oldObj.pfLParam2));

			dist = Math.sqrt(oldDistSq);
			depth = radius - dist;

			if (dist > JNumber3D.NUM_TINY){
				dir = Vector3DUtil.subtract(segPos, boxPos);
				Vector3DUtil.normalize(dir);
			}else if (Vector3DUtil.get_length(Vector3DUtil.subtract(segPos, box.get_oldState().position)) > JNumber3D.NUM_TINY){
				dir = Vector3DUtil.subtract(segPos, box.get_oldState().position);
				Vector3DUtil.normalize(dir);
			}else{
				dir = Vector3DUtil.Y_AXIS;
				JMatrix3D.multiplyVector(JMatrix3D.getRotationMatrix(0, 0, 1, 360 * Math.random()), dir);
			}
			averageNormal = Vector3DUtil.add(averageNormal, dir);

			cpInfo = new CollPointInfo();
			cpInfo.r0 = Vector3DUtil.subtract(boxPos, capsule.get_oldState().position);
			cpInfo.r1 = Vector3DUtil.subtract(boxPos, box.get_oldState().position);
			cpInfo.initialPenetration = depth;
			collPts.push(cpInfo);
		}

		if (collPts.length > 0){
			averageNormal.normalize();
			var collInfo = new CollisionInfo();
			collInfo.objInfo = info;
			collInfo.dirToBody = averageNormal;
			collInfo.pointInfo = collPts;

			var mat = new MaterialProperties();
			mat.set_restitution(Math.sqrt(capsule.get_material().get_restitution() * box.get_material().get_restitution()));
			mat.set_friction(Math.sqrt(capsule.get_material().get_friction() * box.get_material().get_friction()));
			collInfo.mat = mat;
			collArr.push(collInfo);

			info.body0.collisions.push(collInfo);
			info.body1.collisions.push(collInfo);
		}
	};
	
	jigLib.CollDetectCapsuleBox=CollDetectCapsuleBox;
	
})(jigLib);
/*
   Copyright (c) 2007 Danny Chapman
   http://www.rowlhouse.co.uk

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any damages
   arising from the use of this software.
   Permission is granted to anyone to use this software for any purpose,
   including commercial applications, and to alter it and redistribute it
   freely, subject to the following restrictions:
   1. The origin of this software must not be misrepresented; you must not
   claim that you wrote the original software. If you use this software
   in a product, an acknowledgment in the product documentation would be
   appreciated but is not required.
   2. Altered source versions must be plainly marked as such, and must not be
   misrepresented as being the original software.
   3. This notice may not be removed or altered from any source
   distribution.
 */

/**
 * @author Muzer(muzerly@gmail.com)
 * @link http://code.google.com/p/jiglibflash
 */
 
(function(jigLib){
	var Vector3DUtil=jigLib.Vector3DUtil;
	var JMatrix3D=jigLib.JMatrix3D;
	var JNumber3D=jigLib.JNumber3D;
	var JConstraint=jigLib.JConstraint;
	var JConfig=jigLib.JConfig;
	var JCapsule=jigLib.JCapsule;
	var JSegment=jigLib.JSegment;
	var MaterialProperties=jigLib.MaterialProperties;
	var RigidBody=jigLib.RigidBody;
	var CollPointInfo=jigLib.CollPointInfo;
	var CollisionInfo=jigLib.CollisionInfo;

		var CollDetectCapsuleCapsule=function(){
		this.name = "CapsuleCapsule";
		this.type0 = "CAPSULE";
		this.type1 = "CAPSULE";
	};
	jigLib.extend(CollDetectCapsuleCapsule,jigLib.CollDetectFunctor);

	CollDetectCapsuleCapsule.prototype.collDetect=function(info, collArr){
		var capsule0 = info.body0;
		var capsule1 = info.body1;

		if (!capsule0.hitTestObject3D(capsule1)) {
			return;
		}
						
		if (JConfig.aabbDetection && !capsule0.get_boundingBox().overlapTest(capsule1.get_boundingBox())) {
			return;
		}

		var collPts = [];
		var cpInfo;

		var averageNormal = [0,0,0,0];
		var oldSeg0= new JSegment(capsule0.getEndPos(capsule0.get_oldState()), JNumber3D.getScaleVector(capsule0.get_oldState().getOrientationCols()[1], -Vector3DUtil.get_length(capsule0)));
		var newSeg0= new JSegment(capsule0.getEndPos(capsule0.get_currentState()), JNumber3D.getScaleVector(capsule0.get_currentState().getOrientationCols()[1], -Vector3DUtil.get_length(capsule0)));
		var oldSeg1= new JSegment(capsule1.getEndPos(capsule1.get_oldState()), JNumber3D.getScaleVector(capsule1.get_oldState().getOrientationCols()[1], -Vector3DUtil.get_length(capsule1)));
		var newSeg1 = new JSegment(capsule1.getEndPos(capsule1.get_currentState()), JNumber3D.getScaleVector(capsule1.get_currentState().getOrientationCols()[1], -Vector3DUtil.get_length(capsule1)));

		var radSum = capsule0.get_radius() + capsule1.get_radius();

		var oldObj = {};
		var oldDistSq = oldSeg0.segmentSegmentDistanceSq(oldObj, oldSeg1);
		var newObj = {};
		var newDistSq = newSeg0.segmentSegmentDistanceSq(oldObj, newSeg1);

		if (Math.min(oldDistSq, newDistSq) < Math.pow(radSum + JConfig.collToll, 2)){
			var pos0 = oldSeg0.getPoint(oldObj.t0);
			var pos1 = oldSeg1.getPoint(oldObj.t1);

			var delta = Vector3DUtil.subtract(pos0, pos1);
			var dist = Math.sqrt(oldDistSq);
			var depth = radSum - dist;

			if (dist > JNumber3D.NUM_TINY){
				delta = JNumber3D.getDivideVector(delta, dist);
			}else{
				delta = Vector3DUtil.Y_AXIS;
				JMatrix3D.multiplyVector(JMatrix3D.getRotationMatrix(0, 0, 1, 360 * Math.random()), delta);
			}

			var worldPos = Vector3DUtil.add(pos1, JNumber3D.getScaleVector(delta, capsule1.get_radius() - 0.5 * depth));
			averageNormal = Vector3DUtil.add(averageNormal, delta);

			cpInfo = new CollPointInfo();
			cpInfo.r0 = Vector3DUtil.subtract(worldPos, capsule0.get_oldState().position);
			cpInfo.r1 = Vector3DUtil.subtract(worldPos, capsule1.get_oldState().position);
			cpInfo.initialPenetration = depth;
			collPts.push(cpInfo);
		}

		oldSeg0 = new JSegment(capsule0.getBottomPos(capsule0.get_oldState()), JNumber3D.getScaleVector(capsule0.get_oldState().getOrientationCols()[1], Vector3DUtil.get_length(capsule0)));
		newSeg0 = new JSegment(capsule0.getBottomPos(capsule0.get_currentState()), JNumber3D.getScaleVector(capsule0.get_currentState().getOrientationCols()[1], Vector3DUtil.get_length(capsule0)));
		oldSeg1 = new JSegment(capsule1.getBottomPos(capsule1.get_oldState()), JNumber3D.getScaleVector(capsule1.get_oldState().getOrientationCols()[1], Vector3DUtil.get_length(capsule1)));
		newSeg1 = new JSegment(capsule1.getBottomPos(capsule1.get_currentState()), JNumber3D.getScaleVector(capsule1.get_currentState().getOrientationCols()[1], Vector3DUtil.get_length(capsule1)));

		oldObj = {};
		oldDistSq = oldSeg0.segmentSegmentDistanceSq(oldObj, oldSeg1);
		newObj = {};
		newDistSq = newSeg0.segmentSegmentDistanceSq(oldObj, newSeg1);

		if (Math.min(oldDistSq, newDistSq) < Math.pow(radSum + JConfig.collToll, 2)){
			pos0 = oldSeg0.getPoint(oldObj.t0);
			pos1 = oldSeg1.getPoint(oldObj.t1);

			delta = Vector3DUtil.subtract(pos0, pos1);
			dist = Math.sqrt(oldDistSq);
			depth = radSum - dist;

			if (dist > JNumber3D.NUM_TINY){
				delta = JNumber3D.getDivideVector(delta, dist);
			}else{
				delta = Vector3DUtil.Y_AXIS;
				JMatrix3D.multiplyVector(JMatrix3D.getRotationMatrix(0, 0, 1, 360 * Math.random()), delta);
			}

			worldPos = Vector3DUtil.add(pos1, JNumber3D.getScaleVector(delta, capsule1.get_radius() - 0.5 * depth));
			averageNormal = Vector3DUtil.add(averageNormal, delta);

			cpInfo = new CollPointInfo();
			cpInfo.r0 = Vector3DUtil.subtract(worldPos, capsule0.get_oldState().position);
			cpInfo.r1 = Vector3DUtil.subtract(worldPos, capsule1.get_oldState().position);
			cpInfo.initialPenetration = depth;
			collPts.push(cpInfo);

		}

		if (collPts.length > 0){
			Vector3DUtil.normalize(averageNormal);
			var collInfo = new CollisionInfo();
			collInfo.objInfo = info;
			collInfo.dirToBody = averageNormal;
			collInfo.pointInfo = collPts;

			var mat = new MaterialProperties();
			mat.set_restitution(Math.sqrt(capsule0.get_material().get_restitution() * capsule1.get_material().get_restitution()));
			mat.set_friction(Math.sqrt(capsule0.get_material().get_friction() * capsule1.get_material().get_friction()));
			collInfo.mat = mat;
			collArr.push(collInfo);

			info.body0.collisions.push(collInfo);
			info.body1.collisions.push(collInfo);
		}
	};
	
	jigLib.CollDetectCapsuleCapsule=CollDetectCapsuleCapsule;
	
})(jigLib);
/*
   Copyright (c) 2007 Danny Chapman
   http://www.rowlhouse.co.uk

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any damages
   arising from the use of this software.
   Permission is granted to anyone to use this software for any purpose,
   including commercial applications, and to alter it and redistribute it
   freely, subject to the following restrictions:
   1. The origin of this software must not be misrepresented; you must not
   claim that you wrote the original software. If you use this software
   in a product, an acknowledgment in the product documentation would be
   appreciated but is not required.
   2. Altered source versions must be plainly marked as such, and must not be
   misrepresented as being the original software.
   3. This notice may not be removed or altered from any source
   distribution.
 */

/**
 * @author Muzer(muzerly@gmail.com)
 * @link http://code.google.com/p/jiglibflash
 */
 
(function(jigLib){
	var Vector3DUtil=jigLib.Vector3DUtil;
	var JNumber3D=jigLib.JNumber3D;
	var JConstraint=jigLib.JConstraint;
	var JConfig=jigLib.JConfig;
	var JCapsule=jigLib.JCapsule;
	var JTerrain=jigLib.JPlane;
	var MaterialProperties=jigLib.MaterialProperties;
	var RigidBody=jigLib.RigidBody;
	var CollPointInfo=jigLib.CollPointInfo;
	var CollisionInfo=jigLib.CollisionInfo;
	
	var CollDetectCapsulePlane=function(){
		this.name = "CapsulePlane";
		this.type0 = "CAPSULE";
		this.type1 = "PLANE";
	};
	jigLib.extend(CollDetectCapsulePlane,jigLib.CollDetectFunctor);
	
	CollDetectCapsulePlane.prototype.collDetect=function(info, collArr){
		var tempBody;
		if (info.body0.get_type() == "PLANE"){
			tempBody = info.body0;
			info.body0 = info.body1;
			info.body1 = tempBody;
		}

		var capsule = info.body0;
		var plane = info.body1;

		var collPts = [];
		var cpInfo;

		var oldPos = capsule.getBottomPos(capsule.get_oldState());
		var oldDist = plane.pointPlaneDistance(oldPos);
		var newPos = capsule.getBottomPos(capsule.get_currentState());
		var newDist = plane.pointPlaneDistance(newPos);

		if (Math.min(oldDist, newDist) < capsule.get_radius() + JConfig.collToll){
			var oldDepth= capsule.get_radius() - oldDist;
			var worldPos= Vector3DUtil.subtract(oldPos, JNumber3D.getScaleVector(plane.get_normal(), capsule.get_radius()));

			cpInfo = new CollPointInfo();
			cpInfo.r0 = Vector3DUtil.subtract(worldPos, capsule.get_oldState().position);
			cpInfo.r1 = Vector3DUtil.subtract(worldPos, plane.get_oldState().position);
			cpInfo.initialPenetration = oldDepth;
			collPts.push(cpInfo);
		}

		oldPos = capsule.getEndPos(capsule.get_oldState());
		newPos = capsule.getEndPos(capsule.get_currentState());
		oldDist = plane.pointPlaneDistance(oldPos);
		newDist = plane.pointPlaneDistance(newPos);
		if (Math.min(oldDist, newDist) < capsule.get_radius() + JConfig.collToll){
			oldDepth = capsule.get_radius() - oldDist;
			worldPos = Vector3DUtil.subtract(oldPos, JNumber3D.getScaleVector(plane.get_normal(), capsule.get_radius()));

			cpInfo = new CollPointInfo();
			cpInfo.r0 = Vector3DUtil.subtract(worldPos, capsule.get_oldState().position);
			cpInfo.r1 = Vector3DUtil.subtract(worldPos, plane.get_oldState().position);
			cpInfo.initialPenetration = oldDepth;
			collPts.push(cpInfo);
		}

		if (collPts.length > 0){
			var collInfo= new CollisionInfo();
			collInfo.objInfo = info;
			collInfo.dirToBody = plane.get_normal();
			collInfo.pointInfo = collPts;

			var mat = new MaterialProperties();
			mat.set_restitution(Math.sqrt(capsule.get_material().get_restitution() * plane.get_material().get_restitution()));
			mat.set_friction(Math.sqrt(capsule.get_material().get_friction() * plane.get_material().get_friction()));
			collInfo.mat = mat;
			collArr.push(collInfo);

			info.body0.collisions.push(collInfo);
			info.body1.collisions.push(collInfo);
		}
	};
	
	jigLib.CollDetectCapsulePlane=CollDetectCapsulePlane;
	
})(jigLib);/*
   Copyright (c) 2007 Danny Chapman
   http://www.rowlhouse.co.uk

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any damages
   arising from the use of this software.
   Permission is granted to anyone to use this software for any purpose,
   including commercial applications, and to alter it and redistribute it
   freely, subject to the following restrictions:
   1. The origin of this software must not be misrepresented; you must not
   claim that you wrote the original software. If you use this software
   in a product, an acknowledgment in the product documentation would be
   appreciated but is not required.
   2. Altered source versions must be plainly marked as such, and must not be
   misrepresented as being the original software.
   3. This notice may not be removed or altered from any source
   distribution.
 */

/**
 * @author Muzer(muzerly@gmail.com)
 * @link http://code.google.com/p/jiglibflash
 */

(function(jigLib){
	var Vector3DUtil=jigLib.Vector3DUtil;
	var JNumber3D=jigLib.JNumber3D;
	var JConstraint=jigLib.JConstraint;
	var JConfig=jigLib.JConfig;
	var JCapsule=jigLib.JCapsule;
	var JTerrain=jigLib.JTerrain;
	var MaterialProperties=jigLib.MaterialProperties;
	var RigidBody=jigLib.RigidBody;
	
	var CollDetectCapsuleTerrain=function(){
		this.name = "BoxTerrain";
		this.type0 = "CAPSULE";
		this.type1 = "TERRAIN";
	};
	jigLib.extend(CollDetectCapsuleTerrain,jigLib.CollDetectFunctor);

	CollDetectCapsuleTerrain.prototype.collDetect=function(info, collArr){
		var tempBody;
		if (info.body0.type == "TERRAIN"){
			tempBody = info.body0;
			info.body0 = info.body1;
			info.body1 = tempBody;
		}
						
		var capsule = info.body0;
		var terrain = info.body1;
						
		var collPts = [];
		var cpInfo;
						
		var averageNormal= [0,0,0,0];
		var pos1 = capsule.getBottomPos(capsule.oldState);
		var pos2 = capsule.getBottomPos(capsule.currentState);
		var obj1= terrain.getHeightAndNormalByPoint(pos1);
		var obj2 = terrain.getHeightAndNormalByPoint(pos2);
		if (Math.min(obj1.height, obj2.height) < JConfig.collToll + capsule.radius) {
			var oldDepth = capsule.radius - obj1.height;
			var worldPos = Vector3DUtil.subtract(pos1, JNumber3D.getScaleVector(obj2.normal, capsule.radius));
			cpInfo = new CollPointInfo();
			cpInfo.r0 = Vector3DUtil.subtract(worldPos, capsule.oldState.position);
			cpInfo.r1 = Vector3DUtil.subtract(worldPos, terrain.oldState.position);
			cpInfo.initialPenetration = oldDepth;
			collPts.push(cpInfo);
			averageNormal = Vector3DUtil.add(averageNormal, obj2.normal);
		}
						
		pos1 = capsule.getEndPos(capsule.oldState);
		pos2 = capsule.getEndPos(capsule.currentState);
		obj1 = terrain.getHeightAndNormalByPoint(pos1);
		obj2 = terrain.getHeightAndNormalByPoint(pos2);
		if (Math.min(obj1.height, obj2.height) < JConfig.collToll + capsule.radius) {
			oldDepth = capsule.radius - obj1.height;
			worldPos = Vector3DUtil.subtract(pos1, JNumber3D.getScaleVector(obj2.normal, capsule.radius));
			cpInfo = new CollPointInfo();
			cpInfo.r0 = Vector3DUtil.subtract(worldPos, capsule.oldState.position);
			cpInfo.r1 = Vector3DUtil.subtract(worldPos, terrain.oldState.position);
			cpInfo.initialPenetration = oldDepth;
			collPts.push(cpInfo);
			averageNormal = Vector3DUtil.add(averageNormal, obj2.normal);
		}
						
		if (collPts.length > 0){
			Vector3DUtil.normalize(averageNormal);
			var collInfo = new CollisionInfo();
			collInfo.objInfo = info;
			collInfo.dirToBody = averageNormal;
			collInfo.pointInfo = collPts;

			var mat = new MaterialProperties();
			mat.restitution = Math.sqrt(capsule.material.restitution * terrain.material.restitution);
			mat.friction = Math.sqrt(capsule.material.friction * terrain.material.friction);
			collInfo.mat = mat;
			collArr.push(collInfo);

			info.body0.collisions.push(collInfo);
			info.body1.collisions.push(collInfo);
		}
	};
	
	jigLib.CollDetectCapsuleTerrain=CollDetectCapsuleTerrain;
	
})(jigLib);/*
Copyright (c) 2007 Danny Chapman 
http://www.rowlhouse.co.uk

This software is provided 'as-is', without any express or implied
warranty. In no event will the authors be held liable for any damages
arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it
freely, subject to the following restrictions:
1. The origin of this software must not be misrepresented; you must not
claim that you wrote the original software. If you use this software
in a product, an acknowledgment in the product documentation would be
appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be
misrepresented as being the original software.
3. This notice may not be removed or altered from any source
distribution.
 */

/**
 * @author Muzer(muzerly@gmail.com)
 * @link http://code.google.com/p/jiglibflash
 */
 
(function(jigLib){
	var Vector3DUtil=jigLib.Vector3DUtil;
	var JNumber3D=jigLib.JNumber3D;
	var JConstraint=jigLib.JConstraint;
	var JConfig=jigLib.JConfig;
	var JSphere=jigLib.JSphere;
	var MaterialProperties=jigLib.MaterialProperties;
	var RigidBody=jigLib.RigidBody;
	var CollPointInfo=jigLib.CollPointInfo;
	var CollisionInfo=jigLib.CollisionInfo;

	var CollDetectSphereBox=function(){
		this.name = "SphereBox";
		this.type0 = "SPHERE";
		this.type1 = "BOX";
	};
	jigLib.extend(CollDetectSphereBox,jigLib.CollDetectFunctor);
	
				
	CollDetectSphereBox.prototype.collDetect=function(info, collArr){
		var tempBody;
		if(info.body0.get_type()=="BOX") {
			tempBody=info.body0;
			info.body0=info.body1;
			info.body1=tempBody;
		}
						
		var sphere = info.body0;
		var box = info.body1;		
		if (!sphere.hitTestObject3D(box)) 
			return;

		if (JConfig.aabbDetection && !sphere.get_boundingBox().overlapTest(box.get_boundingBox())) 
			return;
		
		//var spherePos:Vector3D = sphere.get_oldState().position;
		//var boxPos:Vector3D = box.get_oldState().position;

		var oldBoxPoint={};
		var newBoxPoint={};
						
		var oldDist = box.getDistanceToPoint(box.get_oldState(), oldBoxPoint, sphere.get_oldState().position);
		var newDist = box.getDistanceToPoint(box.get_currentState(), newBoxPoint, sphere.get_currentState().position);
						
		var oldDepth = sphere.get_radius() - oldDist;
		var newDepth = sphere.get_radius() - newDist;
		if (Math.max(oldDepth, newDepth) > -JConfig.collToll) {
			var dir;
			var collPts = [];
			if (oldDist < -JNumber3D.NUM_TINY) {
				dir = Vector3DUtil.subtract(Vector3DUtil.subtract(oldBoxPoint.pos, 
																  sphere.get_oldState().position), 
											oldBoxPoint.pos);
				Vector3DUtil.normalize(dir);
			}else if (oldDist > JNumber3D.NUM_TINY) {
				dir = Vector3DUtil.subtract(sphere.get_oldState().position, oldBoxPoint.pos);
				Vector3DUtil.normalize(dir);
			}else{
				dir = Vector3DUtil.subtract(sphere.get_oldState().position, box.get_oldState().position);
				Vector3DUtil.normalize(dir);
			}
								
			var cpInfo = new CollPointInfo();
			cpInfo.r0 = Vector3DUtil.subtract(oldBoxPoint.pos, sphere.get_oldState().position);
			cpInfo.r1 = Vector3DUtil.subtract(oldBoxPoint.pos, box.get_oldState().position);
			cpInfo.initialPenetration = oldDepth;
			collPts.push(cpInfo);
								
			var collInfo=new CollisionInfo();
			collInfo.objInfo=info;
			collInfo.dirToBody = dir;
			collInfo.pointInfo = collPts;
								
			var mat = new MaterialProperties();
			mat.set_restitution(Math.sqrt(sphere.get_material().get_restitution() * box.get_material().get_restitution()));
			mat.set_friction(Math.sqrt(sphere.get_material().get_friction() * box.get_material().get_friction()));
			collInfo.mat = mat;
			collArr.push(collInfo);
								
			info.body0.collisions.push(collInfo);
			info.body1.collisions.push(collInfo);
		}
	};
	
	jigLib.CollDetectSphereBox=CollDetectSphereBox;
	
})(jigLib);/*
   Copyright (c) 2007 Danny Chapman
   http://www.rowlhouse.co.uk

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any damages
   arising from the use of this software.
   Permission is granted to anyone to use this software for any purpose,
   including commercial applications, and to alter it and redistribute it
   freely, subject to the following restrictions:
   1. The origin of this software must not be misrepresented; you must not
   claim that you wrote the original software. If you use this software
   in a product, an acknowledgment in the product documentation would be
   appreciated but is not required.
   2. Altered source versions must be plainly marked as such, and must not be
   misrepresented as being the original software.
   3. This notice may not be removed or altered from any source
   distribution.
 */

/**
 * @author Muzer(muzerly@gmail.com)
 * @link http://code.google.com/p/jiglibflash
 */
 
(function(jigLib){
	var Vector3DUtil=jigLib.Vector3DUtil;
	var JMatrix3D=jigLib.JMatrix3D;
	var JNumber3D=jigLib.JNumber3D;
	var JConstraint=jigLib.JConstraint;
	var JConfig=jigLib.JConfig;
	var JSphere=jigLib.JSphere;
	var JSegment=jigLib.JSegment;
	var MaterialProperties=jigLib.MaterialProperties;
	var RigidBody=jigLib.RigidBody;
	var CollPointInfo=jigLib.CollPointInfo;
	var CollisionInfo=jigLib.CollisionInfo;
	
	var CollDetectSphereCapsule=function(){
		this.name = "SphereCapsule";
		this.type0 = "SPHERE";
		this.type1 = "CAPSULE";
	};
	jigLib.extend(CollDetectSphereCapsule,jigLib.CollDetectFunctor);
	
	CollDetectSphereCapsule.prototype.collDetect=function(info, collArr){
		var tempBody;
		if (info.body0.get_type() == "CAPSULE"){
			tempBody = info.body0;
			info.body0 = info.body1;
			info.body1 = tempBody;
		}

		var sphere = info.body0;
		var capsule= info.body1;

		if (!sphere.hitTestObject3D(capsule)){
			return;
		}
						
		if (JConfig.aabbDetection && !sphere.get_boundingBox().overlapTest(capsule.get_boundingBox())) {
			return;
		}

		var oldSeg = new JSegment(capsule.getBottomPos(capsule.get_oldState()), JNumber3D.getScaleVector(capsule.get_oldState().getOrientationCols()[1], Vector3DUtil.get_length(capsule) + 2 * capsule.get_radius()));
		var newSeg = new JSegment(capsule.getBottomPos(capsule.get_currentState()), JNumber3D.getScaleVector(capsule.get_currentState().getOrientationCols()[1], Vector3DUtil.get_length(capsule) + 2 * capsule.get_radius()));
		var radSum = sphere.get_radius() + capsule.get_radius();

		var oldObj = {};
		var oldDistSq = oldSeg.pointSegmentDistanceSq(oldObj, sphere.get_oldState().position);
		var newObj = {};
		var newDistSq = newSeg.pointSegmentDistanceSq(newObj, sphere.get_currentState().position);

		if (Math.min(oldDistSq, newDistSq) < Math.pow(radSum + JConfig.collToll, 2)){
			var segPos = oldSeg.getPoint(oldObj.t);
			var delta = Vector3DUtil.subtract(sphere.get_oldState().position, segPos);

			var dist = Math.sqrt(oldDistSq);
			var depth = radSum - dist;

			if (dist > JNumber3D.NUM_TINY){
				delta = JNumber3D.getDivideVector(delta, dist);
			}else{
				delta = Vector3DUtil.Y_AXIS;
				JMatrix3D.multiplyVector(JMatrix3D.getRotationMatrix(0, 0, 1, 360 * Math.random()), delta);
			}

			var worldPos = Vector3DUtil.add(segPos, JNumber3D.getScaleVector(delta, capsule.get_radius() - 0.5 * depth));

			var collPts = [];
			var cpInfo = new CollPointInfo();
			cpInfo.r0 = Vector3DUtil.subtract(worldPos, sphere.get_oldState().position);
			cpInfo.r1 = Vector3DUtil.subtract(worldPos, capsule.get_oldState().position);
			cpInfo.initialPenetration = depth;
			collPts.push(cpInfo);

			var collInfo = new CollisionInfo();
			collInfo.objInfo = info;
			collInfo.dirToBody = delta;
			collInfo.pointInfo = collPts;

			var mat = new MaterialProperties();
			mat.set_restitution(Math.sqrt(sphere.get_material().get_restitution() * capsule.get_material().get_restitution()));
			mat.set_friction(Math.sqrt(sphere.get_material().get_friction() * capsule.get_material().get_friction()));
			collInfo.mat = mat;
			collArr.push(collInfo);

			info.body0.collisions.push(collInfo);
			info.body1.collisions.push(collInfo);
		}
	};
	
	jigLib.CollDetectSphereCapsule=CollDetectSphereCapsule;
	
})(jigLib);
/*
   Copyright (c) 2007 Danny Chapman
   http://www.rowlhouse.co.uk

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any damages
   arising from the use of this software.
   Permission is granted to anyone to use this software for any purpose,
   including commercial applications, and to alter it and redistribute it
   freely, subject to the following restrictions:
   1. The origin of this software must not be misrepresented; you must not
   claim that you wrote the original software. If you use this software
   in a product, an acknowledgment in the product documentation would be
   appreciated but is not required.
   2. Altered source versions must be plainly marked as such, and must not be
   misrepresented as being the original software.
   3. This notice may not be removed or altered from any source
   distribution.
 */

/**
 * @author Muzer(muzerly@gmail.com)
 * @link http://code.google.com/p/jiglibflash
 */
 
 (function(jigLib){
	var Vector3DUtil=jigLib.Vector3DUtil;
	var JNumber3D=jigLib.JNumber3D;
	var JConstraint=jigLib.JConstraint;
	var JConfig=jigLib.JConfig;
	var JSphere=jigLib.JSphere;
	var MaterialProperties=jigLib.MaterialProperties;
	var RigidBody=jigLib.RigidBody;
	var CollPointInfo=jigLib.CollPointInfo;
	var CollisionInfo=jigLib.CollisionInfo;

	 
	var CollDetectSpherePlane=function(){
		this.name = "SpherePlane";
		this.type0 = "SPHERE";
		this.type1 = "PLANE";
	};
	jigLib.extend(CollDetectSpherePlane,jigLib.CollDetectFunctor);
	
	CollDetectSpherePlane.prototype.collDetect=function(info, collArr){
		var tempBody;
		if (info.body0.get_type() == "PLANE"){
			tempBody = info.body0;
			info.body0 = info.body1;
			info.body1 = tempBody;
		}

		var sphere = info.body0;
		var plane = info.body1;
		var oldDist = plane.pointPlaneDistance(sphere.get_oldState().position);
		var newDist = plane.pointPlaneDistance(sphere.get_currentState().position);

		if (Math.min(newDist, oldDist) > sphere.get_boundingSphere() + JConfig.collToll){
			return;
		}
		
		var collPts = [];
		var cpInfo;
		var depth = sphere.get_radius() - oldDist;

		var worldPos = Vector3DUtil.subtract(sphere.get_oldState().position, JNumber3D.getScaleVector(plane.get_normal(), sphere.get_radius()));
		cpInfo = new CollPointInfo();
		cpInfo.r0 = Vector3DUtil.subtract(worldPos, sphere.get_oldState().position);
		cpInfo.r1 = Vector3DUtil.subtract(worldPos, plane.get_oldState().position);
		cpInfo.initialPenetration = depth;
		collPts.push(cpInfo);

		var collInfo = new CollisionInfo();
		collInfo.objInfo = info;
		collInfo.dirToBody = plane.get_normal();
		collInfo.pointInfo = collPts;
		var mat = new MaterialProperties();
		mat.set_restitution(Math.sqrt(sphere.get_material().get_restitution() * plane.get_material().get_restitution()));
		mat.set_friction(Math.sqrt(sphere.get_material().get_friction() * plane.get_material().get_friction()));
		collInfo.mat = mat;
		collArr.push(collInfo);
		info.body0.collisions.push(collInfo);
		info.body1.collisions.push(collInfo);
	};
	
	jigLib.CollDetectSpherePlane=CollDetectSpherePlane;
	 
})(jigLib);/*
   Copyright (c) 2007 Danny Chapman
   http://www.rowlhouse.co.uk

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any damages
   arising from the use of this software.
   Permission is granted to anyone to use this software for any purpose,
   including commercial applications, and to alter it and redistribute it
   freely, subject to the following restrictions:
   1. The origin of this software must not be misrepresented; you must not
   claim that you wrote the original software. If you use this software
   in a product, an acknowledgment in the product documentation would be
   appreciated but is not required.
   2. Altered source versions must be plainly marked as such, and must not be
   misrepresented as being the original software.
   3. This notice may not be removed or altered from any source
   distribution.
 */

/**
 * @author Muzer(muzerly@gmail.com)
 * @link http://code.google.com/p/jiglibflash
 */
(function(jigLib){
	var Vector3DUtil=jigLib.Vector3DUtil;
	var JMatrix3D=jigLib.JMatrix3D;
	var JNumber3D=jigLib.JNumber3D;
	var JConstraint=jigLib.JConstraint;
	var JConfig=jigLib.JConfig;
	var JSphere=jigLib.JSphere;	var MaterialProperties=jigLib.MaterialProperties;	var CollPointInfo=jigLib.CollPointInfo;	var CollisionInfo=jigLib.CollisionInfo;
	 
	var CollDetectSphereSphere=function(){
		this.name = "SphereSphere";
		this.type0 = "SPHERE";
		this.type1 = "SPHERE";
	};
	jigLib.extend(CollDetectSphereSphere,jigLib.CollDetectFunctor);
	
	CollDetectSphereSphere.prototype.collDetect=function(info, collArr){
		var sphere0 = info.body0;
		var sphere1 = info.body1;
		var oldDelta = Vector3DUtil.subtract(sphere0.get_oldState().position, sphere1.get_oldState().position);
		var newDelta = Vector3DUtil.subtract(sphere0.get_currentState().position, sphere1.get_currentState().position);

		var oldDistSq = Vector3DUtil.get_lengthSquared(oldDelta);
		var newDistSq = Vector3DUtil.get_lengthSquared(newDelta);
		var radSum = sphere0.get_radius() + sphere1.get_radius();

		if (Math.min(oldDistSq, newDistSq) < Math.pow(radSum + JConfig.collToll, 2)){
			var oldDist = Math.sqrt(oldDistSq);
			var depth = radSum - oldDist;
			if (oldDist > JNumber3D.NUM_TINY){
				oldDelta = JNumber3D.getDivideVector(oldDelta, oldDist);
			}else{
				oldDelta = Vector3DUtil.Y_AXIS;
				JMatrix3D.multiplyVector(JMatrix3D.getRotationMatrix(0, 0, 1, 360 * Math.random()), oldDelta);
			}

			var worldPos = Vector3DUtil.add(sphere1.get_oldState().position, JNumber3D.getScaleVector(oldDelta, sphere1.get_radius() - 0.5 * depth));

			var collPts = [];
			var cpInfo = new CollPointInfo();
			cpInfo.r0 = Vector3DUtil.subtract(worldPos, sphere0.get_oldState().position);
			cpInfo.r1 = Vector3DUtil.subtract(worldPos, sphere1.get_oldState().position);
			cpInfo.initialPenetration = depth;
			collPts.push(cpInfo);

			var collInfo = new CollisionInfo();
			collInfo.objInfo = info;
			collInfo.dirToBody = oldDelta;
			collInfo.pointInfo = collPts;

			var mat = new MaterialProperties();
			mat.set_restitution(Math.sqrt(sphere0.get_material().get_restitution() * sphere1.get_material().get_restitution()));
			mat.set_friction(Math.sqrt(sphere0.get_material().get_friction() * sphere1.get_material().get_friction()));
			collInfo.mat = mat;
			collArr.push(collInfo);

			info.body0.collisions.push(collInfo);
			info.body1.collisions.push(collInfo);
		}
	};
	
	jigLib.CollDetectSphereSphere=CollDetectSphereSphere;
	
})(jigLib);/*
   Copyright (c) 2007 Danny Chapman
   http://www.rowlhouse.co.uk

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any damages
   arising from the use of this software.
   Permission is granted to anyone to use this software for any purpose,
   including commercial applications, and to alter it and redistribute it
   freely, subject to the following restrictions:
   1. The origin of this software must not be misrepresented; you must not
   claim that you wrote the original software. If you use this software
   in a product, an acknowledgment in the product documentation would be
   appreciated but is not required.
   2. Altered source versions must be plainly marked as such, and must not be
   misrepresented as being the original software.
   3. This notice may not be removed or altered from any source
   distribution.
 */

/**
 * @author Muzer(muzerly@gmail.com)
 * @link http://code.google.com/p/jiglibflash
 */

(function(jigLib){
	var Vector3DUtil=jigLib.Vector3DUtil;
	var JNumber3D=jigLib.JNumber3D;
	var JConstraint=jigLib.JConstraint;
	var JConfig=jigLib.JConfig;
	var JSphere=jigLib.JSphere;
	var JTerrain=jigLib.JTerrain;
	var MaterialProperties=jigLib.MaterialProperties;
	var RigidBody=jigLib.RigidBody;
	
	var CollDetectSphereTerrain=function(){ 
		this.name = "SphereTerrain";
		this.type0 = "SPHERE";
		this.type1 = "TERRAIN";
	};
	jigLib.extend(CollDetectSphereTerrain,jigLib.CollDetectFunctor);
	CollDetectSphereTerrain.prototype.collDetect=function(info, collArr){
		var tempBody;
		if (info.body0.type == "TERRAIN"){
			tempBody = info.body0;
			info.body0 = info.body1;
			info.body1 = tempBody;
		}

		var sphere = info.body0;
		var terrain = info.body1;
						
		var obj = terrain.getHeightAndNormalByPoint(sphere.currentState.position);
		if (obj.height < JConfig.collToll + sphere.radius) {
			var dist = terrain.getHeightByPoint(sphere.oldState.position);
			var depth = sphere.radius - dist;
								
			var Pt = Vector3DUtil.subtract(sphere.oldState.position, JNumber3D.getScaleVector(obj.normal, sphere.radius));
								
			var collPts = [];
			var cpInfo = new CollPointInfo();
			cpInfo.r0 = Vector3DUtil.subtract(Pt, sphere.oldState.position);
			cpInfo.r1 = Vector3DUtil.subtract(Pt, terrain.oldState.position);
			cpInfo.initialPenetration = depth;
			collPts.push(cpInfo);
								
			var collInfo = new CollisionInfo();
			collInfo.objInfo = info;
			collInfo.dirToBody = obj.normal;
			collInfo.pointInfo = collPts;
			var mat = new MaterialProperties();
			mat.restitution = Math.sqrt(sphere.material.restitution * terrain.material.restitution);
			mat.friction = Math.sqrt(sphere.material.friction * terrain.material.friction);
			collInfo.mat = mat;
			collArr.push(collInfo);
			info.body0.collisions.push(collInfo);
			info.body1.collisions.push(collInfo);
		}
	};
	jigLib.CollDetectSphereTerrain=CollDetectSphereTerrain;
})(jigLib);/*
   Copyright (c) 2007 Danny Chapman
   http://www.rowlhouse.co.uk

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any damages
   arising from the use of this software.
   Permission is granted to anyone to use this software for any purpose,
   including commercial applications, and to alter it and redistribute it
   freely, subject to the following restrictions:
   1. The origin of this software must not be misrepresented; you must not
   claim that you wrote the original software. If you use this software
   in a product, an acknowledgment in the product documentation would be
   appreciated but is not required.
   2. Altered source versions must be plainly marked as such, and must not be
   misrepresented as being the original software.
   3. This notice may not be removed or altered from any source
   distribution.
 */

/**
 * @author Muzer(muzerly@gmail.com)
 * @link http://code.google.com/p/jiglibflash
 */
 
 (function(jigLib){
	var JSegment=jigLib.JSegment;
	var RigidBody=jigLib.RigidBody;
	var Vector3DUtil=jigLib.Vector3DUtil;
	var JNumber3D=jigLib.JNumber3D;
	var JConstraint=jigLib.JConstraint;
	var CollDetectBoxBox=jigLib.CollDetectBoxBox;
	var CollDetectSphereBox=jigLib.CollDetectSphereBox;
	var CollDetectCapsuleBox=jigLib.CollDetectCapsuleBox;
	var CollDetectBoxPlane=jigLib.CollDetectBoxPlane;
	var CollDetectBoxTerrain=jigLib.CollDetectBoxTerrain;
	var CollDetectSphereBox=jigLib.CollDetectSphereBox;
	var CollDetectSphereSphere=jigLib.CollDetectSphereSphere;
	var CollDetectSphereCapsule=jigLib.CollDetectSphereCapsule;
	var CollDetectSpherePlane=jigLib.CollDetectSpherePlane;
	var CollDetectSphereTerrain=jigLib.CollDetectSphereTerrain;
	var CollDetectCapsuleCapsule=jigLib.CollDetectCapsuleCapsule;
	var CollDetectCapsuleBox=jigLib.CollDetectCapsuleBox;
	var CollDetectSphereCapsule=jigLib.CollDetectSphereCapsule;
	var CollDetectCapsulePlane=jigLib.CollDetectCapsulePlane;
	var CollDetectCapsuleTerrain=jigLib.CollDetectCapsuleTerrain;
	var CollDetectInfo=jigLib.CollDetectInfo;
	 
	var CollisionSystem=function(){
		this.collBody = [];
		detectionFunctors = [];
		detectionFunctors["BOX"] = [];
		detectionFunctors["BOX"]["BOX"] = new CollDetectBoxBox();
		detectionFunctors["BOX"]["SPHERE"] = new CollDetectSphereBox();
		detectionFunctors["BOX"]["CAPSULE"] = new CollDetectCapsuleBox();
		detectionFunctors["BOX"]["PLANE"] = new CollDetectBoxPlane();
		detectionFunctors["BOX"]["TERRAIN"] = new CollDetectBoxTerrain();
		detectionFunctors["SPHERE"] = [];
		detectionFunctors["SPHERE"]["BOX"] = new CollDetectSphereBox();
		detectionFunctors["SPHERE"]["SPHERE"] = new CollDetectSphereSphere();
		detectionFunctors["SPHERE"]["CAPSULE"] = new CollDetectSphereCapsule();
		detectionFunctors["SPHERE"]["PLANE"] = new CollDetectSpherePlane();
		detectionFunctors["SPHERE"]["TERRAIN"] = new CollDetectSphereTerrain();
		detectionFunctors["CAPSULE"] = [];
		detectionFunctors["CAPSULE"]["CAPSULE"] = new CollDetectCapsuleCapsule();
		detectionFunctors["CAPSULE"]["BOX"] = new CollDetectCapsuleBox();
		detectionFunctors["CAPSULE"]["SPHERE"] = new CollDetectSphereCapsule();
		detectionFunctors["CAPSULE"]["PLANE"] = new CollDetectCapsulePlane();
		detectionFunctors["CAPSULE"]["TERRAIN"] = new CollDetectCapsuleTerrain();
		detectionFunctors["PLANE"] = [];
		detectionFunctors["PLANE"]["BOX"] = new CollDetectBoxPlane();
		detectionFunctors["PLANE"]["SPHERE"] = new CollDetectSpherePlane();
		detectionFunctors["PLANE"]["CAPSULE"] = new CollDetectCapsulePlane();
		detectionFunctors["TERRAIN"] = [];
		detectionFunctors["TERRAIN"]["SPHERE"] = new CollDetectSphereTerrain();
		detectionFunctors["TERRAIN"]["BOX"] = new CollDetectBoxTerrain();
		detectionFunctors["TERRAIN"]["CAPSULE"] = new CollDetectCapsuleTerrain();
		this.detectionFunctors=detectionFunctors;
	};
	CollisionSystem.prototype.detectionFunctors=null;
	CollisionSystem.prototype.collBody=null;
	 
	CollisionSystem.prototype.addCollisionBody=function(body){
		if (!this.findBody(body))
			this.collBody.push(body);
	};

	CollisionSystem.prototype.removeCollisionBody=function(body){
		if (this.findBody(body))
			this.collBody.splice(this.collBody.indexOf(body), 1);
	};

	CollisionSystem.prototype.removeAllCollisionBodies=function(){
		this.collBody = [];
	};

	// Detects collisions between the body and all the registered collision bodies
	CollisionSystem.prototype.detectCollisions=function(body, collArr){
		if (!body.isActive)
			return;

		var info;
		var fu;

		for(var i=0, cbl=this.collBody.length; i<cbl; i++){
			var _collBody=this.collBody[i];
			if (body != _collBody && this.checkCollidables(body, _collBody) && this.detectionFunctors[body.get_type()][_collBody.get_type()] != undefined){
				info = new CollDetectInfo();
				info.body0 = body;
				info.body1 = _collBody;
				fu = detectionFunctors[info.body0.get_type()][info.body1.get_type()];
				fu.collDetect(info, collArr);
			}
		}
	};
	
	// Detects collisions between the all bodies
	CollisionSystem.prototype.detectAllCollisions=function(bodies, collArr){
		var info;
		var fu;
		var bodyID;
		var bodyType;
						
		for(var i=0, bl=bodies.length; i<bl; i++){
			var _body=bodies[i];
			bodyID = _body.id;
			bodyType = _body.get_type();

			for(var j=0;j<this.collBody.length;j++){
				var _collBody=this.collBody[j];
				if (_body == _collBody){
					continue;
				}

				if (_collBody.isActive && bodyID > _collBody.id){
					continue;
				}

				if (this.checkCollidables(_body, _collBody) && this.detectionFunctors[bodyType][_collBody.get_type()] != undefined){
					info = new CollDetectInfo();
					info.body0 = _body;
					info.body1 = _collBody;
					fu = detectionFunctors[info.body0.get_type()][info.body1.get_type()];
					fu.collDetect(info, collArr);
				}
			}
		}
	};

	CollisionSystem.prototype.segmentIntersect=function(out, seg, ownerBody){
		out.fracOut = JNumber3D.NUM_HUGE;
		out.posOut = [0,0,0,0];
		out.normalOut = [0,0,0,0];

		var obj= {};

		for(var i=0, cbl=this.collBody.length; i<cbl; i++){
			var _collBody=this.collBody[i];
			if (_collBody != ownerBody && this.segmentBounding(seg, _collBody)){
				if (_collBody.segmentIntersect(obj, seg, _collBody.get_currentState())){
					if (obj.fracOut < out.fracOut){
						out.posOut = obj.posOut;
						out.normalOut = obj.normalOut;
						out.fracOut = obj.fracOut;
						out.bodyOut = _collBody;
					}
				}
			}
		}

		if (out.fracOut > 1)
			return false;
		
		if (out.fracOut < 0)
			out.fracOut = 0;
		else if (out.fracOut > 1)
			out.fracOut = 1;
		
		return true;
	};

	CollisionSystem.prototype.segmentBounding=function(seg, obj){
		var pos = seg.getPoint(0.5);
		var r = Vector3DUtil.get_length(seg.delta) / 2;

		if (obj.get_type() != "PLANE" && obj.get_type() != "TERRAIN"){
			var num1 = Vector3DUtil.get_length(Vector3DUtil.subtract(pos, obj.get_currentState().position));
			var num2 = r + obj.get_boundingSphere();
			if (num1 <= num2){
				return true;
			}else{
				return false;
			}
		}else{
			return true;
		}
	};

	CollisionSystem.prototype.findBody=function(body){
		for(var i=0, cbl=this.collBody.length; i<cbl; i++){
			var _collBody=this.collBody[i];
			if (body == _collBody)
				return true;
		}
		return false;
	};

	CollisionSystem.prototype.checkCollidables=function(body0, body1){
		if (body0.get_nonCollidables().length == 0 && body1.get_nonCollidables().length == 0){
			return true;
		}
		var nonCollidables=body0.get_nonCollidables();
		for(var i=0, ncl=nonCollidables.length; i<ncl; i++){
			var _body0=nonCollidables[i];
			if (body1 == _body0)
				return false;
		}
		nonCollidables=body1.get_nonCollidables();
		for(var i=0, ncl=nonCollidables.length; i<ncl; i++){
			var _body1=nonCollidables[i];
			if (body0 == _body1)
				return false;
		}
		return true;
	};
	 
	jigLib.CollisionSystem=CollisionSystem;
})(jigLib);/*
   Copyright (c) 2007 Danny Chapman
   http://www.rowlhouse.co.uk

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any damages
   arising from the use of this software.
   Permission is granted to anyone to use this software for any purpose,
   including commercial applications, and to alter it and redistribute it
   freely, subject to the following restrictions:
   1. The origin of this software must not be misrepresented; you must not
   claim that you wrote the original software. If you use this software
   in a product, an acknowledgment in the product documentation would be
   appreciated but is not required.
   2. Altered source versions must be plainly marked as such, and must not be
   misrepresented as being the original software.
   3. This notice may not be removed or altered from any source
   distribution.
 */

/**
 * @author Muzer(muzerly@gmail.com)
 * @link http://code.google.com/p/jiglibflash
 */

(function(jigLib){
	
	var JConstraint=function(){
		this._constraintEnabled = false;
		this.enableConstraint();
	};
	JConstraint.prototype._satisfied=null;
	JConstraint.prototype._constraintEnabled=null;

	JConstraint.prototype.set_satisfied=function(s){
		this._satisfied = s;
	};

	JConstraint.prototype.get_satisfied=function(){
		return this._satisfied;
	};

	// prepare for applying constraints - the subsequent calls to
	// apply will all occur with a constant position i.e. precalculate
	// everything possible
	JConstraint.prototype.preApply=function(dt){
		this._satisfied = false;
	};

	// apply the constraint by adding impulses. Return value
	// indicates if any impulses were applied. If impulses were applied
	// the derived class should call SetConstraintsUnsatisfied() on each
	// body that is involved.
	JConstraint.prototype.apply=function(dt){
		return false;
	};

	// register with the physics system
	JConstraint.prototype.enableConstraint=function(){
		if (this._constraintEnabled)
			return;
		
		this._constraintEnabled = true;
		jigLib.PhysicsSystem.getInstance().addConstraint(this);
	};

	// deregister from the physics system
	JConstraint.prototype.disableConstraint=function(){
		if (!this._constraintEnabled)
			return;
		
		this._constraintEnabled = false;
		jigLib.PhysicsSystem.getInstance().removeConstraint(this);
	};

	// are we registered with the physics system?
	JConstraint.prototype.get_constraintEnabled=function(){
		return this._constraintEnabled;
	};
	
	jigLib.JConstraint=JConstraint;
	
})(jigLib);/*
   Copyright (c) 2007 Danny Chapman
   http://www.rowlhouse.co.uk

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any damages
   arising from the use of this software.
   Permission is granted to anyone to use this software for any purpose,
   including commercial applications, and to alter it and redistribute it
   freely, subject to the following restrictions:
   1. The origin of this software must not be misrepresented; you must not
   claim that you wrote the original software. If you use this software
   in a product, an acknowledgment in the product documentation would be
   appreciated but is not required.
   2. Altered source versions must be plainly marked as such, and must not be
   misrepresented as being the original software.
   3. This notice may not be removed or altered from any source
   distribution.
 */

/**
 * @author Muzer(muzerly@gmail.com)
 * @link http://code.google.com/p/jiglibflash
 */

(function(jigLib){
	var Vector3DUtil=jigLib.Vector3DUtil;
	var JMatrix3D=jigLib.JMatrix3D;
	var JNumber3D=jigLib.JNumber3D;
	var JConstraint=jigLib.JConstraint;
	var RigidBody=jigLib.RigidBody;

	var JConstraintMaxDistance=function(body0, body0Pos, body1, body1Pos, maxDistance){
		if(!maxDistance) maxDistance=1;
		this.Super();
		this._body0 = body0;
		this._body0Pos = body0Pos;
		this._body1 = body1;
		this._body1Pos = body1Pos;
		this._maxDistance = maxDistance;
		body0.addConstraint(this);
		body1.addConstraint(this);
	};
	jigLib.extend(JConstraintMaxDistance,jigLib.JConstraint);
	
	JConstraintMaxDistance.prototype._maxVelMag = 20;
	JConstraintMaxDistance.prototype._minVelForProcessing = 0.01;

	JConstraintMaxDistance.prototype._body0=null;
	JConstraintMaxDistance.prototype._body1=null;
	JConstraintMaxDistance.prototype._body0Pos=null;
	JConstraintMaxDistance.prototype._body1Pos=null;
	JConstraintMaxDistance.prototype._maxDistance=null;

	JConstraintMaxDistance.prototype.r0=null;
	JConstraintMaxDistance.prototype.r1=null;
	JConstraintMaxDistance.prototype._worldPos=null;
	JConstraintMaxDistance.prototype._currentRelPos0=null;
	
	JConstraintMaxDistance.prototype.preApply=function(dt){
		this.set_satisfied(false);
		
		this.r0 = this._body0Pos.slice(0);
		this.r1 = this._body1Pos.slice(0);
		JMatrix3D.multiplyVector(this._body0.get_currentState().get_orientation(), this.r0);
		JMatrix3D.multiplyVector(this._body1.get_currentState().get_orientation(), this.r1);
		//this.r0 = this._body0.get_currentState().get_orientation().transformVector(this._body0Pos.slice(0));
		//this.r1 = this._body1.get_currentState().get_orientation().transformVector(this._body1Pos.slice(0));
		
		var worldPos0 = Vector3DUtil.add(this._body0.get_currentState().position, this.r0);
		var worldPos1 = Vector3DUtil.add(this._body1.get_currentState().position, this.r1);
		this._worldPos = JNumber3D.getScaleVector(Vector3DUtil.add(worldPos0, worldPos1), 0.5);

		this._currentRelPos0 = Vector3DUtil.subtract(worldPos0, worldPos1);
	};

	JConstraintMaxDistance.prototype.apply=function(dt){
		this.set_satisfied(true);

		if (!this._body0.isActive && !this._body1.isActive)
			return false;
		
		var currentVel0 = this._body0.getVelocity(this.r0);
		var currentVel1 = this._body1.getVelocity(this.r1);

		var predRelPos0 = Vector3DUtil.add(this._currentRelPos0, JNumber3D.getScaleVector(Vector3DUtil.subtract(currentVel0, currentVel1), dt));
		var clampedRelPos0 = predRelPos0.slice(0);
		var clampedRelPos0Mag = Vector3DUtil.get_length(clampedRelPos0);
		
		if (clampedRelPos0Mag <= JNumber3D.NUM_TINY)
			return false;
		
		if (clampedRelPos0Mag > this._maxDistance)
			clampedRelPos0 = JNumber3D.getScaleVector(clampedRelPos0, this._maxDistance / clampedRelPos0Mag);

		var desiredRelVel0 = JNumber3D.getDivideVector(Vector3DUtil.subtract(clampedRelPos0, this._currentRelPos0), dt);
		var Vr = Vector3DUtil.subtract(Vector3DUtil.subtract(currentVel0, currentVel1), desiredRelVel0);

		var normalVel = Vector3DUtil.get_length(Vr);
		if (normalVel > this._maxVelMag){
			Vr = JNumber3D.getScaleVector(Vr, this._maxVelMag / normalVel);
			normalVel = this._maxVelMag;
		}else if (normalVel < this._minVelForProcessing){
			return false;
		}

		var N = JNumber3D.getDivideVector(Vr, normalVel);
		
		var tempVec1 = Vector3DUtil.crossProduct(this.r0, N);
		JMatrix3D.multiplyVector(this._body0.get_worldInvInertia(), tempVec1);
		
		var tempVec2 = Vector3DUtil.crossProduct(this.r1, N);
		JMatrix3D.multiplyVector(this._body1.get_worldInvInertia(), tempVec2);
		
		var denominator = this._body0.get_invMass()  
						+ this._body1.get_invMass() 
						+ Vector3DUtil.dotProduct(N, Vector3DUtil.crossProduct(tempVec1, this.r0)) 
						+ Vector3DUtil.dotProduct(N, Vector3DUtil.crossProduct(tempVec2, this.r1));

		if (denominator < JNumber3D.NUM_TINY)
			return false;

		var normalImpulse = JNumber3D.getScaleVector(N, -normalVel / denominator);
		this._body0.applyWorldImpulse(normalImpulse, this._worldPos);
		this._body1.applyWorldImpulse(JNumber3D.getScaleVector(normalImpulse, -1), this._worldPos);

		this._body0.setConstraintsAndCollisionsUnsatisfied();
		this._body1.setConstraintsAndCollisionsUnsatisfied();
		this.set_satisfied(true);
		return true;
	};
	
	jigLib.JConstraintMaxDistance=JConstraintMaxDistance;
	
})(jigLib);/*
   Copyright (c) 2007 Danny Chapman
   http://www.rowlhouse.co.uk

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any damages
   arising from the use of this software.
   Permission is granted to anyone to use this software for any purpose,
   including commercial applications, and to alter it and redistribute it
   freely, subject to the following restrictions:
   1. The origin of this software must not be misrepresented; you must not
   claim that you wrote the original software. If you use this software
   in a product, an acknowledgment in the product documentation would be
   appreciated but is not required.
   2. Altered source versions must be plainly marked as such, and must not be
   misrepresented as being the original software.
   3. This notice may not be removed or altered from any source
   distribution.
 */

/**
 * @author Muzer(muzerly@gmail.com)
 * @link http://code.google.com/p/jiglibflash
 */

(function(jigLib){
	var Vector3DUtil=jigLib.Vector3DUtil;
	var JMatrix3D=jigLib.JMatrix3D;
	var JNumber3D=jigLib.JNumber3D;
	var JConstraint=jigLib.JConstraint;
	var RigidBody=jigLib.RigidBody;
	
	// Constrains a point on one body to be fixed to a point on another body

	/// allowed_distance indicated how much the points are allowed to deviate.
	/// timescale indicates the timescale over which deviation is eliminated
	/// (suggest a few times dt - be careful if there's a variable timestep!)
	/// if timescale < 0 then the value indicates the number of dts
	var JConstraintPoint=function(body0, body0Pos, body1, body1Pos, allowedDistance, timescale)
	{
		this.Super();
		this._body0 = body0;
		this._body0Pos = body0Pos;
		this._body1 = body1;
		this._body1Pos = body1Pos;
		this._allowedDistance = (allowedDistance) ? allowedDistance : 1;
		this._timescale = (timescale) ? timescale : 1;
		if (this._timescale < JNumber3D.NUM_TINY) _timescale = JNumber3D.NUM_TINY;
		body0.addConstraint(this);
		body1.addConstraint(this);
	};
	jigLib.extend(JConstraintPoint,jigLib.JConstraint);
	
	JConstraintPoint.prototype._maxVelMag = 20;
	JConstraintPoint.prototype._minVelForProcessing = 0.01;

	JConstraintPoint.prototype._body0=null;
	JConstraintPoint.prototype._body1=null;
	JConstraintPoint.prototype._body0Pos=null;
	JConstraintPoint.prototype._body1Pos=null;

	JConstraintPoint.prototype._timescale=null;
	JConstraintPoint.prototype._allowedDistance=null;

	JConstraintPoint.prototype.r0=null;
	JConstraintPoint.prototype.r1=null;
	JConstraintPoint.prototype._worldPos=null;
	JConstraintPoint.prototype._vrExtra=null;
	
	JConstraintPoint.prototype.preApply=function(dt)
	{
		this.set_satisfied(false);
		
		this.r0 = this._body0Pos.slice(0);
		JMatrix3D.multiplyVector(this._body0.get_currentState().get_orientation(), this.r0);
		this.r1 = this._body1Pos.slice(0);
		JMatrix3D.multiplyVector(this._body1.get_currentState().get_orientation(), this.r1);
		
		//this.r0 = this._body0.get_currentState().get_orientation().transformVector(this._body0Pos);
		//this.r1 = this._body1.get_currentState().get_orientation().transformVector(this._body1Pos);

		var worldPos0 = Vector3DUtil.add(this._body0.get_currentState().position, this.r0);
		var worldPos1 = Vector3DUtil.add(this._body1.get_currentState().position, this.r1);
		this._worldPos = JNumber3D.getScaleVector(Vector3DUtil.add(worldPos0, worldPos1), 0.5);

		var deviation = Vector3DUtil.subtract(worldPos0, worldPos1);
		var deviationAmount = Vector3DUtil.get_length(deviation);
		/*
		if (deviationAmount <= this._allowedDistance){
			this.set_satisfied(true);
			this._vrExtra = [0,0,0,0];
			return;
		}
		*/
		if (deviationAmount > this._allowedDistance)
			this._vrExtra = JNumber3D.getScaleVector(deviation, (deviationAmount - this._allowedDistance) / (deviationAmount * Math.max(this._timescale, dt)));
		else
			this._vrExtra = [0,0,0,0];
	};

	JConstraintPoint.prototype.apply=function(dt)
	{
		//if (this._satisfied) return;
		this.set_satisfied(true);
		
		if (!this._body0.isActive && !this._body1.isActive)
			return false;
		
		var currentVel0 = this._body0.getVelocity(this.r0);
		var currentVel1 = this._body1.getVelocity(this.r1);
		var Vr = Vector3DUtil.add(this._vrExtra, Vector3DUtil.subtract(currentVel0, currentVel1));

		var normalVel = Vector3DUtil.get_length(Vr);
		if (normalVel < this._minVelForProcessing)
			return false;

		if (normalVel > this._maxVelMag){
			Vr = JNumber3D.getScaleVector(Vr, this._maxVelMag / normalVel);
			normalVel = this._maxVelMag;
		}
		
		var N = JNumber3D.getDivideVector(Vr, normalVel);
		var tempVec1 = Vector3DUtil.crossProduct(this.r0, N);
		JMatrix3D.multiplyVector(this._body0.get_worldInvInertia(), tempVec1);
		//tempVec1 = this._body0.get_worldInvInertia().transformVector(tempVec1);
		var tempVec2 = Vector3DUtil.crossProduct(this.r1, N);
		JMatrix3D.multiplyVector(this._body1.get_worldInvInertia(), tempVec2);
		//tempVec2 = this._body1.get_worldInvInertia().transformVector(tempVec2);
		
		var denominator = this._body0.get_invMass() 
						+ this._body1.get_invMass() 
						+ Vector3DUtil.dotProduct(N, Vector3DUtil.crossProduct(tempVec1, this.r0)) 
						+ Vector3DUtil.dotProduct(N, Vector3DUtil.crossProduct(tempVec2, this.r1));

		
		if (denominator < JNumber3D.NUM_TINY)
			return false;

		var normalImpulse0=JNumber3D.getScaleVector(N, -normalVel / denominator);
		//Vector3DUtil.scaleBy(normalImpulse0, 0.5);
		var normalImpulse1=JNumber3D.getScaleVector(normalImpulse0, -1);
		
		/*limit the impulse applied to body1 so it does not exceed the velocity of body0
		var vel1toAdd=JNumber3D.getScaleVector(normalImpulse1, this._body1._invMass);
		var newVel1=Vector3DUtil.add(this._body1._currState.linVelocity, vel1toAdd);
		var vel0Sum=Vector3DUtil.getSum(currentVel0);
		var newVel1Sum=Vector3DUtil.getSum(newVel1);
		if (newVel1Sum > vel0Sum){
			var diff=newVel1Sum-vel0Sum;
			Vector3DUtil.limitSum(normalImpulse1,newVel1Sum-diff);
		}
		
		//limit the impulse applied to body1 so it does not exceed the velocity of body0
		var vel0toAdd=JNumber3D.getScaleVector(normalImpulse0, this._body1._invMass);
		var newVel0=Vector3DUtil.add(this._body0._currState.linVelocity, vel0toAdd);
		//var vel0Sum=Vector3DUtil.getSum(currentVel0);
		var newVel0Sum=Vector3DUtil.getSum(newVel0);
		if (newVel0Sum > vel0Sum){
			var diff=newVel0Sum-vel0Sum;
			Vector3DUtil.limitSum(normalImpulse0,newVel0Sum-diff);
		}
		*/
		
		this._body0.applyWorldImpulse(normalImpulse0, this._worldPos);
		this._body1.applyWorldImpulse(normalImpulse1, this._worldPos);
		
		this._body0.setConstraintsAndCollisionsUnsatisfied();
		this._body1.setConstraintsAndCollisionsUnsatisfied();
		this.set_satisfied(true);
		
		return true;
	};
	
	jigLib.JConstraintPoint=JConstraintPoint;
	
})(jigLib);/*
Copyright (c) 2007 Danny Chapman 
http://www.rowlhouse.co.uk

This software is provided 'as-is', without any express or implied
warranty. In no event will the authors be held liable for any damages
arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it
freely, subject to the following restrictions:
1. The origin of this software must not be misrepresented; you must not
claim that you wrote the original software. If you use this software
in a product, an acknowledgment in the product documentation would be
appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be
misrepresented as being the original software.
3. This notice may not be removed or altered from any source
distribution.
 */

/**
 * @author Muzer(muzerly@gmail.com)
 * @link http://code.google.com/p/jiglibflash
 */
 
(function(jigLib){
	var Vector3DUtil=jigLib.Vector3DUtil;
	var JMatrix3D=jigLib.JMatrix3D;
	var JNumber3D=jigLib.JNumber3D;
	var JConstraint=jigLib.JConstraint;
	var RigidBody=jigLib.RigidBody;

	// pointOnBody is in body coords
	var JConstraintWorldPoint=function(body, pointOnBody, worldPosition) {
		this.Super();
		this._body = body;
		this._pointOnBody = pointOnBody;
		this._worldPosition = worldPosition;
		body.addConstraint(this);
	};
	jigLib.extend(JConstraintWorldPoint,jigLib.JConstraint);

	JConstraintWorldPoint.prototype.minVelForProcessing = 0.001;
	JConstraintWorldPoint.prototype.allowedDeviation = 0.01;
	JConstraintWorldPoint.prototype.timescale = 4;
				
	JConstraintWorldPoint.prototype._body=null;
	JConstraintWorldPoint.prototype._pointOnBody=null;
	JConstraintWorldPoint.prototype._worldPosition=null;
	

	JConstraintWorldPoint.prototype.set_worldPosition=function(pos){
		this._worldPosition = pos;
	};
				
	JConstraintWorldPoint.prototype.get_worldPosition=function(){
		return this._worldPosition;
	};
				
	JConstraintWorldPoint.prototype.apply=function(dt){
		this.set_satisfied(true);

		var worldPos = this._pointOnBody.slice(0);
		JMatrix3D.multiplyVector(this._body.get_currentState().get_orientation(), worldPos);
		worldPos = Vector3DUtil.add(worldPos, this._body.get_currentState().position);
		var R = Vector3DUtil.subtract(worldPos, this._body.get_currentState().position);
		var currentVel = Vector3DUtil.add(this._body.get_currentState().linVelocity, 
										  Vector3DUtil.crossProduct(this._body.get_currentState().rotVelocity, R));
						
		var desiredVel;
		var deviationDir;
		var deviation= Vector3DUtil.subtract(worldPos, this._worldPosition);
		var deviationDistance = Vector3DUtil.get_length(deviation);
		if (deviationDistance > this.allowedDeviation) {
			deviationDir = JNumber3D.getDivideVector(deviation, deviationDistance);
			desiredVel = JNumber3D.getScaleVector(deviationDir, (this.allowedDeviation - deviationDistance) / (this.timescale * dt));
		} else {
			desiredVel = [0,0,0,0];
		}
						
		var N = Vector3DUtil.subtract(currentVel, desiredVel);
		var normalVel = Vector3DUtil.get_length(N);
		if (normalVel < this.minVelForProcessing) {
			return false;
		}
		N = JNumber3D.getDivideVector(N, normalVel);
		
		var tempV = Vector3DUtil.crossProduct(R, N);
		JMatrix3D.multiplyVector(this._body.get_worldInvInertia(), tempV);
		var denominator= this._body.get_invMass() + Vector3DUtil.dotProduct(N, Vector3DUtil.crossProduct(tempV, R));
						 
		if (denominator < JNumber3D.NUM_TINY) {
			return false;
		}
						 
		var normalImpulse = -normalVel / denominator;
						
		this._body.applyWorldImpulse(JNumber3D.getScaleVector(N, normalImpulse), worldPos);
						
		this._body.setConstraintsAndCollisionsUnsatisfied();
		this.set_satisfied(true);
						
		return true;
	};
	
	jigLib.JConstraintWorldPoint=JConstraintWorldPoint;
	
})(jigLib);/*
   Copyright (c) 2007 Danny Chapman
   http://www.rowlhouse.co.uk

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any damages
   arising from the use of this software.
   Permission is granted to anyone to use this software for any purpose,
   including commercial applications, and to alter it and redistribute it
   freely, subject to the following restrictions:
   1. The origin of this software must not be misrepresented; you must not
   claim that you wrote the original software. If you use this software
   in a product, an acknowledgment in the product documentation would be
   appreciated but is not required.
   2. Altered source versions must be plainly marked as such, and must not be
   misrepresented as being the original software.
   3. This notice may not be removed or altered from any source
   distribution.
 */

/**
 * @author Muzer(muzerly@gmail.com)
 * @link http://code.google.com/p/jiglibflash
 */

(function(jigLib){
	var Vector3DUtil=jigLib.Vector3DUtil;
	var JMatrix3D=jigLib.JMatrix3D;
	var JNumber3D=jigLib.JNumber3D;
	var PhysicsController=jigLib.PhysicsController;
	var JConstraintMaxDistance=jigLib.JConstraintMaxDistance;
	var JConstraintPoint=jigLib.JConstraintPoint;

	var HingeJoint=function(body0, body1,hingeAxis, hingePosRel0,hingeHalfWidth, hingeFwdAngle,hingeBckAngle, sidewaysSlack, damping){
		this._body0 = body0;
		this._body1 = body1;
		this._hingeAxis = hingeAxis.slice(0);
		this._hingePosRel0 = hingePosRel0.slice(0);
		this._usingLimit = false;
		this._hingeEnabled = false;
		this._broken = false;
		this._damping = damping;
		this._extraTorque = 0;

		Vector3DUtil.normalize(this._hingeAxis);
		var _hingePosRel1 = Vector3DUtil.add(this._body0.get_currentState().position, Vector3DUtil.subtract(this._hingePosRel0, this._body1.get_currentState().position));

		var relPos0a = Vector3DUtil.add(this._hingePosRel0, JNumber3D.getScaleVector(this._hingeAxis, hingeHalfWidth));
		var relPos0b = Vector3DUtil.subtract(this._hingePosRel0, JNumber3D.getScaleVector(this._hingeAxis, hingeHalfWidth));

		var relPos1a = Vector3DUtil.add(_hingePosRel1, JNumber3D.getScaleVector(this._hingeAxis, hingeHalfWidth));
		var relPos1b = Vector3DUtil.subtract(_hingePosRel1, JNumber3D.getScaleVector(this._hingeAxis, hingeHalfWidth));

		var timescale = 1 / 20;
		var allowedDistanceMid = 0.005;
		var allowedDistanceSide = sidewaysSlack * hingeHalfWidth;

		this.sidePointConstraints = [];
		this.sidePointConstraints[0] = new JConstraintMaxDistance(this._body0, relPos0a, this._body1, relPos1a, allowedDistanceSide);
		this.sidePointConstraints[1] = new JConstraintMaxDistance(this._body0, relPos0b, this._body1, relPos1b, allowedDistanceSide);

		this.midPointConstraint = new JConstraintPoint(this._body0, this._hingePosRel0, this._body1, _hingePosRel1, allowedDistanceMid, timescale);

		if (hingeFwdAngle <= this.MAX_HINGE_ANGLE_LIMIT){
			var perpDir = Vector3DUtil.Y_AXIS;
			if (Vector3DUtil.dotProduct(perpDir, this._hingeAxis) > 0.1){
				perpDir[0] = 1;
				perpDir[1] = 0;
				perpDir[2] = 0;
			}
			var sideAxis = Vector3DUtil.crossProduct(this._hingeAxis, perpDir);
			perpDir = Vector3DUtil.crossProduct(sideAxis, this._hingeAxis);
			Vector3DUtil.normalize(perpDir);

			var len = 10 * hingeHalfWidth;
			var hingeRelAnchorPos0 = JNumber3D.getScaleVector(perpDir, len);
			var angleToMiddle = 0.5 * (hingeFwdAngle - hingeBckAngle);
			var hingeRelAnchorPos1 = hingeRelAnchorPos0.slice(0);
			JMatrix3D.multiplyVector(JMatrix3D.getRotationMatrix(this._hingeAxis[0], this._hingeAxis[1], this._hingeAxis[2], -angleToMiddle), hingeRelAnchorPos1);

			var hingeHalfAngle = 0.5 * (hingeFwdAngle + hingeBckAngle);
			var allowedDistance = len * 2 * Math.sin(0.5 * hingeHalfAngle * Math.PI / 180);

			var hingePos = Vector3DUtil.add(this._body1.get_currentState().position, this._hingePosRel0);
			var relPos0c = Vector3DUtil.add(hingePos, Vector3DUtil.subtract(hingeRelAnchorPos0, this._body0.get_currentState().position));
			var relPos1c = Vector3DUtil.add(hingePos, Vector3DUtil.subtract(hingeRelAnchorPos1, this._body1.get_currentState().position));

			this.maxDistanceConstraint = new JConstraintMaxDistance(this._body0, relPos0c, this._body1, relPos1c, allowedDistance);
			this._usingLimit = true;
		}
		if (this._damping <= 0){
			this._damping = -1;
		}else{
			this._damping = JNumber3D.getLimiteNumber(this._damping, 0, 1);
		}

		this.enableHinge();
	};
	jigLib.extend(HingeJoint,jigLib.PhysicsController);
	
	HingeJoint.prototype.MAX_HINGE_ANGLE_LIMIT = 150;
	HingeJoint.prototype._hingeAxis = null;
	HingeJoint.prototype._hingePosRel0 = null;
	HingeJoint.prototype._body0 = null;
	HingeJoint.prototype._body1 = null;
	HingeJoint.prototype._usingLimit = null;
	HingeJoint.prototype._hingeEnabled = null;
	HingeJoint.prototype._broken = null;
	HingeJoint.prototype._damping = null;
	HingeJoint.prototype._extraTorque = null;
	
	HingeJoint.prototype.sidePointConstraints = null;
	HingeJoint.prototype.midPointConstraint = null;
	HingeJoint.prototype.maxDistanceConstraint = null;

	HingeJoint.prototype.enableHinge=function(){
		if (this._hingeEnabled){
			return;
		}
		this.midPointConstraint.enableConstraint();
		this.sidePointConstraints[0].enableConstraint();
		this.sidePointConstraints[1].enableConstraint();
		if (this._usingLimit && !this._broken)
			this.maxDistanceConstraint.enableConstraint();

		this.enableController();
		this._hingeEnabled = true;
	};

	HingeJoint.prototype.disableHinge=function(){
		if (!this._hingeEnabled)
			return;

		this.midPointConstraint.disableConstraint();
		this.sidePointConstraints[0].disableConstraint();
		this.sidePointConstraints[1].disableConstraint();

		if (this._usingLimit && !this._broken)
			this.maxDistanceConstraint.disableConstraint();

		this.disableController();
		this._hingeEnabled = false;
	};

	HingeJoint.prototype.breakHinge=function(){
		if (this._broken)
			return;

		if (this._usingLimit)
			this.maxDistanceConstraint.disableConstraint();

		this._broken = true;
	};

	HingeJoint.prototype.mendHinge=function(){
		if (!this._broken)
			return;

		if (this._usingLimit)
			this.maxDistanceConstraint.enableConstraint();

		this._broken = false;
	};

	HingeJoint.prototype.setExtraTorque=function(torque){
		this._extraTorque = torque;
	};

	HingeJoint.prototype.getHingeEnabled=function(){
		return this._hingeEnabled;
	};

	HingeJoint.prototype.isBroken=function(){
		return this._broken;
	};

	HingeJoint.prototype.getHingePosRel0=function(){
		return this._hingePosRel0;
	};

	HingeJoint.prototype.updateController=function(dt){
		if (this._damping > 0){
			var hingeAxis = Vector3DUtil.subtract(this._body1.get_currentState().rotVelocity, this._body0.get_currentState().rotVelocity);
			Vector3DUtil.normalize(hingeAxis);

			var angRot1 = Vector3DUtil.dotProduct(this._body0.get_currentState().rotVelocity, hingeAxis);
			var angRot2 = Vector3DUtil.dotProduct(this._body1.get_currentState().rotVelocity, hingeAxis);

			var avAngRot = 0.5 * (angRot1 + angRot2);
			var frac = 1 - this._damping;
			var newAngRot1= avAngRot + (angRot1 - avAngRot) * frac;
			var newAngRot2= avAngRot + (angRot2 - avAngRot) * frac;

			var newAngVel1 = Vector3DUtil.add(this._body0.get_currentState().rotVelocity, JNumber3D.getScaleVector(hingeAxis, newAngRot1 - angRot1));
			var newAngVel2 = Vector3DUtil.add(this._body1.get_currentState().rotVelocity, JNumber3D.getScaleVector(hingeAxis, newAngRot2 - angRot2));

			this._body0.setAngVel(newAngVel1);
			this._body1.setAngVel(newAngVel2);
		}

		if (this._extraTorque != 0){
			var torque1 = this._hingeAxis.slice(0);
			JMatrix3D.multiplyVector(this._body0.get_currentState().get_orientation(), torque1);
			torque1 = JNumber3D.getScaleVector(torque1, this._extraTorque);

			this._body0.addWorldTorque(torque1);
			this._body1.addWorldTorque(JNumber3D.getScaleVector(torque1, -1));
		}
	};
	
	jigLib.HingeJoint=HingeJoint;
	
})(jigLib);
/*
   Copyright (c) 2007 Danny Chapman
   http://www.rowlhouse.co.uk

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any damages
   arising from the use of this software.
   Permission is granted to anyone to use this software for any purpose,
   including commercial applications, and to alter it and redistribute it
   freely, subject to the following restrictions:
   1. The origin of this software must not be misrepresented; you must not
   claim that you wrote the original software. If you use this software
   in a product, an acknowledgment in the product documentation would be
   appreciated but is not required.
   2. Altered source versions must be plainly marked as such, and must not be
   misrepresented as being the original software.
   3. This notice may not be removed or altered from any source
   distribution.
 */

/**
 * @author Muzer(muzerly@gmail.com), speedok(speedok@gmail.com)
 * @link http://code.google.com/p/jiglibflash
 */

 
(function(jigLib){
	var Vector3DUtil=jigLib.Vector3DUtil;
	var JConfig=jigLib.JConfig;
	var CollPointInfo=jigLib.CollPointInfo;
	var CollisionInfo=jigLib.CollisionInfo;
	var CollisionSystem=jigLib.CollisionSystem;
	var ContactData=jigLib.ContactData;
	var JMatrix3D=jigLib.JMatrix3D;
	var JNumber3D=jigLib.JNumber3D;	var JConstraint=jigLib.JConstraint;	var BodyPair=jigLib.BodyPair;	var CachedImpulse=jigLib.CachedImpulse;
	
	var PhysicsSystem=function(){
		this.setSolverType(JConfig.solverType);
		this._doingIntegration = false;
		this._bodies = [];
		this._collisions = [];
		this._effects=[];
		this._activeBodies = [];
		this._constraints = [];
		this._controllers = [];

		this._cachedContacts = [];
		this._collisionSystem = new CollisionSystem();

		this.setGravity(JNumber3D.getScaleVector(Vector3DUtil.Y_AXIS, -10));
	};
	
	PhysicsSystem.prototype._currentPhysicsSystem=null;

	PhysicsSystem.prototype._maxVelMag = 0.5;
	PhysicsSystem.prototype._minVelForProcessing = 0.001;

	PhysicsSystem.prototype._bodies = null;
	PhysicsSystem.prototype._activeBodies=null;
	PhysicsSystem.prototype._collisions=null;
	PhysicsSystem.prototype._constraints=null;
	PhysicsSystem.prototype._controllers=null;
	PhysicsSystem.prototype._effects=null;

	PhysicsSystem.prototype._gravityAxis=null;
	PhysicsSystem.prototype._gravity=null;

	PhysicsSystem.prototype._doingIntegration=null;

	PhysicsSystem.prototype.preProcessCollisionFn=function(){};
	PhysicsSystem.prototype.preProcessContactFn=function(){};
	PhysicsSystem.prototype.processCollisionFn=function(){};
	PhysicsSystem.prototype.processContactFn=function(){};

	PhysicsSystem.prototype._cachedContacts=null;
	PhysicsSystem.prototype._collisionSystem=null;
		
	PhysicsSystem.getInstance=function(){
		if (!PhysicsSystem._currentPhysicsSystem){
			PhysicsSystem._currentPhysicsSystem = new PhysicsSystem();
		}
		return PhysicsSystem._currentPhysicsSystem;
	};
	
	PhysicsSystem.prototype.getAllExternalForces=function(dt){
		for(var i=0, bl=this._bodies.length; i<bl; i++){
			this._bodies[i].addExternalForces(dt);
		}

		for(var i=0, cl=this._controllers.length; i<cl; i++){
			this._controllers[i].updateController(dt);
		}
	};

	PhysicsSystem.prototype.getCollisionSystem=function(){
		return this._collisionSystem;
	};

	PhysicsSystem.prototype.setGravity=function(gravity){
		this._gravity = gravity;
		if (this._gravity[0] == this._gravity[1] && this._gravity[1] == this._gravity[2])
			this._gravityAxis = -1;

		this._gravityAxis = 0;
		
		if (Math.abs(this._gravity[1]) > Math.abs(this._gravity[2]))
			this._gravityAxis = 1;

		if (Math.abs(this._gravity[2]) > Math.abs(JNumber3D.toArray(this._gravity)[this._gravityAxis]))
			this._gravityAxis = 2;
	};

	// global gravity acceleration
	PhysicsSystem.prototype.get_gravity=function(){
		return this._gravity;
	};

	PhysicsSystem.prototype.get_gravityAxis=function(){
		return this._gravityAxis;
	};

	PhysicsSystem.prototype.get_bodies=function(){
		return this._bodies;
	};

	// Add a rigid body to the simulation
	PhysicsSystem.prototype.addBody=function(body){
		if (!this.findBody(body)){
			this._bodies.push(body);
			this._collisionSystem.addCollisionBody(body);
		}
	};

	PhysicsSystem.prototype.removeBody=function(body){
		if (this.findBody(body)){
			this._bodies.splice(this._bodies.indexOf(body), 1);
			this._collisionSystem.removeCollisionBody(body);
		}
	};

	PhysicsSystem.prototype.removeAllBodies=function(){
		this._bodies = [];
		this._collisionSystem.removeAllCollisionBodies();
	};

	// Add a constraint to the simulation
	PhysicsSystem.prototype.addConstraint=function(constraint){
		if (!this.findConstraint(constraint))
			this._constraints.push(constraint);
	};
	
	PhysicsSystem.prototype.removeConstraint=function(constraint){
		if (this.findConstraint(constraint))
			this._constraints.splice(this._constraints.indexOf(constraint), 1);
	};

	PhysicsSystem.prototype.removeAllConstraints=function(){
		this._constraints = [];
	};
	
	// Add an effect to the simulation
	PhysicsSystem.prototype.addEffect=function(effect){
		if (!this.findEffect(effect))
			this._effects.push(effect);
	};
	
	PhysicsSystem.prototype.removeEffect=function(effect){
		if (this.findEffect(effect))
			this._effects.splice(this._effects.indexOf(effect), 1);
	};

	PhysicsSystem.prototype.removeAllEffects=function(){
		this._effects = [];
	};

	// Add a physics controlled to the simulation
	PhysicsSystem.prototype.addController=function(controller){
		if (!this.findController(controller))
			this._controllers.push(controller);
	};

	PhysicsSystem.prototype.removeController=function(controller){
		if (this.findController(controller))
			this._controllers.splice(this._controllers.indexOf(controller), 1);
	};

	PhysicsSystem.prototype.removeAllControllers=function(){
		this._controllers = [];
	};

	PhysicsSystem.prototype.setSolverType=function(type){
		switch (type)
		{
			case "FAST":
				this.preProcessCollisionFn = this.preProcessCollisionFast;
				this.preProcessContactFn = this.preProcessCollisionFast;
				this.processCollisionFn = this.processCollision;
				this.processContactFn = this.processCollision;
				return;
			case "NORMAL":
				this.preProcessCollisionFn = this.preProcessCollisionNormal;
				this.preProcessContactFn = this.preProcessCollisionNormal;
				this.processCollisionFn = this.processCollision;
				this.processContactFn = this.processCollision;
				return;
			case "ACCUMULATED":
				this.preProcessCollisionFn = this.preProcessCollisionAccumulated;
				this.preProcessContactFn = this.preProcessCollisionAccumulated;
				this.processCollisionFn = this.processCollision;
				this.processContactFn = this.processCollisionAccumulated;
				return;
			default:
				this.preProcessCollisionFn = this.preProcessCollisionNormal;
				this.preProcessContactFn = this.preProcessCollisionNormal;
				this.processCollisionFn = this.processCollision;
				this.processContactFn = this.processCollision;
				return;
		}
	};

	PhysicsSystem.prototype.findBody=function(body){
		var i=this._bodies.length-1;
		if (i > 0) do { if(body==this._bodies[i]) return true; } while (i--);
		return false;
	};

	PhysicsSystem.prototype.findConstraint=function(constraint){
		var i=this._constraints.length-1;
		if (i > 0) do { if(constraint==this._constraints[i]) return true; } while (i--);
		return false;
	};
	
	PhysicsSystem.prototype.findEffect=function(effect){
		var i=this._effects.length-1;
		if (i > 0) do { if(effect==this._effects[i]) return true; } while (i--);
		return false;
	};

	PhysicsSystem.prototype.findController=function(controller){
		var i=this._controllers.length-1;
		if (i > 0) do { if(controller==this._controllers[i]) return true; } while (i--);
		return false;
	};

	// fast-but-inaccurate pre-processor
	PhysicsSystem.prototype.preProcessCollisionFast=function(collision, dt){
		collision.satisfied=false;

		var body0 = collision.objInfo.body0;
		var body1 = collision.objInfo.body1;

		var N = collision.dirToBody;
		var timescale = JConfig.numPenetrationRelaxationTimesteps * dt;
		var approachScale = 0;
		var ptInfo;
		var tempV;
		var ptNum = collision.pointInfo.length;
		var numTiny = JNumber3D.NUM_TINY;

		if (ptNum > 1){
			var avR0 = [0,0,0,0];
			var avR1 = [0,0,0,0];
			var avDepth = 0;

			for (var i = 0; i < ptNum; i++){
				ptInfo = collision.pointInfo[i];
				avR0 = Vector3DUtil.add(avR0, ptInfo.r0);
				avR1 = Vector3DUtil.add(avR1, ptInfo.r1);
				avDepth += ptInfo.initialPenetration;
			}
			avR0 = JNumber3D.getDivideVector(avR0, ptNum);
			avR1 = JNumber3D.getDivideVector(avR1, ptNum);
			avDepth /= ptNum;

			var colPI = new CollPointInfo();
			colPI.r0 = avR0;
			colPI.r1 = avR1;
			colPI.initialPenetration = avDepth;
			collision.pointInfo = [colPI];
		}
		
		// removed loop because collision.pointInfo.length can only ever be 1 - Jim Sangwine
		ptInfo = collision.pointInfo[0];
		if (!body0.get_movable()){
			ptInfo.denominator = 0;
		}else{
			tempV = Vector3DUtil.crossProduct(ptInfo.r0, N);
			JMatrix3D.multiplyVector(body0.get_worldInvInertia(), tempV);
			ptInfo.denominator = body0.get_invMass() + Vector3DUtil.dotProduct(N, Vector3DUtil.crossProduct(tempV, ptInfo.r0));
		}
		if (body1.get_movable()){
			tempV = Vector3DUtil.crossProduct(ptInfo.r1, N);
			JMatrix3D.multiplyVector(body1.get_worldInvInertia(), tempV);
			ptInfo.denominator += (body1.get_invMass() + Vector3DUtil.dotProduct(N, Vector3DUtil.crossProduct(tempV, ptInfo.r1)));
		}
		if (ptInfo.denominator < numTiny)
			ptInfo.denominator = numTiny;

		if (ptInfo.initialPenetration > JConfig.allowedPenetration){
			ptInfo.minSeparationVel = (ptInfo.initialPenetration - JConfig.allowedPenetration) / timescale;
		}else{
			approachScale = -0.1 * (ptInfo.initialPenetration - JConfig.allowedPenetration) / JConfig.allowedPenetration;
			if (approachScale < numTiny)
				approachScale = numTiny;
			else if (approachScale > 1)
				approachScale = 1;
			var max = (dt > numTiny) ? dt : numTiny; // ~7x quicker than Math.max in Chromium, ~4x quicker in WebKit and marginally slower in Minefield
			ptInfo.minSeparationVel = approachScale * (ptInfo.initialPenetration - JConfig.allowedPenetration) / max;
		}
		
		if (ptInfo.minSeparationVel > this._maxVelMag)
			ptInfo.minSeparationVel = this._maxVelMag;
	};

	// Special pre-processor for the normal solver
	PhysicsSystem.prototype.preProcessCollisionNormal=function(collision, dt){
		collision.satisfied = false;

		var body0 = collision.objInfo.body0;
		var body1 = collision.objInfo.body1;

		var N = collision.dirToBody;
		var timescale= JConfig.numPenetrationRelaxationTimesteps * dt;
		var approachScale = 0;
		var ptInfo;
		var tempV;
		var len= collision.pointInfo.length;
		for (var i = 0; i < len; i++){
			ptInfo = collision.pointInfo[i];
			if (!body0.get_movable()){
				ptInfo.denominator = 0;
			}else{
				tempV = Vector3DUtil.crossProduct(ptInfo.r0, N);
				JMatrix3D.multiplyVector(body0.get_worldInvInertia(), tempV);
				ptInfo.denominator = body0.get_invMass() + Vector3DUtil.dotProduct(N, Vector3DUtil.crossProduct(tempV, ptInfo.r0));
			}

			if (body1.get_movable()){
				tempV = Vector3DUtil.crossProduct(ptInfo.r1, N);
				JMatrix3D.multiplyVector(body1.get_worldInvInertia(), tempV);
				ptInfo.denominator += (body1.get_invMass() + Vector3DUtil.dotProduct(N, Vector3DUtil.crossProduct(tempV, ptInfo.r1)));
			}

			if (ptInfo.denominator < JNumber3D.NUM_TINY)
				ptInfo.denominator = JNumber3D.NUM_TINY;

			if (ptInfo.initialPenetration > JConfig.allowedPenetration){
				ptInfo.minSeparationVel = (ptInfo.initialPenetration - JConfig.allowedPenetration) / timescale;
			}else{
				approachScale = -0.1 * (ptInfo.initialPenetration - JConfig.allowedPenetration) / JConfig.allowedPenetration;
				if (approachScale < JNumber3D.NUM_TINY)
					approachScale = JNumber3D.NUM_TINY;
				else if (approachScale > 1)
					approachScale = 1;
				
				var max=(dt > JNumber3D.NUM_TINY) ? dt : JNumber3D.NUM_TINY;
				ptInfo.minSeparationVel = approachScale * (ptInfo.initialPenetration - JConfig.allowedPenetration) / max;
			}
			if (ptInfo.minSeparationVel > this._maxVelMag)
				ptInfo.minSeparationVel = this._maxVelMag;
		}
	};

	// Special pre-processor for the accumulated solver
	PhysicsSystem.prototype.preProcessCollisionAccumulated=function(collision, dt){
		collision.satisfied = false;
		var body0 = collision.objInfo.body0;
		var body1 = collision.objInfo.body1;
		var N = collision.dirToBody;
		var timescale = JConfig.numPenetrationRelaxationTimesteps * dt;
		var tempV;
		var ptInfo;
		var initMinAllowedPen;
		var approachScale = 0;
		var numTiny = JNumber3D.NUM_TINY;
		var allowedPenetration = JConfig.allowedPenetration;
		var len = collision.pointInfo.length;
		for (var i = 0; i < len; i++){
			ptInfo = collision.pointInfo[i];
			initMinAllowedPen = ptInfo.initialPenetration - allowedPenetration;
			if (!body0.get_movable()){
				ptInfo.denominator = 0;
			}else{
				tempV = Vector3DUtil.crossProduct(ptInfo.r0, N);
				JMatrix3D.multiplyVector(body0.get_worldInvInertia(), tempV);
				ptInfo.denominator = body0.get_invMass() + Vector3DUtil.dotProduct(N, Vector3DUtil.crossProduct(tempV, ptInfo.r0));
			}

			if (body1.get_movable()){
				tempV = Vector3DUtil.crossProduct(ptInfo.r1, N);
				JMatrix3D.multiplyVector(body1.get_worldInvInertia(), tempV);
				ptInfo.denominator += (body1.get_invMass() + Vector3DUtil.dotProduct(N, Vector3DUtil.crossProduct(tempV, ptInfo.r1)));
			}
			if (ptInfo.denominator < numTiny) ptInfo.denominator = numTiny;

			if (ptInfo.initialPenetration > allowedPenetration){
				ptInfo.minSeparationVel = initMinAllowedPen / timescale;
			}else{
				approachScale = -0.1 * initMinAllowedPen / allowedPenetration;
				
				if (approachScale < numTiny) approachScale = numTiny;
				else if (approachScale > 1) approachScale = 1;
				
				var max=(dt>numTiny) ? dt : numTiny;
				ptInfo.minSeparationVel = approachScale * initMinAllowedPen / max;
			}

			ptInfo.accumulatedNormalImpulse = 0;
			ptInfo.accumulatedNormalImpulseAux = 0;
			ptInfo.accumulatedFrictionImpulse = [0,0,0,0];

			var bestDistSq = 0.04;
			var bp = new BodyPair(body0, body1, [0,0,0,0], [0,0,0,0]);

			for(var j=0, ccl=this._cachedContacts.length; j<ccl; j++){
				var cont=this._cachedContacts[j];
				var cpair=cont.pair;

				if (bp.body0 != cpair.body0 || bp.body1 == cpair.body1)
					continue;

				var distSq = (cpair.body0 == body0)  ? Vector3DUtil.get_lengthSquared(Vector3DUtil.subtract(cpair.r, ptInfo.r0)) 
													 : Vector3DUtil.get_lengthSquared(Vector3DUtil.subtract(cpair.r, ptInfo.r1));

				if (distSq < bestDistSq){
					bestDistSq = distSq;
					ptInfo.accumulatedNormalImpulse = this._cachedContacts[j].impulse.normalImpulse;
					ptInfo.accumulatedNormalImpulseAux = this._cachedContacts[j].impulse.normalImpulseAux;
					ptInfo.accumulatedFrictionImpulse = this._cachedContacts[j].impulse.frictionImpulse;
					if (this._cachedContacts[j].pair.body0 != body0){
						ptInfo.accumulatedFrictionImpulse = JNumber3D.getScaleVector(ptInfo.accumulatedFrictionImpulse, -1);
					}
				}
			}
			
			var impulse;
			if (ptInfo.accumulatedNormalImpulse != 0){
				impulse = JNumber3D.getScaleVector(N, ptInfo.accumulatedNormalImpulse);
				impulse = Vector3DUtil.add(impulse, ptInfo.accumulatedFrictionImpulse);
				body0.applyBodyWorldImpulse(impulse, ptInfo.r0);
				body1.applyBodyWorldImpulse(JNumber3D.getScaleVector(impulse, -1), ptInfo.r1);
			}
			if (ptInfo.accumulatedNormalImpulseAux != 0){
				impulse = JNumber3D.getScaleVector(N, ptInfo.accumulatedNormalImpulseAux);
				body0.applyBodyWorldImpulseAux(impulse, ptInfo.r0);
				body1.applyBodyWorldImpulseAux(JNumber3D.getScaleVector(impulse, -1), ptInfo.r1);
			}
		}
	};
	
	/* Handle an individual collision by classifying it, calculating
	impulse, applying impulse and updating the velocities of the
	objects. Allows over-riding of the elasticity. Ret val indicates
	if an impulse was applied
	*/
	PhysicsSystem.prototype.processCollision=function(collision, dt){
		collision.satisfied = true;

		var body0= collision.objInfo.body0;
		var body1 = collision.objInfo.body1;

		var gotOne = false;
		var N = collision.dirToBody;

		var deltaVel = 0;
		var normalVel = 0;
		var finalNormalVel = 0;
		var normalImpulse= 0;
		var impulse;
		var Vr0;
		var Vr1;
		var ptInfo;
		
		var len = collision.pointInfo.length;
		for (var i = 0; i < len; i++){
			ptInfo = collision.pointInfo[i];

			Vr0 = body0.getVelocity(ptInfo.r0);
			Vr1 = body1.getVelocity(ptInfo.r1);

			normalVel = Vector3DUtil.dotProduct(Vector3DUtil.subtract(Vr0, Vr1), N);
			if (normalVel > ptInfo.minSeparationVel)
				continue;

			finalNormalVel = -1 * collision.mat.get_restitution() * normalVel;
			if (finalNormalVel < this._minVelForProcessing)
				finalNormalVel = ptInfo.minSeparationVel;

			deltaVel = finalNormalVel - normalVel;
			if (deltaVel <= this._minVelForProcessing)
				continue;

			normalImpulse = deltaVel / ptInfo.denominator;

			gotOne = true;
			impulse = JNumber3D.getScaleVector(N, normalImpulse);

			body0.applyBodyWorldImpulse(impulse, ptInfo.r0);
			body1.applyBodyWorldImpulse(JNumber3D.getScaleVector(impulse, -1), ptInfo.r1);

			var tempV;
			var VR = Vr0.slice(0);
			if(body1.get_movable()) VR = Vector3DUtil.subtract(Vr0, Vr1);
			var tangent_vel = Vector3DUtil.subtract(VR, JNumber3D.getScaleVector(N, Vector3DUtil.dotProduct(VR, N)));
			var tangent_speed = Vector3DUtil.get_length(tangent_vel);

			if (tangent_speed > this._minVelForProcessing){
				var T = JNumber3D.getDivideVector(tangent_vel, -tangent_speed);
				var denominator = 0;

				if (body0.get_movable()){
					tempV = Vector3DUtil.crossProduct(ptInfo.r0, T);
					JMatrix3D.multiplyVector(body0.get_worldInvInertia(), tempV);
					denominator = body0.get_invMass() + Vector3DUtil.dotProduct(T, Vector3DUtil.crossProduct(tempV, ptInfo.r0));
				}

				if (body1.get_movable()){
					tempV = Vector3DUtil.crossProduct(ptInfo.r1, T);
					JMatrix3D.multiplyVector(body1.get_worldInvInertia(), tempV);
					denominator += (body1.get_invMass() + Vector3DUtil.dotProduct(T, Vector3DUtil.crossProduct(tempV, ptInfo.r1)));
				}

				if (denominator > JNumber3D.NUM_TINY){
					var impulseToReverse = tangent_speed / denominator;

					T = JNumber3D.getScaleVector(T, impulseToReverse);
					body0.applyBodyWorldImpulse(T, ptInfo.r0);
					body1.applyBodyWorldImpulse(JNumber3D.getScaleVector(T, -1), ptInfo.r1);
				}
			}
		}

		if (gotOne){
			body0.setConstraintsAndCollisionsUnsatisfied();
			body1.setConstraintsAndCollisionsUnsatisfied();
		}
		return gotOne;
	};

	// Accumulated and clamp impulses
	PhysicsSystem.prototype.processCollisionAccumulated=function(collision, dt){
		collision.satisfied = true;
		var gotOne = false;
		var N = collision.dirToBody;
		var body0 = collision.objInfo.body0;
		var body1 = collision.objInfo.body1;

		var deltaVel = 0;
		var normalVel = 0;
		var normalImpulse = 0;
		var impulse;
		var Vr0;
		var Vr1;
		var ptInfo;
		
		var len = collision.pointInfo.length;
		for (var i = 0; i < len; i++){
			ptInfo = collision.pointInfo[i];

			Vr0 = body0.getVelocity(ptInfo.r0);
			Vr1 = body1.getVelocity(ptInfo.r1);
			normalVel = Vector3DUtil.dotProduct(Vector3DUtil.subtract(Vr0, Vr1), N);
			deltaVel = -normalVel;
			if (ptInfo.minSeparationVel < 0)
				deltaVel += ptInfo.minSeparationVel;

			if (Math.abs(deltaVel) > this._minVelForProcessing){
				normalImpulse = deltaVel / ptInfo.denominator;
				var origAccumulatedNormalImpulse = ptInfo.accumulatedNormalImpulse;
				var accImpulse=(origAccumulatedNormalImpulse + normalImpulse);
				if (accImpulse<0) accImpulse = 0;
				ptInfo.accumulatedNormalImpulse = accImpulse;
				var actualImpulse = accImpulse - origAccumulatedNormalImpulse;

				impulse = JNumber3D.getScaleVector(N, actualImpulse);
				body0.applyBodyWorldImpulse(impulse, ptInfo.r0);
				body1.applyBodyWorldImpulse(JNumber3D.getScaleVector(impulse, -1), ptInfo.r1);

				gotOne = true;
			}

			Vr0 = body0.getVelocityAux(ptInfo.r0);
			Vr1 = body1.getVelocityAux(ptInfo.r1);
			normalVel = Vector3DUtil.dotProduct(Vector3DUtil.subtract(Vr0, Vr1), N);

			deltaVel = -normalVel;
			if (ptInfo.minSeparationVel > 0)
				deltaVel += ptInfo.minSeparationVel;

			if (Math.abs(deltaVel) > this._minVelForProcessing){
				normalImpulse = deltaVel / ptInfo.denominator;
				origAccumulatedNormalImpulse = ptInfo.accumulatedNormalImpulseAux;
				var accImpulseAux=ptInfo.accumulatedNormalImpulseAux + normalImpulse;
				if (accImpulseAux < 0) accImpulseAux = 0;
				ptInfo.accumulatedNormalImpulseAux = accImpulseAux;
				actualImpulse = accImpulseAux - origAccumulatedNormalImpulse;

				impulse = JNumber3D.getScaleVector(N, actualImpulse);
				body0.applyBodyWorldImpulseAux(impulse, ptInfo.r0);
				body1.applyBodyWorldImpulseAux(JNumber3D.getScaleVector(impulse, -1), ptInfo.r1);

				gotOne = true;
			}

			if (ptInfo.accumulatedNormalImpulse > 0){
				Vr0 = body0.getVelocity(ptInfo.r0);
				Vr1 = body1.getVelocity(ptInfo.r1);
				var tempV;
				var VR = Vector3DUtil.subtract(Vr0, Vr1);
				var tangent_vel = Vector3DUtil.subtract(VR, JNumber3D.getScaleVector(N, Vector3DUtil.dotProduct(VR, N)));
				var tangent_speed = Vector3DUtil.get_length(tangent_vel);
				if (tangent_speed > this._minVelForProcessing){
					var T= JNumber3D.getScaleVector(JNumber3D.getDivideVector(tangent_vel, tangent_speed), -1);
					var denominator = 0;
					if (body0.get_movable()){
						tempV = Vector3DUtil.crossProduct(ptInfo.r0, T);
						JMatrix3D.multiplyVector(body0.get_worldInvInertia(), tempV);
						denominator = body0.invMass + Vector3DUtil.dotProduct(T, Vector3DUtil.crossProduct(tempV, ptInfo.r0));
					}
					if (body1.get_movable()){
						tempV = Vector3DUtil.crossProduct(ptInfo.r1, T);
						JMatrix3D.multiplyVector(body1.get_worldInvInertia(), tempV);
						denominator += (body1.invMass + Vector3DUtil.dotProduct(T, Vector3DUtil.crossProduct(tempV, ptInfo.r1)));
					}
					if (denominator > JNumber3D.NUM_TINY){
						var impulseToReverse = tangent_speed / denominator;
						var frictionImpulseVec = JNumber3D.getScaleVector(T, impulseToReverse);

						var origAccumulatedFrictionImpulse = ptInfo.accumulatedFrictionImpulse.slice(0);
						ptInfo.accumulatedFrictionImpulse = Vector3DUtil.add(ptInfo.accumulatedFrictionImpulse, frictionImpulseVec);

						var AFIMag = Vector3DUtil.get_length(ptInfo.accumulatedFrictionImpulse);
						var maxAllowedAFIMag = collision.mat.friction * ptInfo.accumulatedNormalImpulse;

						if (AFIMag > JNumber3D.NUM_TINY && AFIMag > maxAllowedAFIMag)
							ptInfo.accumulatedFrictionImpulse = JNumber3D.getScaleVector(ptInfo.accumulatedFrictionImpulse, maxAllowedAFIMag / AFIMag);

						var actualFrictionImpulse = Vector3DUtil.subtract(ptInfo.accumulatedFrictionImpulse, origAccumulatedFrictionImpulse);

						body0.applyBodyWorldImpulse(actualFrictionImpulse, ptInfo.r0);
						body1.applyBodyWorldImpulse(JNumber3D.getScaleVector(actualFrictionImpulse, -1), ptInfo.r1);
					}
				}
			}
		}
		if (gotOne)
		{
			body0.setConstraintsAndCollisionsUnsatisfied();
			body1.setConstraintsAndCollisionsUnsatisfied();
		}
		return gotOne;
	};
	
	
	
	
	
	
	PhysicsSystem.prototype.sortPositionX=function(body0, body1){
		if (body0.get_currentState().position[0] < body1.get_currentState().position[0])
			return -1;
		else if (body0.get_currentState().position[0] > body1.get_currentState().position[0])
			return 1;
		else
			return 0;
	};
                
	PhysicsSystem.prototype.sortPositionY=function(body0, body1){
		if (body0.get_currentState().position[1] < body1.get_currentState().position[1])
			return -1;
		else if (body0.get_currentState().position[1] > body1.get_currentState().position[1])
			return 1;
		else
			return 0;
	};
                
	PhysicsSystem.prototype.sortPositionZ=function(body0, body1){
		if (body0.get_currentState().position[2] < body1.get_currentState().position[2])
			return -1;
		else if (body0.get_currentState().position[2] > body1.get_currentState().position[2])
			return 1;
		else
			return 0;
	};
                
	PhysicsSystem.prototype.doShockStep=function(dt){
		if (Math.abs(this._gravity[0]) > Math.abs(this._gravity[1]) && Math.abs(this._gravity[0]) > Math.abs(this._gravity[2])){
			this._bodies = this._bodies.sort(this.sortPositionX);
			this._collisionSystem.collBody = this._collisionSystem.collBody.sort(this.sortPositionX);
		}else if (Math.abs(this._gravity[1]) > Math.abs(this._gravity[2]) && Math.abs(this._gravity[1]) > Math.abs(this._gravity[0])){
			this._bodies = this._bodies.sort(this.sortPositionY);
			this._collisionSystem.collBody = this._collisionSystem.collBody.sort(this.sortPositionY);
		}else if (Math.abs(this._gravity[2]) > Math.abs(this._gravity[0]) && Math.abs(this._gravity[2]) > Math.abs(this._gravity[1])){
			this._bodies = this._bodies.sort(this.sortPositionZ);
			this._collisionSystem.collBody = this._collisionSystem.collBody.sort(this.sortPositionZ);
		}
                        
		var info;
		var setImmovable;
		var gotOne = true;
		var body_collisions=[];
                        
		var body0;
		var body1;
                        

		while (gotOne){
			gotOne = false;
			for(var i=0;i<this._bodies.length;i++){
				var body=this._bodies[i];
				if (body.get_movable() && body.get_doShockProcessing()){
					if (body.collisions.length == 0 || !body.isActive){
						body.internalSetImmovable();
					}else{
						setImmovable = false;
						body_collisions = body.collisions;
						for(var j=0;j<body_collisions.length;j++){
							info=body_collisions[j];

							body0 = info.objInfo.body0;
							body1 = info.objInfo.body1;
                                                                
							if ((body0 == body && !body1.get_movable()) || (body1 == body && !body0.get_movable())){
								this.preProcessCollisionFast(info, dt);
								this.processCollision(info, dt);
								setImmovable = true;
							}
						}
                                                        
						if (setImmovable){
							body.internalSetImmovable();
							gotOne = true;
						}
					}
				}
			}
		}

		for(var i=0;i<this._bodies.length;i++){
			body=this._bodies[i];
			body.internalRestoreImmovable();
			body_collisions = body.collisions;
			for(var j=0;j<body_collisions.length;j++){
				info=body_collisions[j];
				this.preProcessCollisionFn(info, dt);
				this.processCollisionFn(info, dt);
			}
		}
	};
	
	PhysicsSystem.prototype.updateContactCache=function(){
		this._cachedContacts = [];
		var ptInfo;
		var fricImpulse;
		var contact;
		for(var i=0, cl=this._collisions.length; i<cl; i++){			var collInfo=this._collisions[i];
			for (var j=0, pilen=collInfo.pointInfo.length; j<pilen; j++){
				ptInfo = collInfo.pointInfo[j];
				fricImpulse = (collInfo.objInfo.body0.id > collInfo.objInfo.body1.id) ? ptInfo.accumulatedFrictionImpulse : JNumber3D.getScaleVector(ptInfo.accumulatedFrictionImpulse, -1);

				contact = new ContactData();
				contact.pair = new BodyPair(collInfo.objInfo.body0, collInfo.objInfo.body1, ptInfo.r0, ptInfo.r1);
				contact.impulse = new CachedImpulse(ptInfo.accumulatedNormalImpulse, ptInfo.accumulatedNormalImpulseAux, ptInfo.accumulatedFrictionImpulse);

				this._cachedContacts.push(contact);
			}
		}
	};

	PhysicsSystem.prototype.handleAllConstraints=function(dt, iter, forceInelastic){
		var origNumCollisions = this._collisions.length;
		var collInfo;
		var _constraint;
		for(var i=0, cl=this._constraints.length; i<cl; i++){
			this._constraints[i].preApply(dt);
		}

		if (forceInelastic){
			for(var i=0, cl=this._collisions.length; i<cl; i++){
				this.preProcessContactFn(this._collisions[i], dt);
				this._collisions[i].mat.set_restitution(0);
				this._collisions[i].satisfied=false;
			}
		}else{
			for(var i=0, cl=this._collisions.length; i<cl;i++){
				this.preProcessCollisionFn(this._collisions[i], dt);
			}
		}

		var flag;
		var gotOne;
		var len;
		for (var step = 0; step < iter; step++){
			gotOne = false;

			for(var i=0, cl=this._collisions.length; i<cl;i++){
				collInfo=this._collisions[i];
				if (!collInfo.satisfied){
					if (forceInelastic){
						flag = this.processContactFn(collInfo, dt);
						gotOne = gotOne || flag;
					}else{
						flag = this.processCollisionFn(collInfo, dt);
						gotOne = gotOne || flag;
					}
				}
			}
			for(var i=0, cl=this._constraints.length; i<cl; i++){
				var _constraint=this._constraints[i];
				if (!_constraint.get_satisfied()){
					flag = _constraint.apply(dt);
					gotOne = gotOne || flag;
				}
			}
			this.tryToActivateAllFrozenObjects();

			if (forceInelastic){
				len = this._collisions.length;
				for (var j = origNumCollisions; j < len; j++){
					this._collisions[j].mat.set_restitution(0);
					this._collisions[j].satisfied=false;
					this.preProcessContactFn(this._collisions[j], dt);
				}
			}else{
				len = this._collisions.length;
				for (j = origNumCollisions; j < len; j++){
					this.preProcessCollisionFn(this._collisions[j], dt);
				}
			}
			origNumCollisions = this._collisions.length;
			if (!gotOne) break;
		}
	};

	PhysicsSystem.prototype.handleAllEffects=function(){
		var effect;
		var i=this._effects.length-1;
		if (i < 0) return;
		
		do {
			effect=this._effects[i];
			if (effect.enabled) effect.Apply();
		} while(i--);
	};
	
	PhysicsSystem.prototype.activateObject=function(body){
		if (!body.get_movable() || body.isActive)
			return;

		body.setActive();
		this._activeBodies.push(body);
		var orig_num = this._collisions.length;
		this._collisionSystem.detectCollisions(body, this._collisions);
		var other_body;
		var thisBody_normal;
		for (var i=orig_num, len=this._collisions.length; i<len; i++){
			other_body = this._collisions[i].objInfo.body0;
			thisBody_normal = this._collisions[i].dirToBody;
			if (other_body == body){
				other_body = this._collisions[i].objInfo.body1;
				thisBody_normal = JNumber3D.getScaleVector(this._collisions[i].dirToBody, -1);
			}
			if (!other_body.isActive && Vector3DUtil.dotProduct(other_body.get_force(), thisBody_normal) < -JNumber3D.NUM_TINY)
				this.activateObject(other_body);
		}
	};

	PhysicsSystem.prototype.dampAllActiveBodies=function(){
		for(var i=0, abl=this._activeBodies.length; i<abl; i++){
			_activeBody=this._activeBodies[i];
			_activeBody.dampForDeactivation();
		}
	};

	PhysicsSystem.prototype.tryToActivateAllFrozenObjects=function(){
		for(var i=0, bl=this._bodies.length; i<bl; i++){
			var _body=this._bodies[i];
			if (!_body.isActive){
				if (_body.getShouldBeActive()){
					this.activateObject(_body);
				}else{
					if (_body.getVelChanged()){
						_body.setVelocity([0,0,0,0]);
						_body.setAngVel([0,0,0,0]);
						_body.clearVelChanged();
					}
				}
			}	
		}
	};

	PhysicsSystem.prototype.activateAllFrozenObjectsLeftHanging=function(){
		var other_body;
		for(var i=0, bl=this._bodies.length; i<bl; i++){
			var _body=this._bodies[i];
			if (_body.isActive){
				_body.doMovementActivations();
				if (_body.collisions.length > 0){
					for (var j=0, bcl=_body.collisions.length; j<bcl; j++){
						other_body = _body.collisions[j].objInfo.body0;
						if (other_body == _body)
							other_body = _body.collisions[j].objInfo.body1;

						if (!other_body.isActive)							_body.addMovementActivation(_body.get_currentState().position, other_body);
					}
				}
			}
		}
	};

	PhysicsSystem.prototype.updateAllVelocities=function(dt){
		for(var i=0, abl=this._activeBodies.length; i<abl; i++){
			_activeBody=this._activeBodies[i];
			_activeBody.updateVelocity(dt);
		}
	};

	PhysicsSystem.prototype.updateAllPositions=function(dt){
		for(var i=0, abl=this._activeBodies.length; i<abl; i++){
			_activeBody=this._activeBodies[i];
			_activeBody.updatePositionWithAux(dt);
		}
	};

	PhysicsSystem.prototype.notifyAllPostPhysics=function(dt){
		for(var i=0, abl=this._bodies.length; i<abl; i++){
			_body=this._bodies[i];
			_body.postPhysics(dt);
		}
	};

	PhysicsSystem.prototype.updateAllObject3D=function(){
		for(var i=0, abl=this._bodies.length; i<abl; i++){
			_body=this._bodies[i];
			_body.updateObject3D();
		}
	};

	PhysicsSystem.prototype.limitAllVelocities=function(){
		for(var i=0, abl=this._activeBodies.length; i<abl; i++){
			_activeBody=this._activeBodies[i];
			_activeBody.limitVel();
			_activeBody.limitAngVel();
		}
	};

	PhysicsSystem.prototype.tryToFreezeAllObjects=function(dt){
		for(var i=0, abl=this._activeBodies.length; i<abl; i++){
			_activeBody=this._activeBodies[i];
			_activeBody.tryToFreeze(dt);
		}
	};

	PhysicsSystem.prototype.detectAllCollisions=function(dt){
		for (var i=0, abl=this._activeBodies.length; i<abl; i++)
		{
			_activeBody=this._activeBodies[i];
			_activeBody.storeState();
		}
		
		this.updateAllVelocities(dt);
		this.updateAllPositions(dt);
		
		for (var i=0, bl=this._bodies.length; i<bl; i++)
		{
			_body=this._bodies[i];
			_body.collisions = [];
		}
		
		this._collisions = [];
		this._collisionSystem.detectAllCollisions(this._activeBodies, this._collisions);
		
		for (var i=0, abl=this._activeBodies.length; i<abl; i++)
		{
			_activeBody=this._activeBodies[i];
			_activeBody.restoreState();
		}
	};

	PhysicsSystem.prototype.copyAllCurrentStatesToOld=function(){
		for(var i=0, bl=this._bodies.length; i<bl; i++){
			_body=this._bodies[i];
			if (_body.isActive || _body.getVelChanged())
				_body.copyCurrentStateToOld();
		}
	};

	PhysicsSystem.prototype.findAllActiveBodies=function(){
		this._activeBodies = [];
				
		for(var i=0, bl=this._bodies.length; i<bl; i++){
			var _body=this._bodies[i];			if (_body.isActive)
				this._activeBodies.push(_body);
		}
	};

	// Integrates the system forwards by dt - the caller is
	// responsible for making sure that repeated calls to this use
	// the same dt (if desired)
	PhysicsSystem.prototype.integrate=function(dt){
		this._doingIntegration = true;

		this.findAllActiveBodies();
		this.copyAllCurrentStatesToOld();

		this.getAllExternalForces(dt);
		this.handleAllEffects();
		this.detectAllCollisions(dt);
		this.handleAllConstraints(dt, JConfig.numCollisionIterations, false);
		this.updateAllVelocities(dt);
		this.handleAllConstraints(dt, JConfig.numContactIterations, true);

		if (JConfig.doShockStep) {
			this.doShockStep(dt);
		}

		this.dampAllActiveBodies();
		this.tryToFreezeAllObjects(dt);
		this.activateAllFrozenObjectsLeftHanging();

		this.limitAllVelocities();

		this.updateAllPositions(dt);
		this.notifyAllPostPhysics(dt);

		this.updateAllObject3D();
		if (JConfig.solverType == "ACCUMULATED")
			this.updateContactCache();

		for(var i=0, bl=this._bodies.length; i<bl; i++){
			_body=this._bodies[i];
			_body.clearForces();
		}

		this._doingIntegration = false;
	};
	
	jigLib.PhysicsSystem=PhysicsSystem;
	
})(jigLib);
/*
   Copyright (c) 2007 Danny Chapman
   http://www.rowlhouse.co.uk

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any damages
   arising from the use of this software.
   Permission is granted to anyone to use this software for any purpose,
   including commercial applications, and to alter it and redistribute it
   freely, subject to the following restrictions:
   1. The origin of this software must not be misrepresented; you must not
   claim that you wrote the original software. If you use this software
   in a product, an acknowledgment in the product documentation would be
   appreciated but is not required.
   2. Altered source versions must be plainly marked as such, and must not be
   misrepresented as being the original software.
   3. This notice may not be removed or altered from any source
   distribution.
 */

/**
 * @author Muzer(muzerly@gmail.com)
 * @link http://code.google.com/p/jiglibflash
 */

(function(jigLib){
	var Vector3DUtil=jigLib.Vector3DUtil;
	var JNumber3D=jigLib.JNumber3D;
	var JSegment=jigLib.JSegment;
	var JChassis=jigLib.JChassis;
	var JWheel=jigLib.JWheel;
	var PhysicsSystem=jigLib.PhysicsSystem;
	
	// get local refs to Math methods to improve performance
	var mr=Math, mrAbs=mr.abs, mrSqrt=mr.sqrt;
	
	var JCar=function(skin){
		this._chassis = new JChassis(this, skin);
		this._wheels = [];
		this._steerWheels = [];
		this._destSteering = this._destAccelerate = this._steering = this._accelerate = this._HBrake = 0;
		this.setCar();
	};
	
	JCar.prototype._maxSteerAngle=null;
	JCar.prototype._steerRate=null;
	JCar.prototype._driveTorque=null;

	JCar.prototype._destSteering=null;
	JCar.prototype._destAccelerate=null;

	JCar.prototype._steering=null;
	JCar.prototype._accelerate=null;
	JCar.prototype._HBrake=null;

	JCar.prototype._chassis=null;
	JCar.prototype._wheels=null;
	JCar.prototype._steerWheels=null;

	JCar.prototype.setCar=function(maxSteerAngle, steerRate, driveTorque){
		if(maxSteerAngle==null) maxSteerAngle=45;
		if(steerRate==null) steerRate=4;
		if(driveTorque==null) driveTorque=500;
		
		this._maxSteerAngle = maxSteerAngle;
		this._steerRate = steerRate;
		this._driveTorque = driveTorque;
	};

	JCar.prototype.setupWheel=function(_name, pos, wheelSideFriction, wheelFwdFriction, wheelTravel, wheelRadius, wheelRestingFrac, wheelDampingFrac, wheelNumRays, drive){
		if(wheelSideFriction==null) wheelSideFriction=2;
		if(wheelFwdFriction==null) wheelFwdFriction=2;
		if(wheelTravel==null) wheelTravel=3;
		if(wheelRadius==null) wheelRadius=10;
		if(wheelRestingFrac==null) wheelRestingFrac=0.5;
		if(wheelDampingFrac==null) wheelDampingFrac=0.5;
		if(wheelNumRays==null) wheelNumRays=1;
		if(drive==null) drive=1;

		
		var gravity = PhysicsSystem.getInstance().get_gravity().slice(0);
		var mass = this._chassis.get_mass();
		var mass4 = 0.25 * mass;
		var gravityLen = Vector3DUtil.get_length(gravity);

		Vector3DUtil.normalize(gravity);
		var axis = JNumber3D.getScaleVector(gravity,-1);
		var spring = mass4 * gravityLen / (wheelRestingFrac * wheelTravel);
		var inertia = 0.015 * wheelRadius * wheelRadius * mass;
		var damping = wheelDampingFrac/2;
		var normalForce = gravityLen*mass4;
		//var damping = 2 * mrSqrt(spring * mass);
		//damping *= (0.25 * wheelDampingFrac);
//		damping /= this._steerRate;
//		damping *= wheelDampingFrac;

		var wheel = new JWheel(this);
		wheel.name = _name;
		wheel.setup(pos, axis, spring, wheelTravel, inertia, wheelRadius, wheelSideFriction, wheelFwdFriction, damping, wheelNumRays, drive, normalForce);
		this._wheels.push(wheel);
	};

	JCar.prototype.setAccelerate=function(val){
		this._destAccelerate = val;
	};

	JCar.prototype.setSteer=function(wheels, val){
		this._destSteering = val;
		this._steerWheels = [];
		var wheel=null;
		for (var i=0, l=wheels.length; i<l; i++){
			wheel=this.getWheel(wheels[i]);
			if (wheel)
				this._steerWheels.push(wheel);
		}
	};

	JCar.prototype.findWheel=function(_name){
		for (var i=0, l=this._wheels.length; i<l; i++){
			if (this._wheels[i].name == _name) return true;
		}
		return false;
	};
	
	JCar.prototype.getWheel=function(_name){
		for (var i=0; i<this._wheels.length; i++){
			if (this._wheels[i].name == _name) return this._wheels[i];
		}
		return null;
	};
	
	JCar.prototype.setHBrake=function(val){
		this._HBrake = val;
	};

	JCar.prototype.addExternalForces=function(dt){
		for(var i=0, wl=this._wheels.length; i<wl; i++){
			this._wheels[i].addForcesToCar(dt);
		}
	};

	// Update stuff at the end of physics
	JCar.prototype.postPhysics=function(dt){
		for(var i=0, wl=this._wheels.length; i<wl; i++){
			this._wheels[i].update(dt);
		}

		var deltaAccelerate = dt;
		var deltaSteering = dt * this._steerRate;
		var dAccelerate = this._destAccelerate - this._accelerate;

		if (dAccelerate < -deltaAccelerate) dAccelerate = -deltaAccelerate;
		else if (dAccelerate > deltaAccelerate) dAccelerate = deltaAccelerate;

		this._accelerate += dAccelerate;

		var dSteering = this._destSteering - this._steering;

		if (dSteering < -deltaSteering) dSteering = -deltaSteering;
		else if (dSteering > deltaSteering) dSteering = deltaSteering;

		this._steering += dSteering;

		for(var i=0;i<this._wheels.length;i++){
			this._wheels[i].addTorque(this._driveTorque * this._accelerate);
			this._wheels[i].setLock(this._HBrake > 0.5);
		}

		var alpha = mrAbs(this._maxSteerAngle * this._steering);
		var angleSgn = (this._steering > 0) ? 1 : -1;
		for(var i=0, swl=this._steerWheels.length; i<swl; i++){
			this._steerWheels[i].setSteerAngle(angleSgn * alpha);
		}
	};

	JCar.prototype.getNumWheelsOnFloor=function(dt){
		var count = 0;
		for(var i=0, wl=this._wheels.length; i<wl; i++){
			//this._wheels[i].update(dt);
			if (this._wheels[i].getOnFloor()) count++;
		}
		return count;
	};
	
	jigLib.JCar=JCar;
	
})(jigLib);/*
   Copyright (c) 2007 Danny Chapman
   http://www.rowlhouse.co.uk

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any damages
   arising from the use of this software.
   Permission is granted to anyone to use this software for any purpose,
   including commercial applications, and to alter it and redistribute it
   freely, subject to the following restrictions:
   1. The origin of this software must not be misrepresented; you must not
   claim that you wrote the original software. If you use this software
   in a product, an acknowledgment in the product documentation would be
   appreciated but is not required.
   2. Altered source versions must be plainly marked as such, and must not be
   misrepresented as being the original software.
   3. This notice may not be removed or altered from any source
   distribution.
 */

/**
 * @author Muzer(muzerly@gmail.com)
 * @link http://code.google.com/p/jiglibflash
 */

(function(jigLib){
	
	var JNumber3D=jigLib.JNumber3D;
	var JBox=jigLib.JBox;

	var JChassis=function(car, skin, width, depth, height){
		if(width==null) width=40;
		if(depth==null) depth=70;
		if(height==null) height=30;
		
		this.Super(skin, width, depth, height);

		this._car = car;
	};
	jigLib.extend(JChassis,jigLib.JBox);
	
	JChassis.prototype._car=null;
	
	JChassis.prototype.addExternalForces=function(dt){
		this.clearForces();
		this.addGravity();
		this._car.addExternalForces(dt);
	};

	JChassis.prototype.postPhysics=function(dt){
		this._car.postPhysics(dt);
	};
	
	jigLib.JChassis=JChassis;
	
})(jigLib);/*
   Copyright (c) 2007 Danny Chapman
   http://www.rowlhouse.co.uk

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any damages
   arising from the use of this software.
   Permission is granted to anyone to use this software for any purpose,
   including commercial applications, and to alter it and redistribute it
   freely, subject to the following restrictions:
   1. The origin of this software must not be misrepresented; you must not
   claim that you wrote the original software. If you use this software
   in a product, an acknowledgment in the product documentation would be
   appreciated but is not required.
   2. Altered source versions must be plainly marked as such, and must not be
   misrepresented as being the original software.
   3. This notice may not be removed or altered from any source
   distribution.
 */

/**
 * @author Muzer(muzerly@gmail.com)
 * @link http://code.google.com/p/jiglibflash
 */
 
(function(jigLib){
	var Vector3DUtil=jigLib.Vector3DUtil;
	var JMatrix3D=jigLib.JMatrix3D;
	var JNumber3D=jigLib.JNumber3D;
	var JSegment=jigLib.JSegment;
	var JConfig=jigLib.JConfig;
	var PhysicsSystem=jigLib.PhysicsSystem;
	
	// get local refs to Math methods to improve performance
	var mr=Math, mrPI=mr.PI, mrMin=mr.min, mrMax=mr.max, mrCos=mr.cos, mrAbs=mr.abs, mrSqrt=mr.sqrt;
	
	var JWheel=function(car){
		this._car = car;
	};
	
	JWheel.prototype.name = null;
	
	JWheel.prototype.noslipVel = 0.2;
	JWheel.prototype.slipVel = 0.4;
	JWheel.prototype.slipFactor = 0.7;
	JWheel.prototype.smallVel = 3;

	JWheel.prototype._car=null;
	JWheel.prototype._pos=null;
	JWheel.prototype._axisUp=null;
	JWheel.prototype._spring=null;
 	JWheel.prototype._travel=null;
	JWheel.prototype._inertia=null;
	JWheel.prototype._radius=null;
	JWheel.prototype._sideFriction=null;
	JWheel.prototype._fwdFriction=null;
	JWheel.prototype._damping=null;
	JWheel.prototype._numRays=null;

	JWheel.prototype._angVel=null;
	JWheel.prototype._steerAngle=null;
	JWheel.prototype._torque=null;
	JWheel.prototype._driveTorque=null;
	JWheel.prototype._axisAngle=null;
	JWheel.prototype._displacement=null;
	JWheel.prototype._upSpeed=null;
	JWheel.prototype._rotDamping=null;
	JWheel.prototype._normalForce=null;

	JWheel.prototype._locked=null;
	JWheel.prototype._lastDisplacement=null;
	JWheel.prototype._lastOnFloor=null;
	JWheel.prototype._angVelForGrip=null;

	JWheel.prototype.worldPos=null;
	JWheel.prototype.worldAxis=null;
	JWheel.prototype.wheelFwd=null;
	JWheel.prototype.wheelUp=null;
	JWheel.prototype.wheelLeft=null;
	JWheel.prototype.wheelRayEnd=null;
	JWheel.prototype.wheelRay=null;
	JWheel.prototype.groundUp=null;
	JWheel.prototype.groundLeft=null;
	JWheel.prototype.groundFwd=null;
	JWheel.prototype.wheelPointVel=null;
	JWheel.prototype.rimVel=null;
	JWheel.prototype.worldVel=null;
	JWheel.prototype.wheelCentreVel=null;
	
	JWheel.prototype._collSystem=null;
	
	/*
	* pos: position relative to car, in car's space
	* axisUp: in car's space
	* spring: force per suspension offset
	* travel: suspension travel upwards
	* inertia: inertia about the axel
	* radius: wheel radius
	*/
	JWheel.prototype.setup=function(pos, axisUp, spring, travel, inertia, radius, sideFriction, fwdFriction, damping, numRays, drive, normalForce){
		if(spring==null) spring=0;
		if(travel==null) travel=0;
		if(inertia==null) inertia=0;
		if(radius==null) radius=0;
		if(sideFriction==null) sideFriction=0;
		if(fwdFriction==null) fwdFriction=0;
		if(damping==null) damping=0;
		if(numRays==null) numRays=0;
		if(drive==null) drive=0;
		if(normalForce==null) normalForce=0;
		
		this._pos = pos;
		this._axisUp = axisUp;
		this._spring = spring;
		this._travel = travel;
		this._inertia = inertia;
		this._radius = radius;
		this._sideFriction = sideFriction;
		this._fwdFriction = fwdFriction;
		this._damping = damping;
		this._numRays = numRays;
		this._drive = drive;
		this._normalForce = normalForce;
		this._torque = 0;
		this.reset();
	};

	// power
	JWheel.prototype.addTorque=function(torque){
		this._driveTorque += torque;
	};

	// lock/unlock the wheel
	JWheel.prototype.setLock=function(lock){
		this._locked = lock;
	};

	JWheel.prototype.setSteerAngle=function(steer){
		this._steerAngle = steer;
	};

	// get steering angle in degrees
	JWheel.prototype.getSteerAngle=function(){
		return this._steerAngle;
	};

	JWheel.prototype.getPos=function(){
		return this._pos;
	};
	

	// the suspension axis in the car's frame
	JWheel.prototype.getLocalAxisUp=function(){
		return this._axisUp;
	};

	JWheel.prototype.getActualPos=function(){
		return Vector3DUtil.add(this._pos, JNumber3D.getScaleVector(this._axisUp, this._displacement));
	};

	// wheel radius
	JWheel.prototype.getRadius=function(){
		return this._radius;
	};

	// the displacement along our up axis
	JWheel.prototype.getDisplacement=function(){
		return this._displacement;
	};

	JWheel.prototype.getAxisAngle=function(){
		return this._axisAngle;
	};

	JWheel.prototype.getRollAngle=function(){
		return 0.1 * this._angVel * 180 / mrPI;
	};

	JWheel.prototype.setRotationDamping=function(vel){
		this._rotDamping = vel;
	};
	JWheel.prototype.getRotationDamping=function(){
		return this._rotDamping;
	};
				
	//if it's on the ground.
	JWheel.prototype.getOnFloor=function(){
		return this._lastOnFloor;
	};
	var maxforce=0;
	// Adds the forces die to this wheel to the parent. Return value indicates if it's on the ground.
	JWheel.prototype.addForcesToCar=function(dt){
		var force = [0,0,0,0];
		this._lastDisplacement = this._displacement;
		this._displacement = 0;

		var carBody = this._car._chassis;
		worldPos = this._pos.slice(0);
		JMatrix3D.multiplyVector(carBody.get_currentState().get_orientation(), worldPos);
		worldPos = Vector3DUtil.add(carBody.get_currentState().position, worldPos);
		worldAxis = this._axisUp.slice(0);
		JMatrix3D.multiplyVector(carBody.get_currentState().get_orientation(), worldAxis);

		wheelFwd = carBody.get_currentState().getOrientationCols()[2].slice(0);
		JMatrix3D.multiplyVector(JMatrix3D.getRotationMatrix(worldAxis[0], worldAxis[1], worldAxis[2], this._steerAngle/180*2*Math.PI), wheelFwd);
		wheelUp = worldAxis;
		wheelLeft = Vector3DUtil.crossProduct(wheelUp, wheelFwd);
		Vector3DUtil.normalize(wheelLeft);

		var rayLen = 2 * this._radius + this._travel;
		wheelRayEnd = Vector3DUtil.subtract(worldPos, JNumber3D.getScaleVector(worldAxis, this._radius));
		wheelRay = new JSegment(Vector3DUtil.add(wheelRayEnd, JNumber3D.getScaleVector(worldAxis, rayLen)), JNumber3D.getScaleVector(worldAxis, -rayLen));

		if (this._collSystem == null)
			this._collSystem = PhysicsSystem.getInstance().getCollisionSystem();

		var maxNumRays = 10;
		var numRays = mrMin(this._numRays, maxNumRays);

		var objArr = [];
		var segments = [];

		var deltaFwd = (2 * this._radius) / (numRays +1);
		var deltaFwdStart = deltaFwd;

		this._lastOnFloor = false;

		var distFwd;
		var yOffset;
		var bestIRay = 0;
		var iRay = 0;
		var segment = null;
		for (iRay = 0; iRay < numRays; iRay++){
			objArr[iRay] = {};
			distFwd = (deltaFwdStart + iRay * deltaFwd) - this._radius;
			yOffset = this._radius * (1 - mrCos(90 * (distFwd / this._radius) * mrPI / 180));
			segment = wheelRay.clone();
			segment.origin = Vector3DUtil.add(segment.origin, Vector3DUtil.add(JNumber3D.getScaleVector(wheelFwd, distFwd), JNumber3D.getScaleVector(wheelUp, yOffset)));
			
			if (this._collSystem.segmentIntersect(objArr[iRay], segment, carBody)) {
				this._lastOnFloor = true;
				if (objArr[iRay].fracOut < objArr[bestIRay].fracOut){
					bestIRay = iRay;
				}
			}
			segments[iRay] = segment;
		}
		
		if (!this._lastOnFloor) return false;

		var frac= objArr[bestIRay].fracOut;
		var groundPos = objArr[bestIRay].posOut;
		var otherBody = objArr[bestIRay].bodyOut;

		var groundNormal = worldAxis.slice(0);
		if (numRays > 1){
			for (iRay = 0; iRay < numRays; iRay++){
				var rayFracOut=objArr[iRay].fracOut;
				if (rayFracOut <= 1)
					groundNormal = Vector3DUtil.add(groundNormal, JNumber3D.getScaleVector(Vector3DUtil.subtract(worldPos, segments[iRay].getEnd()), 1 - rayFracOut));
			}
			Vector3DUtil.normalize(groundNormal);
		}else groundNormal = objArr[bestIRay].normalOut;
		
		wheelFwd=Vector3DUtil.crossProduct(wheelLeft,groundNormal);
		
		this._displacement = rayLen * (1 - frac);

		if (this._displacement < 0) this._displacement = 0;
		
		var mass = carBody.get_mass();
		var mass4 = mass/4;
		var otherFriction=otherBody.get_friction()
	
		var wheelCenterVel=carBody.getVelocity(this._pos);
		
		
		//hit floor hard
		var origDisplacement=this._displacement;
		if (this._displacement > this._travel){
			this._displacement=this._travel;
			var cv=Vector3DUtil.dotProduct(wheelCenterVel,groundNormal)/dt*mass4;
			cv=cv*2*otherBody.get_restitution()/10;
			extraForce = JNumber3D.getScaleVector(groundNormal, -cv);
			force = Vector3DUtil.add(force, extraForce);
		}
		//suspension spring force
		extraForce = JNumber3D.getScaleVector(this._axisUp, this._spring*this._displacement+this._upSpeed*this._damping);
		force = Vector3DUtil.add(force, extraForce);

		
		groundUp = groundNormal;
		groundLeft = Vector3DUtil.crossProduct(groundNormal, wheelFwd);
		Vector3DUtil.normalize(groundLeft);
		groundFwd = Vector3DUtil.crossProduct(groundLeft, groundUp);
	
		var rimVel = JNumber3D.getScaleVector(Vector3DUtil.crossProduct(groundLeft, Vector3DUtil.subtract(groundPos, worldPos)), -this._angVel);
		var centerVel = JNumber3D.getScaleVector(groundFwd, Vector3DUtil.dotProduct(wheelCenterVel,groundFwd));

		var friction=this._fwdFriction*otherFriction;
		var extraForce = JNumber3D.getScaleVector(Vector3DUtil.subtract(rimVel,centerVel), mass4/dt/this._radius*friction);
		var forceSize=Vector3DUtil.get_length(extraForce);
		if(forceSize>this._normalForce*friction) extraForce = JNumber3D.getScaleVector(extraForce,this._normalForce*friction/forceSize);
		force = Vector3DUtil.add(force, extraForce);		
		this._torque-=Vector3DUtil.dotProduct(Vector3DUtil.subtract(rimVel,centerVel),groundFwd)/this._radius*mass4/dt;
		this._angVelForGrip = Vector3DUtil.dotProduct(wheelCenterVel, groundFwd) / this._radius;

		//sideways friction
		var sideVel = Vector3DUtil.dotProduct(wheelCenterVel,groundLeft);
		var friction=this._sideFriction*otherFriction;		
		var leftVel = JNumber3D.getScaleVector(groundLeft, -sideVel*friction);

		
		var extraForce = JNumber3D.getScaleVector(leftVel, mass4/dt/this._radius);	
		var forceSize=Vector3DUtil.get_length(extraForce);
		if(forceSize>this._normalForce*friction) extraForce = JNumber3D.getScaleVector(extraForce,this._normalForce*friction/forceSize);
		
		force = Vector3DUtil.add(force, extraForce);

		carBody.addWorldForce(force, groundPos);
		if (otherBody.get_movable()){
			var maxOtherBodyAcc = 500;
			var maxOtherBodyForce = maxOtherBodyAcc * otherBody.get_mass();
			if (Vector3DUtil.get_lengthSquared(force) > (maxOtherBodyForce * maxOtherBodyForce))
				force = JNumber3D.getScaleVector(force, maxOtherBodyForce / Vector3DUtil.get_length(force));

			otherBody.addWorldForce(JNumber3D.getScaleVector(force, -1), groundPos);
		}
		return true;
	};

	// Updates the rotational state etc
	JWheel.prototype.update=function(dt){
		if (dt <= 0) return;

		var origAngVel = this._angVel;
		this._upSpeed = (this._displacement - this._lastDisplacement) / mrMax(dt, JNumber3D.NUM_TINY);

		if (this._locked){
			this._angVel = 0;
			this._torque = 0;
		}else{					
			this._angVel += (this._torque * dt / this._inertia);
			this._torque = 0;
			
			if (((origAngVel > this._angVelForGrip) && (this._angVel < this._angVelForGrip)) || ((origAngVel < this._angVelForGrip) && (this._angVel > this._angVelForGrip)))
				this._angVel = this._angVelForGrip;
			
			
			this._angVel += this._driveTorque * dt / this._inertia * this._drive;
			this._driveTorque = 0;

			if (this._angVel < -100) this._angVel = -100;
			else if (this._angVel > 100) this._angVel = 100;
			
			this._angVel *= this._rotDamping;
			this._axisAngle += (this._angVel * dt * 180 / mrPI);
		}
	};

	JWheel.prototype.reset=function(){
		this._angVel = 0;
		this._steerAngle = 0;
		this._torque = 0;
		this._driveTorque = 0;
		this._axisAngle = 0;
		this._displacement = 0;
		this._upSpeed = 0;
		this._locked = false;
		this._lastDisplacement = 0;
		this._lastOnFloor = false;
		this._angVelForGrip = 0;
		this._rotDamping = 0.99;
	};
	
	jigLib.JWheel=JWheel;
	
})(jigLib);